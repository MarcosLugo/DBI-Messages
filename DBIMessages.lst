CCS PCH C Compiler, Version 5.083, 5967               15-nov.-19 15:53

               Filename:   G:\Mi unidad\Proyectos Documentados\DBI Messages\DBIMessages.lst

               ROM used:   27292 bytes (42%)
                           Largest free fragment is 38240
               RAM used:   1741 (48%) at main() level
                           2021 (55%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   2626
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.1
00056:  GOTO   0060
0005A:  BTFSC  F9E.1
0005C:  GOTO   0394
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   04FE
0006C:  BTFSS  FA3.5
0006E:  GOTO   0078
00072:  BTFSC  FA4.5
00074:  GOTO   0638
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVF   04,W
000BC:  MOVFF  06,FE0
000C0:  MOVFF  05,FD8
000C4:  RETFIE 0
.................... #include <DBIMessages.h> 
.................... #include <18F26K80.h> 
.................... //////////// Standard Header file for the PIC18F26K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F26K80 
*
003CE:  TSTFSZ 01
003D0:  BRA    03D8
003D2:  TSTFSZ 02
003D4:  BRA    03DA
003D6:  BRA    03E6
003D8:  INCF   02,F
003DA:  MOVFF  00,FEE
003DE:  DECFSZ 01,F
003E0:  BRA    03DA
003E2:  DECFSZ 02,F
003E4:  BRA    03DA
003E6:  RETURN 0
*
0064E:  DATA 54,68
00650:  DATA 65,20
00652:  DATA 44,42
00654:  DATA 49,20
00656:  DATA 69,73
00658:  DATA 20,74
0065A:  DATA 75,72
0065C:  DATA 6E,65
0065E:  DATA 64,20
00660:  DATA 4F,4E
00662:  DATA 00,00
00664:  DATA 44,61
00666:  DATA 74,61
00668:  DATA 20,4C
0066A:  DATA 65,6E
0066C:  DATA 67,74
0066E:  DATA 68,20
00670:  DATA 4E,6F
00672:  DATA 74,20
00674:  DATA 41,6C
00676:  DATA 6C,6F
00678:  DATA 77,65
0067A:  DATA 64,00
0067C:  DATA 4D,49
0067E:  DATA 4D,45
00680:  DATA 20,4D
00682:  DATA 65,73
00684:  DATA 73,61
00686:  DATA 67,65
00688:  DATA 20,52
0068A:  DATA 65,63
0068C:  DATA 65,69
0068E:  DATA 76,65
00690:  DATA 64,00
00692:  DATA 57,61
00694:  DATA 69,74
00696:  DATA 69,6E
00698:  DATA 67,20
0069A:  DATA 4D,49
0069C:  DATA 4D,45
0069E:  DATA 20,41
006A0:  DATA 43,4B
006A2:  DATA 00,00
006A4:  DATA 54,68
006A6:  DATA 65,20
006A8:  DATA 49,4F
006AA:  DATA 58,20
006AC:  DATA 69,73
006AE:  DATA 20,4E
006B0:  DATA 6F,74
006B2:  DATA 20,53
006B4:  DATA 79,6E
006B6:  DATA 63,68
006B8:  DATA 72,6F
006BA:  DATA 6E,69
006BC:  DATA 7A,65
006BE:  DATA 64,00
006C0:  DATA 57,61
006C2:  DATA 69,74
006C4:  DATA 20,25
006C6:  DATA 6C,75
006C8:  DATA 20,53
006CA:  DATA 20,54
006CC:  DATA 6F,20
006CE:  DATA 53,65
006D0:  DATA 6E,64
006D2:  DATA 20,61
006D4:  DATA 20,54
006D6:  DATA 65,78
006D8:  DATA 74,20
006DA:  DATA 4D,65
006DC:  DATA 73,73
006DE:  DATA 61,67
006E0:  DATA 65,20
006E2:  DATA 41,67
006E4:  DATA 61,69
006E6:  DATA 6E,00
006E8:  DATA 4D,49
006EA:  DATA 4D,45
006EC:  DATA 20,4D
006EE:  DATA 65,73
006F0:  DATA 73,61
006F2:  DATA 67,65
006F4:  DATA 20,74
006F6:  DATA 6F,20
006F8:  DATA 53,65
006FA:  DATA 72,76
006FC:  DATA 65,72
006FE:  DATA 20,4E
00700:  DATA 6F,74
00702:  DATA 20,41
00704:  DATA 6C,6C
00706:  DATA 6F,77
00708:  DATA 65,64
0070A:  DATA 00,00
0070C:  DATA 44,61
0070E:  DATA 74,61
00710:  DATA 20,4C
00712:  DATA 65,6E
00714:  DATA 67,74
00716:  DATA 68,20
00718:  DATA 4E,6F
0071A:  DATA 74,20
0071C:  DATA 41,6C
0071E:  DATA 6C,6F
00720:  DATA 77,65
00722:  DATA 64,00
00724:  DATA 43,75
00726:  DATA 73,74
00728:  DATA 6F,6D
0072A:  DATA 20,44
0072C:  DATA 61,74
0072E:  DATA 61,20
00730:  DATA 52,65
00732:  DATA 63,65
00734:  DATA 69,76
00736:  DATA 65,64
00738:  DATA 00,00
0073A:  DATA 54,68
0073C:  DATA 65,20
0073E:  DATA 49,4F
00740:  DATA 58,20
00742:  DATA 69,73
00744:  DATA 20,4E
00746:  DATA 6F,74
00748:  DATA 20,53
0074A:  DATA 79,6E
0074C:  DATA 63,68
0074E:  DATA 72,6F
00750:  DATA 6E,69
00752:  DATA 7A,65
00754:  DATA 64,00
00756:  DATA 57,61
00758:  DATA 74,74
0075A:  DATA 69,6E
0075C:  DATA 67,20
0075E:  DATA 43,75
00760:  DATA 73,74
00762:  DATA 6F,6D
00764:  DATA 20,44
00766:  DATA 61,74
00768:  DATA 61,20
0076A:  DATA 41,43
0076C:  DATA 4B,00
0076E:  DATA 57,61
00770:  DATA 74,74
00772:  DATA 69,6E
00774:  DATA 67,20
00776:  DATA 53,74
00778:  DATA 61,74
0077A:  DATA 75,73
0077C:  DATA 20,44
0077E:  DATA 61,74
00780:  DATA 61,20
00782:  DATA 41,43
00784:  DATA 4B,00
00786:  DATA 57,61
00788:  DATA 69,74
0078A:  DATA 20,25
0078C:  DATA 6C,75
0078E:  DATA 20,53
00790:  DATA 20,54
00792:  DATA 6F,20
00794:  DATA 53,65
00796:  DATA 6E,64
00798:  DATA 20,61
0079A:  DATA 20,43
0079C:  DATA 75,73
0079E:  DATA 74,6F
007A0:  DATA 6D,20
007A2:  DATA 44,61
007A4:  DATA 74,61
007A6:  DATA 20,41
007A8:  DATA 67,61
007AA:  DATA 69,6E
007AC:  DATA 00,00
007AE:  DATA 43,75
007B0:  DATA 73,74
007B2:  DATA 6F,6D
007B4:  DATA 20,44
007B6:  DATA 61,74
007B8:  DATA 61,20
007BA:  DATA 4E,6F
007BC:  DATA 74,20
007BE:  DATA 53,75
007C0:  DATA 70,70
007C2:  DATA 6F,72
007C4:  DATA 74,65
007C6:  DATA 64,00
007C8:  DATA 44,61
007CA:  DATA 74,61
007CC:  DATA 20,4C
007CE:  DATA 65,6E
007D0:  DATA 67,74
007D2:  DATA 68,20
007D4:  DATA 4E,6F
007D6:  DATA 74,20
007D8:  DATA 41,6C
007DA:  DATA 6C,6F
007DC:  DATA 77,65
007DE:  DATA 64,00
007E0:  DATA 53,74
007E2:  DATA 61,74
007E4:  DATA 75,73
007E6:  DATA 20,44
007E8:  DATA 61,74
007EA:  DATA 61,20
007EC:  DATA 52,65
007EE:  DATA 63,65
007F0:  DATA 69,76
007F2:  DATA 65,64
007F4:  DATA 00,00
007F6:  DATA 54,68
007F8:  DATA 65,20
007FA:  DATA 49,4F
007FC:  DATA 58,20
007FE:  DATA 69,73
00800:  DATA 20,4E
00802:  DATA 6F,74
00804:  DATA 20,53
00806:  DATA 79,6E
00808:  DATA 63,68
0080A:  DATA 72,6F
0080C:  DATA 6E,69
0080E:  DATA 7A,65
00810:  DATA 64,00
00812:  DATA 57,61
00814:  DATA 69,74
00816:  DATA 69,6E
00818:  DATA 67,20
0081A:  DATA 43,75
0081C:  DATA 73,74
0081E:  DATA 6F,6D
00820:  DATA 20,44
00822:  DATA 61,74
00824:  DATA 61,20
00826:  DATA 41,43
00828:  DATA 4B,00
0082A:  DATA 57,61
0082C:  DATA 69,74
0082E:  DATA 69,6E
00830:  DATA 67,20
00832:  DATA 53,74
00834:  DATA 61,74
00836:  DATA 75,73
00838:  DATA 20,44
0083A:  DATA 61,74
0083C:  DATA 61,20
0083E:  DATA 41,43
00840:  DATA 4B,00
00842:  DATA 53,74
00844:  DATA 61,74
00846:  DATA 75,73
00848:  DATA 20,44
0084A:  DATA 61,74
0084C:  DATA 61,20
0084E:  DATA 4E,6F
00850:  DATA 74,20
00852:  DATA 53,75
00854:  DATA 70,70
00856:  DATA 6F,72
00858:  DATA 74,65
0085A:  DATA 64,00
0085C:  DATA 57,61
0085E:  DATA 69,74
00860:  DATA 69,6E
00862:  DATA 67,20
00864:  DATA 43,75
00866:  DATA 73,74
00868:  DATA 6F,6D
0086A:  DATA 20,61
0086C:  DATA 6E,64
0086E:  DATA 20,53
00870:  DATA 74,61
00872:  DATA 74,75
00874:  DATA 73,20
00876:  DATA 44,61
00878:  DATA 74,61
0087A:  DATA 20,43
0087C:  DATA 61,6E
0087E:  DATA 63,65
00880:  DATA 6C,6C
00882:  DATA 65,64
00884:  DATA 00,00
00886:  DATA 50,69
00888:  DATA 6E,67
0088A:  DATA 20,4F
0088C:  DATA 6B,00
0088E:  DATA 4E,6F
00890:  DATA 20,47
00892:  DATA 6F,20
00894:  DATA 49,6E
00896:  DATA 66,6F
00898:  DATA 20,44
0089A:  DATA 61,74
0089C:  DATA 61,20
0089E:  DATA 41,76
008A0:  DATA 61,69
008A2:  DATA 6C,61
008A4:  DATA 62,6C
008A6:  DATA 65,00
008A8:  DATA 54,68
008AA:  DATA 65,20
008AC:  DATA 49,4F
008AE:  DATA 58,20
008B0:  DATA 69,73
008B2:  DATA 20,4E
008B4:  DATA 6F,74
008B6:  DATA 20,53
008B8:  DATA 79,6E
008BA:  DATA 63,68
008BC:  DATA 72,6F
008BE:  DATA 6E,69
008C0:  DATA 7A,65
008C2:  DATA 64,00
008C4:  DATA 47,6F
008C6:  DATA 20,49
008C8:  DATA 6E,66
008CA:  DATA 6F,20
008CC:  DATA 52,65
008CE:  DATA 71,75
008D0:  DATA 65,73
008D2:  DATA 74,20
008D4:  DATA 4E,6F
008D6:  DATA 74,20
008D8:  DATA 53,75
008DA:  DATA 70,70
008DC:  DATA 6F,72
008DE:  DATA 74,65
008E0:  DATA 64,00
008E2:  DATA 4D,49
008E4:  DATA 4D,45
008E6:  DATA 20,57
008E8:  DATA 61,69
008EA:  DATA 74,69
008EC:  DATA 6E,67
008EE:  DATA 20,41
008F0:  DATA 43,4B
008F2:  DATA 20,46
008F4:  DATA 72,6F
008F6:  DATA 6D,20
008F8:  DATA 53,65
008FA:  DATA 72,76
008FC:  DATA 65,72
008FE:  DATA 20,43
00900:  DATA 61,6E
00902:  DATA 63,65
00904:  DATA 6C,6C
00906:  DATA 65,64
00908:  DATA 00,00
0090A:  DATA 54,68
0090C:  DATA 65,20
0090E:  DATA 41,63
00910:  DATA 74,75
00912:  DATA 61,74
00914:  DATA 6F,72
00916:  DATA 20,69
00918:  DATA 73,20
0091A:  DATA 43,6F
0091C:  DATA 6E,66
0091E:  DATA 69,67
00920:  DATA 75,72
00922:  DATA 65,64
00924:  DATA 20,61
00926:  DATA 73,20
00928:  DATA 54,69
0092A:  DATA 6D,65
0092C:  DATA 64,20
0092E:  DATA 4F,75
00930:  DATA 74,70
00932:  DATA 75,74
00934:  DATA 00,00
00936:  DATA 54,68
00938:  DATA 65,20
0093A:  DATA 41,63
0093C:  DATA 74,75
0093E:  DATA 61,74
00940:  DATA 6F,72
00942:  DATA 20,69
00944:  DATA 73,20
00946:  DATA 43,6F
00948:  DATA 6E,66
0094A:  DATA 69,67
0094C:  DATA 75,72
0094E:  DATA 65,64
00950:  DATA 20,61
00952:  DATA 73,20
00954:  DATA 4F,75
00956:  DATA 74,70
00958:  DATA 75,74
0095A:  DATA 00,00
0095C:  DATA 54,68
0095E:  DATA 65,20
00960:  DATA 41,63
00962:  DATA 74,75
00964:  DATA 61,74
00966:  DATA 6F,72
00968:  DATA 20,69
0096A:  DATA 73,20
0096C:  DATA 4E,6F
0096E:  DATA 74,20
00970:  DATA 43,6F
00972:  DATA 6E,66
00974:  DATA 69,67
00976:  DATA 75,72
00978:  DATA 65,64
0097A:  DATA 00,00
0097C:  DATA 54,68
0097E:  DATA 65,20
00980:  DATA 54,69
00982:  DATA 6D,65
00984:  DATA 64,20
00986:  DATA 41,63
00988:  DATA 74,75
0098A:  DATA 61,74
0098C:  DATA 6F,72
0098E:  DATA 20,69
00990:  DATA 73,20
00992:  DATA 47,6F
00994:  DATA 69,6E
00996:  DATA 67,20
00998:  DATA 74,6F
0099A:  DATA 20,62
0099C:  DATA 65,20
0099E:  DATA 41,70
009A0:  DATA 70,6C
009A2:  DATA 69,65
009A4:  DATA 64,20
009A6:  DATA 69,6E
009A8:  DATA 20,25
009AA:  DATA 4C,55
009AC:  DATA 20,53
009AE:  DATA 20,44
009B0:  DATA 75,72
009B2:  DATA 69,6E
009B4:  DATA 67,20
009B6:  DATA 25,4C
009B8:  DATA 55,20
009BA:  DATA 53,20
009BC:  DATA 62,79
009BE:  DATA 20,50
009C0:  DATA 43,00
009C2:  DATA 41,63
009C4:  DATA 74,20
009C6:  DATA 50,43
009C8:  DATA 20,54
009CA:  DATA 4F,20
009CC:  DATA 25,4C
009CE:  DATA 75,20
009D0:  DATA 25,4C
009D2:  DATA 75,21
009D4:  DATA 00,00
009D6:  DATA 54,68
009D8:  DATA 65,20
009DA:  DATA 54,69
009DC:  DATA 6D,65
009DE:  DATA 64,20
009E0:  DATA 41,63
009E2:  DATA 74,75
009E4:  DATA 61,74
009E6:  DATA 6F,72
009E8:  DATA 20,69
009EA:  DATA 73,20
009EC:  DATA 47,6F
009EE:  DATA 69,6E
009F0:  DATA 67,20
009F2:  DATA 74,6F
009F4:  DATA 20,62
009F6:  DATA 65,20
009F8:  DATA 41,70
009FA:  DATA 70,6C
009FC:  DATA 69,65
009FE:  DATA 64,20
00A00:  DATA 69,6E
00A02:  DATA 20,25
00A04:  DATA 4C,55
00A06:  DATA 20,53
00A08:  DATA 20,44
00A0A:  DATA 75,72
00A0C:  DATA 69,6E
00A0E:  DATA 67,20
00A10:  DATA 25,4C
00A12:  DATA 55,20
00A14:  DATA 53,20
00A16:  DATA 62,79
00A18:  DATA 20,50
00A1A:  DATA 43,00
00A1C:  DATA 41,63
00A1E:  DATA 74,20
00A20:  DATA 50,43
00A22:  DATA 20,54
00A24:  DATA 4F,20
00A26:  DATA 25,4C
00A28:  DATA 75,20
00A2A:  DATA 25,4C
00A2C:  DATA 75,21
00A2E:  DATA 00,00
00A30:  DATA 54,68
00A32:  DATA 65,20
00A34:  DATA 41,63
00A36:  DATA 74,75
00A38:  DATA 61,74
00A3A:  DATA 6F,72
00A3C:  DATA 20,69
00A3E:  DATA 73,20
00A40:  DATA 43,6F
00A42:  DATA 6E,66
00A44:  DATA 69,67
00A46:  DATA 75,72
00A48:  DATA 65,64
00A4A:  DATA 20,61
00A4C:  DATA 73,20
00A4E:  DATA 4F,75
00A50:  DATA 74,70
00A52:  DATA 75,74
00A54:  DATA 00,00
00A56:  DATA 4C,6F
00A58:  DATA 63,61
00A5A:  DATA 6C,20
00A5C:  DATA 54,69
00A5E:  DATA 6D,65
00A60:  DATA 64,20
00A62:  DATA 41,63
00A64:  DATA 74,75
00A66:  DATA 61,74
00A68:  DATA 6F,72
00A6A:  DATA 20,43
00A6C:  DATA 6F,6E
00A6E:  DATA 74,72
00A70:  DATA 6F,6C
00A72:  DATA 20,4E
00A74:  DATA 6F,74
00A76:  DATA 20,53
00A78:  DATA 75,70
00A7A:  DATA 70,6F
00A7C:  DATA 72,74
00A7E:  DATA 65,64
00A80:  DATA 00,00
00A82:  DATA 41,63
00A84:  DATA 74,75
00A86:  DATA 61,74
00A88:  DATA 6F,72
00A8A:  DATA 20,44
00A8C:  DATA 65,73
00A8E:  DATA 69,72
00A90:  DATA 65,64
00A92:  DATA 20,53
00A94:  DATA 74,61
00A96:  DATA 74,75
00A98:  DATA 73,20
00A9A:  DATA 3D,20
00A9C:  DATA 25,55
00A9E:  DATA 20,62
00AA0:  DATA 79,20
00AA2:  DATA 50,43
00AA4:  DATA 00,00
00AA6:  DATA 41,63
00AA8:  DATA 74,20
00AAA:  DATA 50,43
00AAC:  DATA 20,4F
00AAE:  DATA 20,25
00AB0:  DATA 75,21
00AB2:  DATA 00,00
00AB4:  DATA 54,68
00AB6:  DATA 65,20
00AB8:  DATA 41,63
00ABA:  DATA 74,75
00ABC:  DATA 61,74
00ABE:  DATA 6F,72
00AC0:  DATA 20,69
00AC2:  DATA 73,20
00AC4:  DATA 43,6F
00AC6:  DATA 6E,66
00AC8:  DATA 69,67
00ACA:  DATA 75,72
00ACC:  DATA 65,64
00ACE:  DATA 20,61
00AD0:  DATA 73,20
00AD2:  DATA 54,69
00AD4:  DATA 6D,65
00AD6:  DATA 64,20
00AD8:  DATA 4F,75
00ADA:  DATA 74,70
00ADC:  DATA 75,74
00ADE:  DATA 00,00
00AE0:  DATA 4C,6F
00AE2:  DATA 63,61
00AE4:  DATA 6C,20
00AE6:  DATA 41,63
00AE8:  DATA 74,75
00AEA:  DATA 61,74
00AEC:  DATA 6F,72
00AEE:  DATA 20,43
00AF0:  DATA 6F,6E
00AF2:  DATA 74,72
00AF4:  DATA 6F,6C
00AF6:  DATA 20,4E
00AF8:  DATA 6F,74
00AFA:  DATA 20,53
00AFC:  DATA 75,70
00AFE:  DATA 70,6F
00B00:  DATA 72,74
00B02:  DATA 65,64
00B04:  DATA 00,00
00B06:  DATA 41,63
00B08:  DATA 74,75
00B0A:  DATA 61,74
00B0C:  DATA 6F,72
00B0E:  DATA 20,52
00B10:  DATA 65,71
00B12:  DATA 75,65
00B14:  DATA 73,74
00B16:  DATA 20,43
00B18:  DATA 61,6E
00B1A:  DATA 63,65
00B1C:  DATA 6C,6C
00B1E:  DATA 65,64
00B20:  DATA 00,00
00B22:  DATA 41,63
00B24:  DATA 74,20
00B26:  DATA 50,43
00B28:  DATA 20,43
00B2A:  DATA 61,6E
00B2C:  DATA 63,65
00B2E:  DATA 6C,6C
00B30:  DATA 65,64
00B32:  DATA 21,00
00B34:  DATA 41,63
00B36:  DATA 74,75
00B38:  DATA 61,74
00B3A:  DATA 6F,72
00B3C:  DATA 20,52
00B3E:  DATA 65,71
00B40:  DATA 75,65
00B42:  DATA 73,74
00B44:  DATA 20,4E
00B46:  DATA 6F,74
00B48:  DATA 20,43
00B4A:  DATA 61,6E
00B4C:  DATA 63,65
00B4E:  DATA 6C,6C
00B50:  DATA 65,64
00B52:  DATA 20,44
00B54:  DATA 75,65
00B56:  DATA 20,54
00B58:  DATA 69,6D
00B5A:  DATA 65,4F
00B5C:  DATA 75,74
00B5E:  DATA 00,00
00B60:  DATA 41,63
00B62:  DATA 74,75
00B64:  DATA 61,74
00B66:  DATA 6F,72
00B68:  DATA 20,56
00B6A:  DATA 61,6C
00B6C:  DATA 75,65
00B6E:  DATA 3A,20
00B70:  DATA 25,75
00B72:  DATA 00,00
00B74:  DATA 44,42
00B76:  DATA 49,20
00B78:  DATA 69,73
00B7A:  DATA 20,67
00B7C:  DATA 6F,69
00B7E:  DATA 6E,67
00B80:  DATA 20,74
00B82:  DATA 6F,20
00B84:  DATA 62,65
00B86:  DATA 20,72
00B88:  DATA 65,73
00B8A:  DATA 74,61
00B8C:  DATA 72,74
00B8E:  DATA 65,64
00B90:  DATA 20,69
00B92:  DATA 6E,20
00B94:  DATA 32,20
00B96:  DATA 73,65
00B98:  DATA 63,6F
00B9A:  DATA 6E,64
00B9C:  DATA 73,20
00B9E:  DATA 42,79
00BA0:  DATA 20,50
00BA2:  DATA 43,00
00BA4:  DATA 54,68
00BA6:  DATA 65,20
00BA8:  DATA 49,4F
00BAA:  DATA 58,20
00BAC:  DATA 69,73
00BAE:  DATA 20,53
00BB0:  DATA 79,6E
00BB2:  DATA 63,68
00BB4:  DATA 72,6F
00BB6:  DATA 6E,69
00BB8:  DATA 7A,65
00BBA:  DATA 64,00
00BBC:  DATA 54,68
00BBE:  DATA 65,20
00BC0:  DATA 49,4F
00BC2:  DATA 58,20
00BC4:  DATA 69,73
00BC6:  DATA 20,4E
00BC8:  DATA 6F,74
00BCA:  DATA 20,53
00BCC:  DATA 79,6E
00BCE:  DATA 63,68
00BD0:  DATA 72,6F
00BD2:  DATA 6E,69
00BD4:  DATA 7A,65
00BD6:  DATA 64,00
00BD8:  DATA 46,69
00BDA:  DATA 6D,72
00BDC:  DATA 77,61
00BDE:  DATA 72,65
00BE0:  DATA 20,56
00BE2:  DATA 65,72
00BE4:  DATA 73,69
00BE6:  DATA 6F,6E
00BE8:  DATA 3A,20
00BEA:  DATA 25,75
00BEC:  DATA 2E,25
00BEE:  DATA 75,00
00BF0:  DATA 48,61
00BF2:  DATA 72,64
00BF4:  DATA 77,61
00BF6:  DATA 72,65
00BF8:  DATA 20,56
00BFA:  DATA 65,72
00BFC:  DATA 73,69
00BFE:  DATA 6F,6E
00C00:  DATA 3A,20
00C02:  DATA 25,75
00C04:  DATA 2E,25
00C06:  DATA 75,00
00C08:  DATA 49,67
00C0A:  DATA 6E,69
00C0C:  DATA 74,69
00C0E:  DATA 6F,6E
00C10:  DATA 20,4F
00C12:  DATA 4E,00
00C14:  DATA 49,67
00C16:  DATA 6E,69
00C18:  DATA 74,69
00C1A:  DATA 6F,6E
00C1C:  DATA 20,4F
00C1E:  DATA 46,46
00C20:  DATA 00,00
00C22:  DATA 49,6E
00C24:  DATA 70,75
00C26:  DATA 74,20
00C28:  DATA 56,61
00C2A:  DATA 6C,75
00C2C:  DATA 65,3A
00C2E:  DATA 20,25
00C30:  DATA 75,00
00C32:  DATA 49,6E
00C34:  DATA 70,75
00C36:  DATA 74,20
00C38:  DATA 53,74
00C3A:  DATA 61,74
00C3C:  DATA 65,20
00C3E:  DATA 52,65
00C40:  DATA 71,75
00C42:  DATA 65,73
00C44:  DATA 74,20
00C46:  DATA 4E,6F
00C48:  DATA 74,20
00C4A:  DATA 53,75
00C4C:  DATA 70,70
00C4E:  DATA 6F,72
00C50:  DATA 74,65
00C52:  DATA 64,00
00C54:  DATA 53,65
00C56:  DATA 72,69
00C58:  DATA 61,6C
00C5A:  DATA 20,49
00C5C:  DATA 44,3A
00C5E:  DATA 20,25
00C60:  DATA 4C,58
00C62:  DATA 25,58
00C64:  DATA 25,58
00C66:  DATA 25,58
00C68:  DATA 25,58
00C6A:  DATA 25,58
00C6C:  DATA 25,58
00C6E:  DATA 25,58
00C70:  DATA 25,58
00C72:  DATA 00,00
00C74:  DATA 55,6E
00C76:  DATA 69,64
00C78:  DATA 65,6E
00C7A:  DATA 74,69
00C7C:  DATA 66,69
00C7E:  DATA 65,64
00C80:  DATA 20,43
00C82:  DATA 6F,6D
00C84:  DATA 6D,61
00C86:  DATA 6E,64
00C88:  DATA 00,00
00C8A:  DATA 43,68
00C8C:  DATA 65,63
00C8E:  DATA 6B,73
00C90:  DATA 75,6D
00C92:  DATA 20,46
00C94:  DATA 61,69
00C96:  DATA 6C,00
00C98:  DATA 49,6E
00C9A:  DATA 76,61
00C9C:  DATA 6C,69
00C9E:  DATA 64,20
00CA0:  DATA 46,72
00CA2:  DATA 61,6D
00CA4:  DATA 65,20
00CA6:  DATA 46,6F
00CA8:  DATA 72,6D
00CAA:  DATA 61,74
00CAC:  DATA 00,00
00CAE:  DATA 54,68
00CB0:  DATA 65,20
00CB2:  DATA 49,4F
00CB4:  DATA 58,20
00CB6:  DATA 69,73
00CB8:  DATA 20,53
00CBA:  DATA 79,6E
00CBC:  DATA 63,68
00CBE:  DATA 72,6F
00CC0:  DATA 6E,69
00CC2:  DATA 7A,65
00CC4:  DATA 64,00
00CC6:  DATA 54,68
00CC8:  DATA 65,20
00CCA:  DATA 49,4F
00CCC:  DATA 58,20
00CCE:  DATA 69,73
00CD0:  DATA 20,4E
00CD2:  DATA 6F,74
00CD4:  DATA 20,53
00CD6:  DATA 79,6E
00CD8:  DATA 63,68
00CDA:  DATA 72,6F
00CDC:  DATA 6E,69
00CDE:  DATA 7A,65
00CE0:  DATA 64,00
00CE2:  DATA 43,75
00CE4:  DATA 73,74
00CE6:  DATA 6F,6D
00CE8:  DATA 20,44
00CEA:  DATA 61,74
00CEC:  DATA 61,20
00CEE:  DATA 53,65
00CF0:  DATA 6E,74
00CF2:  DATA 00,00
00CF4:  DATA 53,74
00CF6:  DATA 61,74
00CF8:  DATA 75,73
00CFA:  DATA 20,44
00CFC:  DATA 61,74
00CFE:  DATA 61,20
00D00:  DATA 53,65
00D02:  DATA 6E,74
00D04:  DATA 00,00
00D06:  DATA 4D,49
00D08:  DATA 4D,45
00D0A:  DATA 20,4D
00D0C:  DATA 65,73
00D0E:  DATA 73,61
00D10:  DATA 67,65
00D12:  DATA 20,53
00D14:  DATA 65,6E
00D16:  DATA 74,00
00D18:  DATA 4D,49
00D1A:  DATA 4D,45
00D1C:  DATA 20,4D
00D1E:  DATA 65,73
00D20:  DATA 73,61
00D22:  DATA 67,65
00D24:  DATA 20,46
00D26:  DATA 61,69
00D28:  DATA 6C,65
00D2A:  DATA 64,00
00D2C:  DATA 4D,65
00D2E:  DATA 73,73
00D30:  DATA 61,67
00D32:  DATA 65,20
00D34:  DATA 44,65
00D36:  DATA 6C,69
00D38:  DATA 76,65
00D3A:  DATA 72,65
00D3C:  DATA 64,00
00D3E:  DATA 4D,49
00D40:  DATA 4D,45
00D42:  DATA 20,4D
00D44:  DATA 65,73
00D46:  DATA 73,61
00D48:  DATA 67,65
00D4A:  DATA 73,20
00D4C:  DATA 46,72
00D4E:  DATA 6F,6D
00D50:  DATA 20,53
00D52:  DATA 65,72
00D54:  DATA 76,65
00D56:  DATA 72,20
00D58:  DATA 4E,6F
00D5A:  DATA 74,20
00D5C:  DATA 53,75
00D5E:  DATA 70,70
00D60:  DATA 6F,72
00D62:  DATA 74,65
00D64:  DATA 64,00
00D66:  DATA 41,63
00D68:  DATA 74,75
00D6A:  DATA 61,74
00D6C:  DATA 6F,72
00D6E:  DATA 20,44
00D70:  DATA 65,73
00D72:  DATA 69,72
00D74:  DATA 65,64
00D76:  DATA 20,53
00D78:  DATA 74,61
00D7A:  DATA 74,75
00D7C:  DATA 73,20
00D7E:  DATA 3D,20
00D80:  DATA 25,55
00D82:  DATA 20,62
00D84:  DATA 79,20
00D86:  DATA 53,65
00D88:  DATA 72,76
00D8A:  DATA 65,72
00D8C:  DATA 00,00
00D8E:  DATA 41,63
00D90:  DATA 74,20
00D92:  DATA 53,65
00D94:  DATA 72,76
00D96:  DATA 65,72
00D98:  DATA 20,4F
00D9A:  DATA 20,31
00D9C:  DATA 21,00
00D9E:  DATA 41,63
00DA0:  DATA 74,75
00DA2:  DATA 61,74
00DA4:  DATA 6F,72
00DA6:  DATA 20,44
00DA8:  DATA 65,73
00DAA:  DATA 69,72
00DAC:  DATA 65,64
00DAE:  DATA 20,53
00DB0:  DATA 74,61
00DB2:  DATA 74,75
00DB4:  DATA 73,20
00DB6:  DATA 3D,20
00DB8:  DATA 25,55
00DBA:  DATA 20,62
00DBC:  DATA 79,20
00DBE:  DATA 53,65
00DC0:  DATA 72,76
00DC2:  DATA 65,72
00DC4:  DATA 00,00
00DC6:  DATA 41,63
00DC8:  DATA 74,20
00DCA:  DATA 53,65
00DCC:  DATA 72,76
00DCE:  DATA 65,72
00DD0:  DATA 20,4F
00DD2:  DATA 20,30
00DD4:  DATA 21,00
00DD6:  DATA 54,69
00DD8:  DATA 6D,65
00DDA:  DATA 64,20
00DDC:  DATA 4F,75
00DDE:  DATA 74,70
00DE0:  DATA 75,74
00DE2:  DATA 20,41
00DE4:  DATA 63,74
00DE6:  DATA 75,61
00DE8:  DATA 74,6F
00DEA:  DATA 72,20
00DEC:  DATA 6E,6F
00DEE:  DATA 20,52
00DF0:  DATA 65,61
00DF2:  DATA 6C,69
00DF4:  DATA 7A,61
00DF6:  DATA 64,6F
00DF8:  DATA 20,70
00DFA:  DATA 6F,72
00DFC:  DATA 20,4D
00DFE:  DATA 6F,64
00E00:  DATA 6F,20
00E02:  DATA 64,65
00E04:  DATA 20,41
00E06:  DATA 63,74
00E08:  DATA 75,61
00E0A:  DATA 64,6F
00E0C:  DATA 72,00
00E0E:  DATA 54,68
00E10:  DATA 65,20
00E12:  DATA 54,69
00E14:  DATA 6D,65
00E16:  DATA 64,20
00E18:  DATA 41,63
00E1A:  DATA 74,75
00E1C:  DATA 61,74
00E1E:  DATA 6F,72
00E20:  DATA 20,69
00E22:  DATA 73,20
00E24:  DATA 47,6F
00E26:  DATA 69,6E
00E28:  DATA 67,20
00E2A:  DATA 74,6F
00E2C:  DATA 20,62
00E2E:  DATA 65,20
00E30:  DATA 41,70
00E32:  DATA 70,6C
00E34:  DATA 69,65
00E36:  DATA 64,20
00E38:  DATA 69,6E
00E3A:  DATA 20,25
00E3C:  DATA 4C,55
00E3E:  DATA 20,53
00E40:  DATA 20,44
00E42:  DATA 75,72
00E44:  DATA 69,6E
00E46:  DATA 67,20
00E48:  DATA 25,4C
00E4A:  DATA 55,20
00E4C:  DATA 53,20
00E4E:  DATA 62,79
00E50:  DATA 20,53
00E52:  DATA 65,72
00E54:  DATA 76,65
00E56:  DATA 72,00
00E58:  DATA 41,63
00E5A:  DATA 74,20
00E5C:  DATA 53,65
00E5E:  DATA 72,76
00E60:  DATA 65,72
00E62:  DATA 20,54
00E64:  DATA 4F,20
00E66:  DATA 25,4C
00E68:  DATA 75,20
00E6A:  DATA 25,4C
00E6C:  DATA 75,21
00E6E:  DATA 00,00
00E70:  DATA 4F,75
00E72:  DATA 74,70
00E74:  DATA 75,74
00E76:  DATA 20,41
00E78:  DATA 63,74
00E7A:  DATA 75,61
00E7C:  DATA 74,6F
00E7E:  DATA 72,20
00E80:  DATA 6E,6F
00E82:  DATA 20,52
00E84:  DATA 65,61
00E86:  DATA 6C,69
00E88:  DATA 7A,61
00E8A:  DATA 64,61
00E8C:  DATA 20,70
00E8E:  DATA 6F,72
00E90:  DATA 20,4D
00E92:  DATA 6F,64
00E94:  DATA 6F,20
00E96:  DATA 64,65
00E98:  DATA 20,41
00E9A:  DATA 63,74
00E9C:  DATA 75,61
00E9E:  DATA 64,6F
00EA0:  DATA 72,00
00EA2:  DATA 53,69
00EA4:  DATA 6E,20
00EA6:  DATA 50,65
00EA8:  DATA 74,69
00EAA:  DATA 63,69
00EAC:  DATA 6F,6E
00EAE:  DATA 20,64
00EB0:  DATA 65,20
00EB2:  DATA 41,63
00EB4:  DATA 74,75
00EB6:  DATA 61,64
00EB8:  DATA 6F,72
00EBA:  DATA 00,00
00EBC:  DATA 50,49
00EBE:  DATA 4E,20
00EC0:  DATA 25,6C
00EC2:  DATA 75,20
00EC4:  DATA 49,6E
00EC6:  DATA 63,6F
00EC8:  DATA 72,72
00ECA:  DATA 65,63
00ECC:  DATA 74,6F
00ECE:  DATA 00,00
00ED0:  DATA 50,49
00ED2:  DATA 4E,20
00ED4:  DATA 53,69
00ED6:  DATA 6E,20
00ED8:  DATA 46,6F
00EDA:  DATA 72,6D
00EDC:  DATA 61,74
00EDE:  DATA 6F,00
00EE0:  DATA 54,69
00EE2:  DATA 65,6D
00EE4:  DATA 70,6F
00EE6:  DATA 20,64
00EE8:  DATA 65,20
00EEA:  DATA 45,73
00EEC:  DATA 70,65
00EEE:  DATA 72,61
00EF0:  DATA 20,50
00EF2:  DATA 61,72
00EF4:  DATA 61,20
00EF6:  DATA 50,49
00EF8:  DATA 4E,20
00EFA:  DATA 53,75
00EFC:  DATA 70,65
00EFE:  DATA 72,61
00F00:  DATA 64,6F
00F02:  DATA 00,00
00F04:  DATA 50,49
00F06:  DATA 4E,20
00F08:  DATA 4E,6F
00F0A:  DATA 20,45
00F0C:  DATA 73,70
00F0E:  DATA 65,72
00F10:  DATA 61,64
00F12:  DATA 6F,00
00F14:  DATA 44,42
00F16:  DATA 49,20
00F18:  DATA 48,65
00F1A:  DATA 61,72
00F1C:  DATA 74,42
00F1E:  DATA 65,61
00F20:  DATA 74,21
00F22:  DATA 00,00
00F24:  DATA 44,42
00F26:  DATA 49,20
00F28:  DATA 69,73
00F2A:  DATA 20,67
00F2C:  DATA 6F,69
00F2E:  DATA 6E,67
00F30:  DATA 20,74
00F32:  DATA 6F,20
00F34:  DATA 62,65
00F36:  DATA 20,72
00F38:  DATA 65,73
00F3A:  DATA 74,61
00F3C:  DATA 72,74
00F3E:  DATA 65,64
00F40:  DATA 20,69
00F42:  DATA 6E,20
00F44:  DATA 32,20
00F46:  DATA 73,65
00F48:  DATA 63,6F
00F4A:  DATA 6E,64
00F4C:  DATA 73,20
00F4E:  DATA 42,79
00F50:  DATA 20,53
00F52:  DATA 65,72
00F54:  DATA 76,65
00F56:  DATA 72,00
00F58:  DATA 49,67
00F5A:  DATA 6E,69
00F5C:  DATA 74,69
00F5E:  DATA 6F,6E
00F60:  DATA 20,4F
00F62:  DATA 4E,00
00F64:  DATA 49,67
00F66:  DATA 6E,69
00F68:  DATA 74,69
00F6A:  DATA 6F,6E
00F6C:  DATA 20,4F
00F6E:  DATA 46,46
00F70:  DATA 00,00
00F72:  DATA 44,42
00F74:  DATA 49,20
00F76:  DATA 4D,73
00F78:  DATA 67,2E
00F7A:  DATA 20,46
00F7C:  DATA 57,3A
00F7E:  DATA 20,76
00F80:  DATA 25,75
00F82:  DATA 2E,25
00F84:  DATA 75,20
00F86:  DATA 48,57
00F88:  DATA 3A,20
00F8A:  DATA 76,25
00F8C:  DATA 75,2E
00F8E:  DATA 25,75
00F90:  DATA 00,00
00F92:  DATA 44,42
00F94:  DATA 49,20
00F96:  DATA 45,45
00F98:  DATA 50,52
00F9A:  DATA 4F,4D
00F9C:  DATA 20,42
00F9E:  DATA 6C,6F
00FA0:  DATA 63,6B
00FA2:  DATA 3A,20
00FA4:  DATA 25,75
00FA6:  DATA 00,00
00FA8:  DATA 44,42
00FAA:  DATA 49,20
00FAC:  DATA 48,65
00FAE:  DATA 61,72
00FB0:  DATA 74,42
00FB2:  DATA 65,61
00FB4:  DATA 74,21
00FB6:  DATA 00,00
00FB8:  DATA 49,6E
00FBA:  DATA 70,75
00FBC:  DATA 74,20
00FBE:  DATA 56,61
00FC0:  DATA 6C,75
00FC2:  DATA 65,3A
00FC4:  DATA 20,25
00FC6:  DATA 75,00
*
00FF8:  MOVLB  7
00FFA:  MOVF   x23,W
00FFC:  MULWF  x25
00FFE:  MOVFF  FF3,01
01002:  MOVFF  FF4,00
01006:  MULWF  x26
01008:  MOVF   FF3,W
0100A:  ADDWF  00,F
0100C:  MOVF   x24,W
0100E:  MULWF  x25
01010:  MOVF   FF3,W
01012:  ADDWFC 00,W
01014:  MOVWF  02
01016:  MOVLB  0
01018:  RETURN 0
*
01696:  MOVFF  386,FEA
0169A:  MOVFF  385,FE9
0169E:  MOVLB  7
016A0:  MOVFF  7DB,FEF
016A4:  INCF   FE9,F
016A6:  BTFSC  FD8.2
016A8:  INCF   FEA,F
016AA:  CLRF   FEF
016AC:  MOVLB  3
016AE:  INCF   x85,F
016B0:  BTFSC  FD8.2
016B2:  INCF   x86,F
016B4:  MOVLB  0
016B6:  RETURN 0
016B8:  TBLRD*+
016BA:  MOVF   FF5,F
016BC:  BZ    16D6
016BE:  MOVFF  FF6,6C5
016C2:  MOVFF  FF7,6C6
016C6:  MOVFF  FF5,7DB
016CA:  RCALL  1696
016CC:  MOVFF  6C5,FF6
016D0:  MOVFF  6C6,FF7
016D4:  BRA    16B8
016D6:  RETURN 0
016D8:  MOVLB  7
016DA:  BTFSC  xDA.7
016DC:  BRA    1700
016DE:  MOVLW  0F
016E0:  MOVWF  00
016E2:  SWAPF  xD9,W
016E4:  ANDWF  00,F
016E6:  MOVLW  0A
016E8:  SUBWF  00,W
016EA:  BC    16F2
016EC:  MOVLW  30
016EE:  ADDWF  00,F
016F0:  BRA    16F6
016F2:  MOVF   xDA,W
016F4:  ADDWF  00,F
016F6:  MOVFF  00,7DB
016FA:  MOVLB  0
016FC:  RCALL  1696
016FE:  MOVLB  7
01700:  MOVLW  0F
01702:  ANDWF  xD9,F
01704:  MOVLW  0A
01706:  SUBWF  xD9,W
01708:  BC    170E
0170A:  MOVLW  30
0170C:  BRA    1712
0170E:  BCF    xDA.7
01710:  MOVF   xDA,W
01712:  ADDWF  xD9,F
01714:  MOVFF  7D9,7DB
01718:  MOVLB  0
0171A:  RCALL  1696
0171C:  RETURN 0
0171E:  MOVLB  7
01720:  MOVF   xDC,W
01722:  CLRF   01
01724:  SUBWF  xDB,W
01726:  BC    172E
01728:  MOVFF  7DB,00
0172C:  BRA    1746
0172E:  CLRF   00
01730:  MOVLW  08
01732:  MOVWF  xDD
01734:  RLCF   xDB,F
01736:  RLCF   00,F
01738:  MOVF   xDC,W
0173A:  SUBWF  00,W
0173C:  BTFSC  FD8.0
0173E:  MOVWF  00
01740:  RLCF   01,F
01742:  DECFSZ xDD,F
01744:  BRA    1734
01746:  MOVLB  0
01748:  RETURN 0
0174A:  MOVF   01,W
0174C:  MOVFF  7D9,7DB
01750:  MOVLW  64
01752:  MOVLB  7
01754:  MOVWF  xDC
01756:  MOVLB  0
01758:  RCALL  171E
0175A:  MOVFF  00,7D9
0175E:  MOVF   01,W
01760:  MOVLW  30
01762:  BNZ   1774
01764:  MOVLB  7
01766:  BTFSS  xDA.1
01768:  BRA    1788
0176A:  BTFSC  xDA.3
0176C:  BRA    1788
0176E:  BTFSC  xDA.4
01770:  MOVLW  20
01772:  BRA    177C
01774:  MOVLB  7
01776:  BCF    xDA.3
01778:  BCF    xDA.4
0177A:  BSF    xDA.0
0177C:  ADDWF  01,F
0177E:  MOVFF  01,7DB
01782:  MOVLB  0
01784:  RCALL  1696
01786:  MOVLB  7
01788:  MOVFF  7D9,7DB
0178C:  MOVLW  0A
0178E:  MOVWF  xDC
01790:  MOVLB  0
01792:  RCALL  171E
01794:  MOVFF  00,7D9
01798:  MOVF   01,W
0179A:  MOVLW  30
0179C:  BNZ   17AE
0179E:  MOVLB  7
017A0:  BTFSC  xDA.3
017A2:  BRA    17B8
017A4:  BTFSS  xDA.0
017A6:  BRA    17B8
017A8:  BTFSC  xDA.4
017AA:  MOVLW  20
017AC:  MOVLB  0
017AE:  ADDWF  01,F
017B0:  MOVFF  01,7DB
017B4:  RCALL  1696
017B6:  MOVLB  7
017B8:  MOVLW  30
017BA:  ADDWF  xD9,F
017BC:  MOVFF  7D9,7DB
017C0:  MOVLB  0
017C2:  RCALL  1696
017C4:  RETURN 0
*
01C26:  BTFSC  FD8.1
01C28:  BRA    1C32
01C2A:  MOVLW  06
01C2C:  MOVWF  FEA
01C2E:  MOVLW  E1
01C30:  MOVWF  FE9
01C32:  CLRF   00
01C34:  CLRF   01
01C36:  CLRF   02
01C38:  CLRF   03
01C3A:  MOVLB  6
01C3C:  CLRF   xE1
01C3E:  CLRF   xE2
01C40:  CLRF   xE3
01C42:  CLRF   xE4
01C44:  MOVF   xE0,W
01C46:  IORWF  xDF,W
01C48:  IORWF  xDE,W
01C4A:  IORWF  xDD,W
01C4C:  BZ    1CA6
01C4E:  MOVLW  20
01C50:  MOVWF  xE5
01C52:  BCF    FD8.0
01C54:  RLCF   xD9,F
01C56:  RLCF   xDA,F
01C58:  RLCF   xDB,F
01C5A:  RLCF   xDC,F
01C5C:  RLCF   xE1,F
01C5E:  RLCF   xE2,F
01C60:  RLCF   xE3,F
01C62:  RLCF   xE4,F
01C64:  MOVF   xE0,W
01C66:  SUBWF  xE4,W
01C68:  BNZ   1C7A
01C6A:  MOVF   xDF,W
01C6C:  SUBWF  xE3,W
01C6E:  BNZ   1C7A
01C70:  MOVF   xDE,W
01C72:  SUBWF  xE2,W
01C74:  BNZ   1C7A
01C76:  MOVF   xDD,W
01C78:  SUBWF  xE1,W
01C7A:  BNC   1C9A
01C7C:  MOVF   xDD,W
01C7E:  SUBWF  xE1,F
01C80:  MOVF   xDE,W
01C82:  BTFSS  FD8.0
01C84:  INCFSZ xDE,W
01C86:  SUBWF  xE2,F
01C88:  MOVF   xDF,W
01C8A:  BTFSS  FD8.0
01C8C:  INCFSZ xDF,W
01C8E:  SUBWF  xE3,F
01C90:  MOVF   xE0,W
01C92:  BTFSS  FD8.0
01C94:  INCFSZ xE0,W
01C96:  SUBWF  xE4,F
01C98:  BSF    FD8.0
01C9A:  RLCF   00,F
01C9C:  RLCF   01,F
01C9E:  RLCF   02,F
01CA0:  RLCF   03,F
01CA2:  DECFSZ xE5,F
01CA4:  BRA    1C52
01CA6:  MOVFF  6E1,FEF
01CAA:  MOVFF  6E2,FEC
01CAE:  MOVFF  6E3,FEC
01CB2:  MOVFF  6E4,FEC
01CB6:  MOVLB  0
01CB8:  RETURN 0
01CBA:  TBLRD*+
01CBC:  MOVFF  FF6,6CE
01CC0:  MOVFF  FF7,6CF
01CC4:  MOVFF  FF5,7DB
01CC8:  RCALL  1696
01CCA:  MOVFF  6CE,FF6
01CCE:  MOVFF  6CF,FF7
01CD2:  MOVLB  6
01CD4:  DECFSZ xCD,F
01CD6:  BRA    1CDA
01CD8:  BRA    1CDE
01CDA:  MOVLB  0
01CDC:  BRA    1CBA
01CDE:  MOVLB  0
01CE0:  RETURN 0
01CE2:  MOVF   FE9,W
01CE4:  MOVLB  6
01CE6:  MOVWF  xD1
01CE8:  MOVLW  3B
01CEA:  MOVWF  xD8
01CEC:  MOVLW  9A
01CEE:  MOVWF  xD7
01CF0:  MOVLW  CA
01CF2:  MOVWF  xD6
01CF4:  CLRF   xD5
01CF6:  MOVLW  0A
01CF8:  MOVWF  xD3
01CFA:  BSF    FD8.1
01CFC:  MOVLW  06
01CFE:  MOVWF  FEA
01D00:  MOVLW  CD
01D02:  MOVWF  FE9
01D04:  MOVFF  6D0,6DC
01D08:  MOVFF  6CF,6DB
01D0C:  MOVFF  6CE,6DA
01D10:  MOVFF  6CD,6D9
01D14:  MOVFF  6D8,6E0
01D18:  MOVFF  6D7,6DF
01D1C:  MOVFF  6D6,6DE
01D20:  MOVFF  6D5,6DD
01D24:  MOVLB  0
01D26:  RCALL  1C26
01D28:  MOVF   01,W
01D2A:  MOVF   00,F
01D2C:  BNZ   1D54
01D2E:  MOVLB  6
01D30:  MOVF   xD3,W
01D32:  XORLW  01
01D34:  BTFSS  FD8.2
01D36:  BRA    1D3C
01D38:  MOVLB  0
01D3A:  BRA    1D54
01D3C:  MOVF   xD1,W
01D3E:  BZ    1D58
01D40:  ANDLW  0F
01D42:  SUBWF  xD3,W
01D44:  BZ    1D48
01D46:  BC    1D66
01D48:  BTFSC  xD1.7
01D4A:  BRA    1D66
01D4C:  BTFSC  xD1.6
01D4E:  BRA    1D58
01D50:  MOVLW  20
01D52:  BRA    1D5A
01D54:  MOVLB  6
01D56:  CLRF   xD1
01D58:  MOVLW  30
01D5A:  ADDWF  00,F
01D5C:  MOVFF  00,7DB
01D60:  MOVLB  0
01D62:  RCALL  1696
01D64:  MOVLB  6
01D66:  BCF    FD8.1
01D68:  MOVFF  6D8,6DC
01D6C:  MOVFF  6D7,6DB
01D70:  MOVFF  6D6,6DA
01D74:  MOVFF  6D5,6D9
01D78:  CLRF   xE0
01D7A:  CLRF   xDF
01D7C:  CLRF   xDE
01D7E:  MOVLW  0A
01D80:  MOVWF  xDD
01D82:  MOVLB  0
01D84:  RCALL  1C26
01D86:  MOVFF  03,6D8
01D8A:  MOVFF  02,6D7
01D8E:  MOVFF  01,6D6
01D92:  MOVFF  00,6D5
01D96:  MOVLB  6
01D98:  DECFSZ xD3,F
01D9A:  BRA    1CFA
01D9C:  MOVLB  0
01D9E:  RETURN 0
*
01F02:  MOVFF  6C6,01
01F06:  MOVFF  6C5,00
01F0A:  TSTFSZ 00
01F0C:  INCF   01,F
01F0E:  TBLRD*+
01F10:  MOVFF  FF5,FEE
01F14:  DECFSZ 00,F
01F16:  BRA    1F0E
01F18:  DECFSZ 01,F
01F1A:  BRA    1F0E
01F1C:  CLRF   FF8
01F1E:  RETURN 0
*
02310:  MOVLB  6
02312:  CLRF   xCD
02314:  CLRF   xCE
02316:  MOVLW  01
02318:  MOVWF  xCF
0231A:  CLRF   FDA
0231C:  CLRF   FD9
0231E:  MOVLW  06
02320:  MOVWF  xD2
02322:  MOVLW  C5
02324:  MOVWF  xD1
02326:  MOVLW  06
02328:  MOVWF  FEA
0232A:  MOVLW  C9
0232C:  MOVWF  FE9
0232E:  MOVFF  6D2,FE2
02332:  MOVFF  6D1,FE1
02336:  MOVFF  6CF,6D0
0233A:  BCF    FD8.0
0233C:  MOVF   FE5,W
0233E:  MULWF  FEE
02340:  MOVF   FF3,W
02342:  ADDWFC xCD,F
02344:  MOVF   FF4,W
02346:  ADDWFC xCE,F
02348:  DECFSZ xD0,F
0234A:  BRA    233A
0234C:  MOVFF  6CD,FDE
02350:  MOVFF  6CE,6CD
02354:  CLRF   xCE
02356:  BTFSC  FD8.0
02358:  INCF   xCE,F
0235A:  INCF   xD1,F
0235C:  BTFSC  FD8.2
0235E:  INCF   xD2,F
02360:  INCF   xCF,F
02362:  MOVF   xCF,W
02364:  SUBLW  05
02366:  BNZ   2326
02368:  MOVLB  0
0236A:  GOTO   23DC (RETURN)
0236E:  CLRF   01
02370:  CLRF   02
02372:  CLRF   00
02374:  CLRF   03
02376:  MOVLB  6
02378:  MOVF   xCB,W
0237A:  BNZ   2380
0237C:  MOVF   xCA,W
0237E:  BZ    23B0
02380:  MOVLW  10
02382:  MOVWF  xCC
02384:  BCF    FD8.0
02386:  RLCF   xC8,F
02388:  RLCF   xC9,F
0238A:  RLCF   00,F
0238C:  RLCF   03,F
0238E:  MOVF   xCB,W
02390:  SUBWF  03,W
02392:  BNZ   2398
02394:  MOVF   xCA,W
02396:  SUBWF  00,W
02398:  BNC   23A8
0239A:  MOVF   xCA,W
0239C:  SUBWF  00,F
0239E:  BTFSS  FD8.0
023A0:  DECF   03,F
023A2:  MOVF   xCB,W
023A4:  SUBWF  03,F
023A6:  BSF    FD8.0
023A8:  RLCF   01,F
023AA:  RLCF   02,F
023AC:  DECFSZ xCC,F
023AE:  BRA    2384
023B0:  MOVLB  0
023B2:  GOTO   241C (RETURN)
*
02426:  MOVFF  FEA,6CD
0242A:  MOVFF  FE9,6CC
0242E:  MOVLB  6
02430:  SWAPF  xC6,W
02432:  IORLW  F0
02434:  MOVWF  xC8
02436:  ADDWF  xC8,F
02438:  ADDLW  E2
0243A:  MOVWF  xC9
0243C:  ADDLW  32
0243E:  MOVWF  xCB
02440:  MOVF   xC6,W
02442:  ANDLW  0F
02444:  ADDWF  xC9,F
02446:  ADDWF  xC9,F
02448:  ADDWF  xCB,F
0244A:  ADDLW  E9
0244C:  MOVWF  xCA
0244E:  ADDWF  xCA,F
02450:  ADDWF  xCA,F
02452:  SWAPF  xC5,W
02454:  ANDLW  0F
02456:  ADDWF  xCA,F
02458:  ADDWF  xCB,F
0245A:  RLCF   xCA,F
0245C:  RLCF   xCB,F
0245E:  COMF   xCB,F
02460:  RLCF   xCB,F
02462:  MOVF   xC5,W
02464:  ANDLW  0F
02466:  ADDWF  xCB,F
02468:  RLCF   xC8,F
0246A:  MOVLW  07
0246C:  MOVWF  xC7
0246E:  MOVLW  0A
02470:  DECF   xCA,F
02472:  ADDWF  xCB,F
02474:  BNC   2470
02476:  DECF   xC9,F
02478:  ADDWF  xCA,F
0247A:  BNC   2476
0247C:  DECF   xC8,F
0247E:  ADDWF  xC9,F
02480:  BNC   247C
02482:  DECF   xC7,F
02484:  ADDWF  xC8,F
02486:  BNC   2482
02488:  MOVLW  06
0248A:  MOVWF  FEA
0248C:  MOVLW  C7
0248E:  MOVWF  FE9
02490:  MOVLW  07
02492:  ANDWF  xCC,W
02494:  BCF    xCC.6
02496:  ADDWF  FE9,F
02498:  MOVLW  00
0249A:  ADDWFC FEA,F
0249C:  MOVF   FE9,W
0249E:  SUBLW  CB
024A0:  BNZ   24AA
024A2:  MOVF   FEA,W
024A4:  SUBLW  06
024A6:  BNZ   24AA
024A8:  BSF    xCC.6
024AA:  MOVF   FEF,W
024AC:  MOVWF  00
024AE:  BNZ   24C0
024B0:  BTFSC  xCC.6
024B2:  BRA    24C0
024B4:  BTFSC  xCC.4
024B6:  BRA    24E4
024B8:  BTFSC  xCC.3
024BA:  BRA    24C0
024BC:  MOVLW  20
024BE:  BRA    24C6
024C0:  BSF    xCC.3
024C2:  BCF    xCC.4
024C4:  MOVLW  30
024C6:  ADDWF  00,F
024C8:  MOVFF  FEA,6C6
024CC:  MOVFF  FE9,6C5
024D0:  MOVFF  00,7DB
024D4:  MOVLB  0
024D6:  CALL   1696
024DA:  MOVFF  6C6,FEA
024DE:  MOVFF  6C5,FE9
024E2:  MOVLB  6
024E4:  MOVF   FEE,W
024E6:  BTFSS  xCC.6
024E8:  BRA    249C
024EA:  MOVLB  0
024EC:  GOTO   5048 (RETURN)
....................  
.................... #list 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
*
01060:  MOVLB  7
01062:  MOVWF  x01
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t unsigned char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(unsigned char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,unsigned char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(unsigned char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
023B6:  MOVFF  1E,6C8
023BA:  MOVFF  1D,6C7
023BE:  MOVFF  1C,6C6
023C2:  MOVFF  1B,6C5
023C6:  MOVLW  41
023C8:  MOVLB  6
023CA:  MOVWF  xCC
023CC:  MOVLW  C6
023CE:  MOVWF  xCB
023D0:  MOVLW  4E
023D2:  MOVWF  xCA
023D4:  MOVLW  6D
023D6:  MOVWF  xC9
023D8:  MOVLB  0
023DA:  BRA    2310
023DC:  MOVLW  39
023DE:  MOVLB  6
023E0:  ADDWF  00,W
023E2:  MOVWF  1B
023E4:  MOVLW  30
023E6:  ADDWFC 01,W
023E8:  MOVWF  1C
023EA:  MOVLW  00
023EC:  ADDWFC 02,W
023EE:  MOVWF  1D
023F0:  MOVLW  00
023F2:  ADDWFC 03,W
023F4:  MOVWF  1E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
023F6:  MOVFF  1D,00
023FA:  MOVFF  1E,01
023FE:  CLRF   02
02400:  CLRF   03
02402:  MOVFF  1E,6C7
02406:  MOVFF  1D,6C6
0240A:  MOVFF  1E,6C9
0240E:  MOVFF  1D,6C8
02412:  MOVLW  7F
02414:  MOVWF  xCB
02416:  SETF   xCA
02418:  MOVLB  0
0241A:  BRA    236E
0241C:  MOVFF  00,01
02420:  MOVFF  03,02
02424:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
022FE:  MOVFF  6C9,1E
02302:  MOVFF  6C8,1D
02306:  MOVFF  6C7,1C
0230A:  MOVFF  6C6,1B
0230E:  RETURN 0
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES   NOMCLR 
.................... #FUSES   WDT                         //No Watch Dog Timer 
.................... #FUSES   WDT2048       
.................... #FUSES   NOXINST                     //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES   ECH_IO                      //High speed Osc, medium power 4MHz-16MHz 
.................... #FUSES   NOBROWNOUT                  //No brownout reset 
.................... #FUSES   WDT_NOSLEEP                 //Watch Dog Timer, disabled during SLEEP 
.................... #FUSES   PROTECT 
.................... #FUSES   PUT 
.................... #use     delay(clock=40000000,RESTART_WDT) 
*
00FC8:  MOVLW  06
00FCA:  MOVWF  FEA
00FCC:  MOVLW  C7
00FCE:  MOVWF  FE9
00FD0:  MOVF   FEF,W
00FD2:  BZ    0FF6
00FD4:  MOVLW  0C
00FD6:  MOVWF  01
00FD8:  MOVLW  BF
00FDA:  MOVWF  00
00FDC:  CLRWDT
00FDE:  DECFSZ 00,F
00FE0:  BRA    0FDC
00FE2:  DECFSZ 01,F
00FE4:  BRA    0FD8
00FE6:  MOVLW  F7
00FE8:  MOVWF  00
00FEA:  DECFSZ 00,F
00FEC:  BRA    0FEA
00FEE:  NOP   
00FF0:  CLRWDT
00FF2:  DECFSZ FEF,F
00FF4:  BRA    0FD4
00FF6:  RETURN 0
....................  
.................... #define interruptTime 5 
.................... #define Led PIN_A0 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Serial ,restart_wdt,errors) 
*
003B4:  CLRWDT
003B6:  BTFSS  F9E.5
003B8:  BRA    03B4
003BA:  MOVFF  FAB,1F
003BE:  MOVFF  FAE,01
003C2:  BTFSS  1F.1
003C4:  BRA    03CA
003C6:  BCF    FAB.4
003C8:  BSF    FAB.4
003CA:  GOTO   0504 (RETURN)
*
017C6:  CLRWDT
017C8:  BTFSS  F9E.4
017CA:  BRA    17C6
017CC:  MOVWF  FAD
017CE:  RETURN 0
.................... #use rs232(baud=19200,parity=N,xmit=PIN_B6,rcv=PIN_B7,bits=8,stream=IOX,restart_wdt,errors) 
*
00514:  CLRWDT
00516:  BTFSS  FA4.5
00518:  BRA    0514
0051A:  MOVFF  FA6,1F
0051E:  MOVFF  F7A,01
00522:  BTFSS  1F.1
00524:  BRA    052A
00526:  BCF    FA6.4
00528:  BSF    FA6.4
0052A:  GOTO   063E (RETURN)
*
019EE:  CLRWDT
019F0:  BTFSS  FA4.4
019F2:  BRA    19EE
019F4:  MOVWF  F79
019F6:  RETURN 0
....................  
.................... struct 
.................... { 
....................    unsigned int1 customData;  
....................    unsigned int1 StatusData;  
....................    unsigned int1 MIMEin;  
....................    unsigned int1 MIMEout;  
....................    unsigned int1 MimeACKResponse; 
....................    unsigned int1 rqstGoInfo; 
....................    unsigned int1 rqstActuator;  
....................    unsigned int1 showGoInfo; 
....................    unsigned int1 blockMIMEByACK; 
....................    unsigned int1 showInputstatus; 
....................    unsigned int1 sendInputstatus; 
....................    unsigned int1 saveEepromDueInput; 
....................     
.................... }AllowedFuntions; 
....................  
.................... static int8 firmwareMajorVersion = 1; 
.................... static int8 firmwareMinorVersion = 1; 
.................... static int8 HardwareMajorVersion = 1; 
.................... static int8 HardwareMinorVersion = 0; 
....................  
....................  
....................  
.................... #include <Eeprom.h> 
.................... /////Eeprom registers defin 
.................... #byte EEADRH = 0xF75 
.................... #byte EEADR  = 0xF74 
.................... #byte EEDATA = 0xF73 
.................... #byte EECON1 = 0xF7F  
.................... #byte INTCON = 0xFF2 
.................... #byte EECON2 = 0xF7E 
.................... #define   EEPGD 7 
.................... #define  CFGS  6 
.................... #define  WREN  2 
.................... #define  WR    1 
.................... #define  GIE   7 
.................... #define  RD    0 
.................... /////////////////////////// 
....................  
.................... #define MaxAddres  1023 
.................... #define MaxBlocks  24 
.................... //#define BlockSize  36 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int16 MIMEackByGo; 
....................    unsigned int32 MIMEackByServer; 
....................    unsigned int16 MIMEmax; 
....................    unsigned int1  MIMEoutEnabled; 
....................    unsigned int1  MIMEinEnabled; 
....................    unsigned int1  MIMEWaitACKtoSend; 
....................    unsigned int1  MIMEautoResponseACK; 
....................  
....................    unsigned int1  CScustomEnabled; 
....................    unsigned int1  CSstatusEnabled; 
....................     
....................    unsigned int1  HOSautoShowEnabled; 
....................    unsigned int1  HOSrqstEnabled; 
....................  
....................    unsigned int16 CSackByGo; 
....................    unsigned int16 CSmax; 
....................     
....................    unsigned int32 HOStimeToResquest; 
....................     
....................    unsigned int8  ACTmode; 
....................    unsigned int32 ACTtoReset; 
....................    unsigned int32 ACTinReset; 
....................    unsigned int32 ACTtimeOutPIN; 
....................    unsigned int1  ACTstatus; 
....................    unsigned int1  ACTenableClientRequest; 
....................    
....................    unsigned int1  DBIheartBeatEnabled; 
....................     
....................    unsigned int1  InputEnableShow; 
....................    unsigned int1  InputEnablestatus; 
....................    unsigned int1  InputEnableSaveEeprom; 
....................    unsigned int1  InputValueToSave; 
....................    unsigned int1  empty; 
....................    unsigned int32 DBItimeToHeartBeat; 
....................     
....................    unsigned int16 InputStatusDataId; 
....................    unsigned int16 InputTimeToSense; 
....................     
.................... }Variables; 
....................  
.................... Variables ValoresIniciales; 
.................... unsigned int1 EepromInputValueToSave; 
.................... unsigned int8 BloqueEeprom = 0; 
....................  
.................... unsigned int1 EepromInit(void); 
.................... void          EepromSave(Variables Structura); 
.................... unsigned int1 CompareStructs(Variables StructA, Variables StructB); 
.................... unsigned int1 EeepromleerBloque(unsigned int8 bloque, Variables *Structura); 
.................... void          EepromEscribirBloque(unsigned int8 bloque, Variables Structura); 
.................... void          EcribirEeprom(unsigned int16 add, unsigned int8 value); 
.................... unsigned int8 LeerEeprom(unsigned int16 add); 
....................  
.................... #include <RS232_HOS.c> 
.................... #include <RS232_HOS.h> 
.................... #define HandshakeRequest             0x01  //Go to external device  confirma que el dispositivo esta emparejado 
.................... #define ThirdPartyDataACK            0x02  //Go to external device  confirma que el mensaje third party se recibio 
.................... #define GoDeviceData                 0x21  //Go to external device  contiene infomacion del go como rpm, vel, etc, si somos un dispositivo hos(id=4141) se envia cada 2 segundos y se le tiene que responder un el ACK con el comando 84, si no solo se envia como respuesta al comando requestDataMesage 
.................... #define BinaryDataResponse           0x22  //Go to external device  confirma que la transmision del"BinaryDataPacket (0x86)" se realizo exitoso o mal 
.................... #define BinaryDataPacketIN           0x23  //Go to external device  contiene el mensaje enviado desde el servidor 
.................... #define HandshakeConfirmation        0x81  //External device to Go  es la respuesta al comando "0x01" y contiene informacion como el external device que somos, si queremos ACK y si queremos el mensaje binary data formateado 
.................... #define ThirdPartyDataStatusData     0x80  //External device to Go  Se envia cuando se quiere reflejar un parametro en mygeotab y se le debe responder el comando 0x02 por parte del go 
.................... #define FreeFormatThirdPartyData     0x82  //External device to Go  Se envia cuando se quiere reflejar un customdata en mygeotab y se le debe responder el comando 0x02 por parte del go 
.................... #define DeviceDataACK                0x84  //External device to Go  Se envia como ACK al comando 0x21 cuando estamos en HOS device y tenemos hasta 30 segundos para enviarlo 
.................... #define RequestDeviceDataMessage     0x85  //External device to Go  Se envia cuando se quiere recibir el comando 0x21 
.................... #define BinaryDataPacketOUT          0x86  //External device to Go  Se envia cuando se enviar un binaryData al servidor 
.................... #define ThirdPartyPriorityStatusData 0x87  //External device to Go  Se envia cuando se quiere reflejar un parametro en mygeotab y se le debe responder el comando 0x02 por parte del go (si tiene el iridium puede que el mensaje salga por ahi) 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8  MsgType;        //Tipo de mensaje segun la documentacion 
....................    unsigned int8  MsgBodyLength;  //longitud 
....................    unsigned int8  Data[250];      //datos de entrada 
....................    unsigned int1  GoFormat;       //debido a que existe la opcion de que lleguen mensajes sin el formato que tiene normalmente  el go7, cualquier mensaje que llegue y no sea valido lo tomaremos pero indicaremos que no tiene el formato 
.................... }HOS_Message; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int32 DateTime;       //Fecha y hora en segundos desde  de enero de 2002 
....................    unsigned int32 Latitude;       //Latitud GPS 
....................    unsigned int32 Longitud;       //Longitud GPS 
....................    unsigned int8  Velocidad;      //Velocidad del Vehiculo, si no tiene datos de motor el dato sera del gps 
....................    unsigned int16 RPM;            // 
....................    unsigned int32 Odometro;       //Si el odometro no esta disponible se usara la distancia del gps 
....................    unsigned int1  GpsValid;   
....................    unsigned int1  Ignition;   
....................    unsigned int1  EngineActivity;   
....................    unsigned int1  DateValid;   
....................    unsigned int1  SpeedFromEngine;   
....................    unsigned int1  OdometerFromEngine;   
....................    unsigned int32 TripOdometer;    
....................    unsigned int32 TotalEngineHours;   
....................    unsigned int32 TripDuration;    
....................    unsigned int32 GoID;   
....................    unsigned int32 DriverId;    
.................... }HOS_DeviceData; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int1  TransmissionSucces;   
.................... }HOS_BinaryDataResponse; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int16 ExternalDevice; 
....................    unsigned int1  HandshakeConfirmationACK;   
....................    unsigned int1  BinaryDataWrapping;   
.................... }HOS_HandShakeConfirmation; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int16 DataID; 
....................    unsigned int32 Data;   
.................... }HOS_StatusData; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8  Size; //max 27 
....................    unsigned int8  Data[27];   
.................... }HOS_FreeFormat; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8  Size; //max 250 
....................    unsigned int8  Data[250];   
.................... }HOS_BinaryDataPacket; 
....................  
.................... struct 
.................... { 
....................    unsigned int1  WattingACKmime; //bandera que indica si esta esperando un ack del go porque se envio un mime 
....................    unsigned int16 p_timeOutMime; //tiempo programado para esperar ack del go7 
....................    unsigned int16 n_timeOutMime; //tiempo actual para hacer comparacion 
....................    unsigned int16 maxMIMEs; //maximo numero de mimes que se pueden enviar 
....................    unsigned int16 MIMESent;//contador de customs en 10 minutos 
....................    unsigned int32 MIMETime; //tiempo que ha transcurrido enviando mimes 
....................     
....................    unsigned int16 p_timeOutCustom; //tiempo programado para esperar ack del go7 
....................    unsigned int16 n_timeOutCustom; //tiempo actual para hacer comparacion 
....................    unsigned int8  WattingACK; //este valor si es cero equivale a no esta esperando ACK si es 1 esta esperando ACK de un custom, si es 2 esta esperando ACK de status data 
....................     
....................    unsigned int16 timeToSync; //contador de tiempo para enviar comando de sincronia cada segundo si no esta sincronizado 
....................    unsigned int1  synchronized;  //bandera que indica si esta en sicronia 
....................    unsigned int1  lastSynchronized;  //bandera para identificar cambios en la sincronia 
....................    unsigned int1  msgReady;  //bandera para saber si hay un mensaje completo desde el go7    
....................     
....................    unsigned int16 maxCustoms; //maximo numero de customs data que se pueden enviar 
....................    unsigned int16 customsSent;//contador de customs en 10 minutos 
....................    unsigned int32 CustomsTime; //tiempo que ha transcurrido enviando customs 
....................     
....................    unsigned int32 p_TimetoRqstHOS; //este tiempo es el configurado para preguntar por la info del go7 
....................    unsigned int32 n_TimetoRqstHOS; //este tiempo que ha transcurrido para preguntar por el comando 
....................    unsigned int1  WattingGoInfoResponse; //bandera que indica si esta esperando un ack del servidor 
....................    unsigned int32 p_timeOutGoInfoResponse; //tiempo programado para esperar ack del servidor 
....................    unsigned int32 n_timeOutGoInfoResponse; //tiempo transcurrido esperando ACK del servidor 
....................    unsigned int1  lastIgnition; //bandera para hacer comparacion y detectar cambios 
....................     
....................    unsigned int1  WattingACKmimeFromServer; //bandera que indica si esta esperando un ack del servidor 
....................    unsigned int32 p_timeOutACKFromServer; //tiempo programado para esperar ack del servidor 
....................    unsigned int32 n_timeOutACKFromServer; //tiempo transcurrido esperando ACK del servidor 
....................     
....................    unsigned int32 p_TimetoHearBeat; //tiempo programado para hacer el heartbeat 
....................    unsigned int32 n_TimetoHeratBeat; //tiempo actual para hacer el heartbeat 
....................    unsigned int1  HeartbeatEnable; //bandera que indica si envia en heartbeat por tiempo 
.................... }GoIOXstatus; 
....................  
.................... unsigned int8 HOS_CHKA, HOS_CHKB; 
.................... unsigned int1 GoInfoDataReady = false; 
....................  
.................... //int1 HOS_WattingBinaryDataACK; 
.................... //int1 HOS_Binary_Succes; //esta bandera se pondra en 1 cuando el mensaje se haya enviado correctamente 
....................  
.................... unsigned int8 HOS_Command = 0; //comando de maquina de estados para procesar mensaje 
.................... unsigned int8 Msg_Type  = 0; 
.................... unsigned int8 Msg_Leng  = 0; 
.................... unsigned int8 Msg_Data[250];  
.................... unsigned int8 Msg_Index = 0; 
.................... unsigned int8 Msg_ChkA  = 0; 
.................... unsigned int8 Msg_ChkB  = 0; 
....................  
.................... unsigned int8 GoInfo_Leng  = 0; 
.................... unsigned int8 GoInfo_Data[250];  
....................  
.................... int8 Size_type = 10; 
.................... char type[10] = {'t','e','x','t','/','p','l','a','i','n'};  
....................  
....................  
.................... /*int8 Size_type = 8; 
.................... char type[10] = {'t','e','x','t','/','t','x','t'}; */ 
....................  
.................... //int8 Size_type = 10; 
.................... //char type[10] = {'i','m','a','g','e','/','j','p','e','g'};  
....................  
.................... void HOS_Init(); 
.................... void HOS_Set_Time(void); 
.................... void HOS_Set_Buffer(unsigned int8 Dato); 
....................  
.................... void SentThirdPartyDataStatusData(int1 Prioritario, unsigned int16 Data_Id, int32 Data); 
.................... void SentFreeFormatThirdPartyData(unsigned int8 Size, unsigned int8 *Data); 
.................... void SentBinaryDataPacket(unsigned int8 Size, unsigned int8 *Data); 
.................... void SentMIMEPacket(unsigned int16 Size, unsigned int8 *Data); 
.................... void SentRequestDeviceDataMessage(void); 
.................... void SentDeviceDataACK(void); 
.................... void SentHandShakeRequest(void); 
.................... void SentHandshakeConfirmation(unsigned int16 DeviceId, int1 ACKConfirmation, int1 BinaryDataWrapping); 
.................... void CheckSum(unsigned int8 Data); 
.................... void GetParameters(HOS_DeviceData *Result); 
....................  
.................... /* 
.................... /////Eeprom registers defin 
.................... #byte TXSTA1 = 0xFAC 
.................... #byte RCSTA1 = 0xFAB 
.................... #byte INTCON = 0xFF2 
.................... //#byte PIE3   = 0xFA3 
....................  
.................... #define  Sync  4 
.................... #define  SPEN  7 
.................... #define  CREN  4 
....................  
.................... //#define  GIE  7 
.................... #define  PEIE 6 
.................... #define  RC2IE 5 
....................  
.................... #bit serialInterrupt=PIE3.RC2IE 
.................... #bit serialReception=RCSTA1.CREN 
.................... #bit GlobalInterrupt=INTCON.GIE 
.................... #bit Interrupt=INTCON.PEIE 
.................... ///////////////////////////*/ 
....................  
.................... void HOS_Init(void) 
.................... { 
....................    GoIOXstatus.synchronized = false; 
*
015A8:  BCF    x63.0
....................    GoIOXstatus.msgReady = false; 
015AA:  BCF    x63.2
....................    GoIOXstatus.p_timeOutCustom = ValoresIniciales.CSackByGo; 
015AC:  MOVFF  30,5D
015B0:  MOVFF  2F,5C
....................    GoIOXstatus.p_timeOutMime = ValoresIniciales.MIMEackByGo;  
015B4:  MOVFF  27,51
015B8:  MOVFF  26,50
....................    GoIOXstatus.n_timeOutCustom = 0; 
015BC:  CLRF   5F
015BE:  CLRF   5E
....................    GoIOXstatus.n_timeOutMime = 0; 
015C0:  CLRF   53
015C2:  CLRF   52
....................    GoIOXstatus.synchronized = False; 
015C4:  BCF    x63.0
....................    GoIOXstatus.WattingACK = 0; 
015C6:  CLRF   x60
....................    GoIOXstatus.timeToSync = 0; 
015C8:  CLRF   x62
015CA:  CLRF   x61
....................    GoIOXstatus.lastSynchronized = false; 
015CC:  BCF    x63.1
....................     
....................    GoIOXstatus.maxCustoms = ValoresIniciales.CSmax; 
015CE:  MOVFF  32,65
015D2:  MOVFF  31,64
....................    GoIOXstatus.CustomsTime = 0; 
015D6:  CLRF   x6B
015D8:  CLRF   x6A
015DA:  CLRF   x69
015DC:  CLRF   x68
....................    GoIOXstatus.customsSent = 0; 
015DE:  CLRF   x67
015E0:  CLRF   x66
....................     
....................    GoIOXstatus.p_timeOutACKFromServer = ValoresIniciales.MIMEackByServer; 
015E2:  MOVFF  2B,81
015E6:  MOVFF  2A,80
015EA:  MOVFF  29,7F
015EE:  MOVFF  28,7E
....................    GoIOXstatus.n_timeOutACKFromServer = 0; 
015F2:  CLRF   x85
015F4:  CLRF   x84
015F6:  CLRF   x83
015F8:  CLRF   x82
....................    GoIOXstatus.WattingACKmimeFromServer = false; 
015FA:  BCF    x7D.1
....................    GoIOXstatus.maxMIMEs = ValoresIniciales.MIMEmax; 
015FC:  MOVFF  2D,55
01600:  MOVFF  2C,54
....................    GoIOXstatus.MIMESent = 0; 
01604:  CLRF   57
01606:  CLRF   56
....................    GoIOXstatus.MIMETime = 0; 
01608:  CLRF   5B
0160A:  CLRF   5A
0160C:  CLRF   59
0160E:  CLRF   58
....................     
....................    GoIOXstatus.p_TimetoRqstHOS = ValoresIniciales.HOStimeToResquest; 
01610:  MOVFF  36,6F
01614:  MOVFF  35,6E
01618:  MOVFF  34,6D
0161C:  MOVFF  33,6C
....................    GoIOXstatus.n_TimetoRqstHOS = 0; 
01620:  CLRF   x73
01622:  CLRF   x72
01624:  CLRF   x71
01626:  CLRF   x70
....................    GoIOXstatus.lastIgnition = false; 
01628:  BCF    x7D.0
....................     
....................     
....................    GoIOXstatus.WattingGoInfoResponse = false; 
0162A:  BCF    x74.0
....................    GoIOXstatus.p_timeOutGoInfoResponse = 5000; 
0162C:  CLRF   x78
0162E:  CLRF   x77
01630:  MOVLW  13
01632:  MOVWF  x76
01634:  MOVLW  88
01636:  MOVWF  x75
....................    GoIOXstatus.n_timeOutGoInfoResponse = 0; 
01638:  CLRF   x7C
0163A:  CLRF   x7B
0163C:  CLRF   x7A
0163E:  CLRF   x79
....................     
....................    GoIOXstatus.p_TimetoHearBeat = ValoresIniciales.DBItimeToHeartBeat; //cada 15 min 
01640:  MOVFF  48,89
01644:  MOVFF  47,88
01648:  MOVFF  46,87
0164C:  MOVFF  45,86
....................    GoIOXstatus.n_TimetoHeratBeat = 0; 
01650:  CLRF   x8D
01652:  CLRF   x8C
01654:  CLRF   x8B
01656:  CLRF   x8A
....................    GoIOXstatus.HeartbeatEnable = ValoresIniciales.DBIheartBeatEnabled; 
01658:  BCF    x8E.0
0165A:  BTFSC  44.2
0165C:  BSF    x8E.0
....................     
....................    HOS_Command   = 0; 
0165E:  CLRF   x91
....................    Msg_Type  = 0; 
01660:  CLRF   x92
....................    Msg_Leng  = 0; 
01662:  CLRF   x93
....................    Msg_Index = 0; 
01664:  MOVLB  1
01666:  CLRF   x8E
....................    Msg_ChkA  = 0; 
01668:  CLRF   x8F
....................    Msg_ChkB  = 0; 
0166A:  CLRF   x90
0166C:  MOVLB  0
0166E:  GOTO   26F4 (RETURN)
.................... } 
....................  
.................... void HOS_Set_Time(void) 
.................... { 
....................    GoIOXstatus.timeToSync += interruptTime; 
*
000C6:  MOVLW  05
000C8:  ADDWF  x61,F
000CA:  MOVLW  00
000CC:  ADDWFC x62,F
....................    GoIOXstatus.n_TimetoRqstHOS += interruptTime; 
000CE:  MOVLW  05
000D0:  ADDWF  x70,F
000D2:  MOVLW  00
000D4:  ADDWFC x71,F
000D6:  ADDWFC x72,F
000D8:  ADDWFC x73,F
....................     
....................    if( GoIOXstatus.HeartbeatEnable == true) 
000DA:  BTFSS  x8E.0
000DC:  BRA    00EA
....................    { 
....................       GoIOXstatus.n_TimetoHeratBeat += interruptTime; 
000DE:  MOVLW  05
000E0:  ADDWF  x8A,F
000E2:  MOVLW  00
000E4:  ADDWFC x8B,F
000E6:  ADDWFC x8C,F
000E8:  ADDWFC x8D,F
....................    } 
....................     
....................    GoIOXstatus.CustomsTime += interruptTime; 
000EA:  MOVLW  05
000EC:  ADDWF  x68,F
000EE:  MOVLW  00
000F0:  ADDWFC x69,F
000F2:  ADDWFC x6A,F
000F4:  ADDWFC x6B,F
....................    if(GoIOXstatus.CustomsTime > 600000)  
000F6:  MOVF   x6B,F
000F8:  BNZ   0114
000FA:  MOVF   x6A,W
000FC:  SUBLW  08
000FE:  BC    0120
00100:  XORLW  FF
00102:  BNZ   0114
00104:  MOVF   x69,W
00106:  SUBLW  26
00108:  BC    0120
0010A:  XORLW  FF
0010C:  BNZ   0114
0010E:  MOVF   x68,W
00110:  SUBLW  C0
00112:  BC    0120
....................    { 
....................       GoIOXstatus.CustomsTime = 0; 
00114:  CLRF   x6B
00116:  CLRF   x6A
00118:  CLRF   x69
0011A:  CLRF   x68
....................       GoIOXstatus.customsSent = 0; 
0011C:  CLRF   x67
0011E:  CLRF   x66
....................    } 
....................     
....................    GoIOXstatus.MIMETime += interruptTime; 
00120:  MOVLW  05
00122:  ADDWF  58,F
00124:  MOVLW  00
00126:  ADDWFC 59,F
00128:  ADDWFC 5A,F
0012A:  ADDWFC 5B,F
....................    if(GoIOXstatus.MIMETime > 600000) 
0012C:  MOVF   5B,F
0012E:  BNZ   014A
00130:  MOVF   5A,W
00132:  SUBLW  08
00134:  BC    0156
00136:  XORLW  FF
00138:  BNZ   014A
0013A:  MOVF   59,W
0013C:  SUBLW  26
0013E:  BC    0156
00140:  XORLW  FF
00142:  BNZ   014A
00144:  MOVF   58,W
00146:  SUBLW  C0
00148:  BC    0156
....................    { 
....................       GoIOXstatus.MIMESent = 0; 
0014A:  CLRF   57
0014C:  CLRF   56
....................       GoIOXstatus.MIMETime = 0; 
0014E:  CLRF   5B
00150:  CLRF   5A
00152:  CLRF   59
00154:  CLRF   58
....................    } 
....................     
....................    if(GoIOXstatus.WattingACK != 0) 
00156:  MOVF   x60,F
00158:  BZ    0178
....................    { 
....................       GoIOXstatus.n_timeOutCustom += interruptTime; 
0015A:  MOVLW  05
0015C:  ADDWF  5E,F
0015E:  MOVLW  00
00160:  ADDWFC 5F,F
....................       if(GoIOXstatus.n_timeOutCustom > GoIOXstatus.p_timeOutCustom) 
00162:  MOVF   5D,W
00164:  SUBWF  5F,W
00166:  BNC   0178
00168:  BNZ   0170
0016A:  MOVF   5E,W
0016C:  SUBWF  5C,W
0016E:  BC    0178
....................       { 
....................          GoIOXstatus.synchronized = False; 
00170:  BCF    x63.0
....................          GoIOXstatus.n_timeOutCustom = 0; 
00172:  CLRF   5F
00174:  CLRF   5E
....................          GoIOXstatus.WattingACK = 0; 
00176:  CLRF   x60
....................       } 
....................    } 
....................     
....................    if(GoIOXstatus.WattingACKmime == true) 
00178:  BTFSS  4F.0
0017A:  BRA    019A
....................    { 
....................       GoIOXstatus.n_timeOutMime+= interruptTime; 
0017C:  MOVLW  05
0017E:  ADDWF  52,F
00180:  MOVLW  00
00182:  ADDWFC 53,F
....................       if(GoIOXstatus.n_timeOutMime > GoIOXstatus.p_timeOutMime) 
00184:  MOVF   51,W
00186:  SUBWF  53,W
00188:  BNC   019A
0018A:  BNZ   0192
0018C:  MOVF   52,W
0018E:  SUBWF  50,W
00190:  BC    019A
....................       { 
....................          GoIOXstatus.synchronized = False; 
00192:  BCF    x63.0
....................          GoIOXstatus.WattingACKmime = false; 
00194:  BCF    4F.0
....................          GoIOXstatus.n_timeOutMime = 0; 
00196:  CLRF   53
00198:  CLRF   52
....................       } 
....................    } 
....................     
....................    if(GoIOXstatus.WattingACKmimeFromServer == true) 
0019A:  BTFSS  x7D.1
0019C:  BRA    01D2
....................    { 
....................       GoIOXstatus.n_timeOutACKFromServer+= interruptTime; 
0019E:  MOVLW  05
001A0:  ADDWF  x82,F
001A2:  MOVLW  00
001A4:  ADDWFC x83,F
001A6:  ADDWFC x84,F
001A8:  ADDWFC x85,F
....................       if(GoIOXstatus.n_timeOutACKFromServer >= GoIOXstatus.p_timeOutACKFromServer) 
001AA:  MOVF   x81,W
001AC:  SUBWF  x85,W
001AE:  BNC   01D2
001B0:  BNZ   01C8
001B2:  MOVF   x80,W
001B4:  SUBWF  x84,W
001B6:  BNC   01D2
001B8:  BNZ   01C8
001BA:  MOVF   x7F,W
001BC:  SUBWF  x83,W
001BE:  BNC   01D2
001C0:  BNZ   01C8
001C2:  MOVF   x7E,W
001C4:  SUBWF  x82,W
001C6:  BNC   01D2
....................       { 
....................          GoIOXstatus.WattingACKmimeFromServer = false; 
001C8:  BCF    x7D.1
....................          GoIOXstatus.n_timeOutACKFromServer = 0; 
001CA:  CLRF   x85
001CC:  CLRF   x84
001CE:  CLRF   x83
001D0:  CLRF   x82
....................       } 
....................    } 
....................     
....................    if(GoIOXstatus.WattingGoInfoResponse == true) 
001D2:  BTFSS  x74.0
001D4:  BRA    020C
....................    { 
....................       GoIOXstatus.n_timeOutGoInfoResponse += interruptTime; 
001D6:  MOVLW  05
001D8:  ADDWF  x79,F
001DA:  MOVLW  00
001DC:  ADDWFC x7A,F
001DE:  ADDWFC x7B,F
001E0:  ADDWFC x7C,F
....................       if(GoIOXstatus.n_timeOutGoInfoResponse >= GoIOXstatus.p_timeOutGoInfoResponse) 
001E2:  MOVF   x78,W
001E4:  SUBWF  x7C,W
001E6:  BNC   020C
001E8:  BNZ   0200
001EA:  MOVF   x77,W
001EC:  SUBWF  x7B,W
001EE:  BNC   020C
001F0:  BNZ   0200
001F2:  MOVF   x76,W
001F4:  SUBWF  x7A,W
001F6:  BNC   020C
001F8:  BNZ   0200
001FA:  MOVF   x75,W
001FC:  SUBWF  x79,W
001FE:  BNC   020C
....................       { 
....................          GoIOXstatus.WattingGoInfoResponse = false; 
00200:  BCF    x74.0
....................          GoIOXstatus.n_timeOutGoInfoResponse = 0; 
00202:  CLRF   x7C
00204:  CLRF   x7B
00206:  CLRF   x7A
00208:  CLRF   x79
....................          GoIOXstatus.synchronized = False; 
0020A:  BCF    x63.0
....................       } 
....................    } 
0020C:  GOTO   0396 (RETURN)
.................... } 
....................  
.................... void HOS_Set_Buffer(unsigned int8 Dato) 
.................... { 
....................    switch (HOS_Command) 
*
0052E:  MOVF   x91,W
00530:  XORLW  00
00532:  BZ    054A
00534:  XORLW  01
00536:  BZ    0562
00538:  XORLW  03
0053A:  BZ    056E
0053C:  XORLW  01
0053E:  BZ    057A
00540:  XORLW  07
00542:  BZ    05AA
00544:  XORLW  01
00546:  BZ    05B6
00548:  BRA    0626
....................    { 
....................       case 0: 
....................       { 
....................          if(Dato == 0x02) 
0054A:  MOVLB  7
0054C:  MOVF   xDF,W
0054E:  SUBLW  02
00550:  BNZ   055E
....................          { 
....................             Msg_Index = 0; 
00552:  MOVLB  1
00554:  CLRF   x8E
....................             HOS_Command++; 
00556:  MOVLB  0
00558:  INCF   x91,F
....................             GoIOXstatus.msgReady = False; 
0055A:  BCF    x63.2
0055C:  MOVLB  7
....................          } 
....................          break; 
0055E:  BRA    0632
00560:  MOVLB  0
....................       } 
....................       case 1: 
....................       { 
....................          Msg_Type  = Dato; 
00562:  MOVFF  7DF,92
....................          HOS_Command++; 
00566:  INCF   x91,F
....................          break; 
00568:  MOVLB  7
0056A:  BRA    0632
0056C:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          Msg_Leng  = Dato; 
0056E:  MOVFF  7DF,93
....................          HOS_Command++; 
00572:  INCF   x91,F
....................          break; 
00574:  MOVLB  7
00576:  BRA    0632
00578:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          if(Msg_Index >= Msg_Leng) 
0057A:  MOVF   x93,W
0057C:  MOVLB  1
0057E:  SUBWF  x8E,W
00580:  BNC   058E
....................          { 
....................             Msg_ChkA = Dato; 
00582:  MOVFF  7DF,18F
....................             HOS_Command++; 
00586:  MOVLB  0
00588:  INCF   x91,F
....................          } 
0058A:  BRA    05A4
0058C:  MOVLB  1
....................          else 
....................          { 
....................             Msg_Data[Msg_Index++] = Dato; 
0058E:  MOVF   x8E,W
00590:  INCF   x8E,F
00592:  CLRF   03
00594:  ADDLW  94
00596:  MOVWF  FE9
00598:  MOVLW  00
0059A:  ADDWFC 03,W
0059C:  MOVWF  FEA
0059E:  MOVFF  7DF,FEF
005A2:  MOVLB  0
....................          } 
....................          break; 
005A4:  MOVLB  7
005A6:  BRA    0632
005A8:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          Msg_ChkB = Dato; 
005AA:  MOVFF  7DF,190
....................          HOS_Command++; 
005AE:  INCF   x91,F
....................          break; 
005B0:  MOVLB  7
005B2:  BRA    0632
005B4:  MOVLB  0
....................       } 
....................       case 5: 
....................       { 
....................          if(Dato == 0x03) 
005B6:  MOVLB  7
005B8:  MOVF   xDF,W
005BA:  SUBLW  03
005BC:  BNZ   061C
....................          { 
....................             unsigned int8 A = 2, B = 2; 
005BE:  MOVLW  02
005C0:  MOVWF  xE0
005C2:  MOVWF  xE1
....................              
....................             A = A + Msg_Type; 
005C4:  MOVLB  0
005C6:  MOVF   x92,W
005C8:  MOVLB  7
005CA:  ADDWF  xE0,F
....................             B = A + B; 
005CC:  MOVF   xE0,W
005CE:  ADDWF  xE1,F
....................             A = A + Msg_Leng; 
005D0:  MOVLB  0
005D2:  MOVF   x93,W
005D4:  MOVLB  7
005D6:  ADDWF  xE0,F
....................             B = A + B; 
005D8:  MOVF   xE0,W
005DA:  ADDWF  xE1,F
....................             for(unsigned int i = 0; i < Msg_Leng; i++) 
005DC:  CLRF   xE2
005DE:  MOVLB  0
005E0:  MOVF   x93,W
005E2:  MOVLB  7
005E4:  SUBWF  xE2,W
005E6:  BC    0602
....................             { 
....................                A = A + Msg_Data[i]; 
005E8:  CLRF   03
005EA:  MOVF   xE2,W
005EC:  ADDLW  94
005EE:  MOVWF  FE9
005F0:  MOVLW  00
005F2:  ADDWFC 03,W
005F4:  MOVWF  FEA
005F6:  MOVF   FEF,W
005F8:  ADDWF  xE0,F
....................                B = A + B; 
005FA:  MOVF   xE0,W
005FC:  ADDWF  xE1,F
005FE:  INCF   xE2,F
00600:  BRA    05DE
....................             } 
....................              
....................             if((A == Msg_ChkA) && (B == Msg_ChkB)) 
00602:  MOVLB  1
00604:  MOVF   x8F,W
00606:  MOVLB  7
00608:  SUBWF  xE0,W
0060A:  BNZ   061C
0060C:  MOVLB  1
0060E:  MOVF   x90,W
00610:  MOVLB  7
00612:  SUBWF  xE1,W
00614:  BNZ   061C
....................             { 
....................               GoIOXstatus.msgReady = True; 
00616:  MOVLB  0
00618:  BSF    x63.2
0061A:  MOVLB  7
....................                //output_toggle(Led); 
....................             }             
....................          } 
....................          HOS_Command = 0; 
0061C:  MOVLB  0
0061E:  CLRF   x91
....................          break; 
00620:  MOVLB  7
00622:  BRA    0632
00624:  MOVLB  0
....................       } 
....................       default: 
....................       { 
....................          Msg_Index = 0; 
00626:  MOVLB  1
00628:  CLRF   x8E
....................          HOS_Command = 0; 
0062A:  MOVLB  0
0062C:  CLRF   x91
....................          GoIOXstatus.msgReady = False; 
0062E:  BCF    x63.2
....................          break; 
00630:  MOVLB  7
....................       } 
....................    }    
00632:  MOVLB  0
00634:  GOTO   0648 (RETURN)
.................... } 
....................  
.................... void SentThirdPartyDataStatusData(unsigned int1 Prioritario, unsigned int16 Data_Id, unsigned int32 Data) 
.................... { 
....................    HOS_CHKA = 0; 
*
01E20:  CLRF   x8F
....................    HOS_CHKB = 0; 
01E22:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01E24:  MOVLW  02
01E26:  MOVLB  6
01E28:  MOVWF  xCC
....................    CheckSum(DataOut); 
01E2A:  MOVFF  6CC,7D2
01E2E:  MOVLB  0
01E30:  RCALL  19F8
....................     
....................    if(Prioritario == true){DataOut = ThirdPartyPriorityStatusData;} 
01E32:  MOVLB  6
01E34:  DECFSZ xC5,W
01E36:  BRA    1E3E
01E38:  MOVLW  87
01E3A:  MOVWF  xCC
01E3C:  BRA    1E42
....................    else                   {DataOut = ThirdPartyDataStatusData;} 
01E3E:  MOVLW  80
01E40:  MOVWF  xCC
....................    CheckSum(DataOut); 
01E42:  MOVFF  6CC,7D2
01E46:  MOVLB  0
01E48:  RCALL  19F8
....................     
....................    DataOut = 0x06; //Longitud 
01E4A:  MOVLW  06
01E4C:  MOVLB  6
01E4E:  MOVWF  xCC
....................    CheckSum(DataOut); 
01E50:  MOVFF  6CC,7D2
01E54:  MOVLB  0
01E56:  RCALL  19F8
....................     
....................    DataOut = MAKE8(Data_Id, 0); //Id 
01E58:  MOVLB  6
01E5A:  MOVFF  6C6,6CC
....................    CheckSum(DataOut); 
01E5E:  MOVFF  6CC,7D2
01E62:  MOVLB  0
01E64:  RCALL  19F8
....................     
....................    DataOut = MAKE8(Data_Id, 1); //Id 
01E66:  MOVLB  6
01E68:  MOVFF  6C7,6CC
....................    CheckSum(DataOut); 
01E6C:  MOVFF  6CC,7D2
01E70:  MOVLB  0
01E72:  RCALL  19F8
....................     
....................    DataOut = Data; 
01E74:  MOVFF  6C8,6CC
....................    CheckSum(DataOut); 
01E78:  MOVFF  6CC,7D2
01E7C:  RCALL  19F8
....................     
....................    DataOut = Data >> 8; 
01E7E:  MOVFF  6C9,6CC
....................    CheckSum(DataOut); 
01E82:  MOVFF  6CC,7D2
01E86:  RCALL  19F8
....................     
....................    DataOut = Data >> 16; 
01E88:  MOVFF  6CA,6CC
....................    CheckSum(DataOut); 
01E8C:  MOVFF  6CC,7D2
01E90:  RCALL  19F8
....................     
....................    DataOut = Data >> 24; 
01E92:  MOVFF  6CB,6CC
....................    CheckSum(DataOut); 
01E96:  MOVFF  6CC,7D2
01E9A:  RCALL  19F8
....................     
....................    putC(HOS_CHKA,IOX); 
01E9C:  MOVF   x8F,W
01E9E:  RCALL  19EE
....................    putC(HOS_CHKB,IOX); 
01EA0:  MOVF   x90,W
01EA2:  RCALL  19EE
....................    putC(0x03,IOX); 
01EA4:  MOVLW  03
01EA6:  RCALL  19EE
....................    GoIOXstatus.WattingACK = 2; 
01EA8:  MOVLW  02
01EAA:  MOVWF  x60
....................    return ; 
01EAC:  RETURN 0
.................... } 
....................  
.................... void SentFreeFormatThirdPartyData(unsigned int8 Size, unsigned int8 *Data) 
.................... { 
....................    HOS_CHKA = 0; 
*
01DA0:  CLRF   x8F
....................    HOS_CHKB = 0; 
01DA2:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01DA4:  MOVLW  02
01DA6:  MOVLB  6
01DA8:  MOVWF  xC8
....................    CheckSum(DataOut); 
01DAA:  MOVFF  6C8,7D2
01DAE:  MOVLB  0
01DB0:  RCALL  19F8
....................     
....................    DataOut = FreeFormatThirdPartyData; 
01DB2:  MOVLW  82
01DB4:  MOVLB  6
01DB6:  MOVWF  xC8
....................    CheckSum(DataOut); 
01DB8:  MOVFF  6C8,7D2
01DBC:  MOVLB  0
01DBE:  RCALL  19F8
....................     
....................    if(Size > 27){Size = 27;} 
01DC0:  MOVLB  6
01DC2:  MOVF   xC5,W
01DC4:  SUBLW  1B
01DC6:  BC    1DCC
01DC8:  MOVLW  1B
01DCA:  MOVWF  xC5
....................    DataOut = Size; //Longitud 
01DCC:  MOVFF  6C5,6C8
....................    CheckSum(DataOut); 
01DD0:  MOVFF  6C8,7D2
01DD4:  MOVLB  0
01DD6:  RCALL  19F8
....................     
....................    for(unsigned int8 i = 0; i < Size; i++) 
01DD8:  MOVLB  6
01DDA:  CLRF   xC9
01DDC:  MOVF   xC5,W
01DDE:  SUBWF  xC9,W
01DE0:  BC    1E06
....................    { 
....................       DataOut = *Data++; 
01DE2:  MOVFF  6C7,03
01DE6:  MOVF   xC6,W
01DE8:  INCF   xC6,F
01DEA:  BTFSC  FD8.2
01DEC:  INCF   xC7,F
01DEE:  MOVWF  FE9
01DF0:  MOVFF  03,FEA
01DF4:  MOVFF  FEF,6C8
....................       CheckSum(DataOut); 
01DF8:  MOVFF  6C8,7D2
01DFC:  MOVLB  0
01DFE:  RCALL  19F8
01E00:  MOVLB  6
01E02:  INCF   xC9,F
01E04:  BRA    1DDC
....................    } 
....................     
....................    putC(HOS_CHKA,IOX); 
01E06:  MOVLB  0
01E08:  MOVF   x8F,W
01E0A:  RCALL  19EE
....................    putC(HOS_CHKB,IOX); 
01E0C:  MOVF   x90,W
01E0E:  RCALL  19EE
....................    putC(0x03,IOX); 
01E10:  MOVLW  03
01E12:  RCALL  19EE
....................    GoIOXstatus.WattingACK = 1; 
01E14:  MOVLW  01
01E16:  MOVWF  x60
....................    GoIOXstatus.customsSent++; 
01E18:  INCF   x66,F
01E1A:  BTFSC  FD8.2
01E1C:  INCF   x67,F
....................    return ; 
01E1E:  RETURN 0
.................... } 
....................  
.................... void SentBinaryDataPacket(unsigned int8 Size, unsigned int8 *Data) 
.................... {  
....................    HOS_CHKA = 0; 
*
01A0E:  CLRF   x8F
....................    HOS_CHKB = 0; 
01A10:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01A12:  MOVLW  02
01A14:  MOVLB  7
01A16:  MOVWF  xD0
....................    CheckSum(DataOut); 
01A18:  MOVFF  7D0,7D2
01A1C:  MOVLB  0
01A1E:  RCALL  19F8
....................    //fprintf(Serial,"Binary %X ",DataOut); 
....................     
....................    DataOut = BinaryDataPacketOUT; 
01A20:  MOVLW  86
01A22:  MOVLB  7
01A24:  MOVWF  xD0
....................    CheckSum(DataOut); 
01A26:  MOVFF  7D0,7D2
01A2A:  MOVLB  0
01A2C:  RCALL  19F8
....................    //fprintf(Serial," %X ",DataOut); 
....................     
....................    if(Size > 250){Size = 250;} 
01A2E:  MOVLB  7
01A30:  MOVF   xCD,W
01A32:  SUBLW  FA
01A34:  BC    1A3A
01A36:  MOVLW  FA
01A38:  MOVWF  xCD
....................    DataOut = Size; //Longitud 
01A3A:  MOVFF  7CD,7D0
....................    CheckSum(DataOut); 
01A3E:  MOVFF  7D0,7D2
01A42:  MOVLB  0
01A44:  RCALL  19F8
....................    //fprintf(Serial," %X ",DataOut); 
....................     
....................    for(unsigned int8 i = 0; i < Size; i++) 
01A46:  MOVLB  7
01A48:  CLRF   xD1
01A4A:  MOVF   xCD,W
01A4C:  SUBWF  xD1,W
01A4E:  BC    1A74
....................    { 
....................       DataOut = *Data++; 
01A50:  MOVFF  7CF,03
01A54:  MOVF   xCE,W
01A56:  INCF   xCE,F
01A58:  BTFSC  FD8.2
01A5A:  INCF   xCF,F
01A5C:  MOVWF  FE9
01A5E:  MOVFF  03,FEA
01A62:  MOVFF  FEF,7D0
....................       CheckSum(DataOut); 
01A66:  MOVFF  7D0,7D2
01A6A:  MOVLB  0
01A6C:  RCALL  19F8
01A6E:  MOVLB  7
01A70:  INCF   xD1,F
01A72:  BRA    1A4A
....................       //fprintf(Serial," %X ",DataOut); 
....................    } 
....................     
....................    putC(HOS_CHKA,IOX); 
01A74:  MOVLB  0
01A76:  MOVF   x8F,W
01A78:  RCALL  19EE
....................    //fprintf(Serial," %X ",HOS_CHKA); 
....................    putC(HOS_CHKB,IOX); 
01A7A:  MOVF   x90,W
01A7C:  RCALL  19EE
....................    //fprintf(Serial," %X ",HOS_CHKB); 
....................    putC(0x03,IOX); 
01A7E:  MOVLW  03
01A80:  RCALL  19EE
....................    //fprintf(Serial,"03\n\r"); 
....................    GoIOXstatus.WattingACKmime = True; 
01A82:  BSF    4F.0
....................    GoIOXstatus.WattingACKmimeFromServer = true; 
01A84:  BSF    x7D.1
....................    GoIOXstatus.n_timeOutACKFromServer = 0; 
01A86:  CLRF   x85
01A88:  CLRF   x84
01A8A:  CLRF   x83
01A8C:  CLRF   x82
....................    return ; 
01A8E:  GOTO   1C1E (RETURN)
.................... } 
....................  
.................... void SentMIMEPacket(unsigned int16 Size, unsigned int8 *Data) 
.................... { 
....................    unsigned int16 IndexDataIN = 0; 
....................    unsigned int8  BufferOut[250]; 
....................    unsigned int8  indexPacket = 0; 
....................    unsigned int8  index_dataOut = 0; 
....................     
....................    BufferOut[index_dataOut++]  = indexPacket; 
....................    BufferOut[index_dataOut++]  = Size_type; 
....................    for(unsigned int8 i = 0; i < Size_type; i++) 
....................    { 
....................       BufferOut[index_dataOut++] = (unsigned int8)type[i]; 
....................    } 
....................     
....................    unsigned int32 Payload = Size; 
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 0); 
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 1); 
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 2); 
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 3); 
....................     
....................    unsigned int1 final = false; 
....................    for(unsigned int16 j = 0; j <= (244 - Size_type) ; j++) 
....................    { 
....................       if(index_dataOut < (Size + 6 + Size_type)) 
....................       { 
....................          BufferOut[index_dataOut] = *Data++; 
....................       } 
....................       else 
....................       { 
....................          final = true; 
....................          j = 255; //aseguramos salir del ciclo 
....................       } 
....................       restart_wdt();       
....................       IndexDataIN   ++; 
....................       index_dataOut ++; 
....................    } 
....................    index_dataOut--; 
....................    Data--; 
....................    SentBinaryDataPacket(index_dataOut, &BufferOut); 
....................    delay_ms(100); 
....................     
....................    unsigned int8 index = 1; 
....................    while(final == false) 
....................    {      
....................       index_dataOut = 0; 
....................       BufferOut[0]  = index; 
....................       index++; 
....................       index_dataOut++; 
....................        
....................       for(unsigned int8 i = 0; i < 249; i++) 
....................       { 
....................          BufferOut[index_dataOut++] = *Data++; 
....................          IndexDataIN ++; 
....................          if(IndexDataIN >= (Size + 1)) 
....................          { 
....................             final = true; 
....................             break; 
....................          } 
....................       } 
....................        
....................       SentBinaryDataPacket(index_dataOut, &BufferOut); 
....................       delay_ms(100); 
....................       restart_wdt(); 
....................    } 
....................    return ; 
.................... } 
....................  
.................... void SentRequestDeviceDataMessage(void) 
.................... { 
....................    HOS_CHKA = 0; 
*
01EAE:  CLRF   x8F
....................    HOS_CHKB = 0; 
01EB0:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01EB2:  MOVLW  02
01EB4:  MOVLB  6
01EB6:  MOVWF  xC5
....................    CheckSum(DataOut); 
01EB8:  MOVFF  6C5,7D2
01EBC:  MOVLB  0
01EBE:  RCALL  19F8
....................     
....................    DataOut = RequestDeviceDataMessage; 
01EC0:  MOVLW  85
01EC2:  MOVLB  6
01EC4:  MOVWF  xC5
....................    CheckSum(DataOut); 
01EC6:  MOVFF  6C5,7D2
01ECA:  MOVLB  0
01ECC:  RCALL  19F8
....................     
....................    DataOut = 0; //Longitud 
01ECE:  MOVLB  6
01ED0:  CLRF   xC5
....................    CheckSum(DataOut); 
01ED2:  MOVFF  6C5,7D2
01ED6:  MOVLB  0
01ED8:  RCALL  19F8
....................     
....................    putC(HOS_CHKA,IOX); 
01EDA:  MOVF   x8F,W
01EDC:  RCALL  19EE
....................    putC(HOS_CHKB,IOX); 
01EDE:  MOVF   x90,W
01EE0:  RCALL  19EE
....................    putC(0x03,IOX); 
01EE2:  MOVLW  03
01EE4:  RCALL  19EE
....................    GoIOXstatus.WattingGoInfoResponse = true; 
01EE6:  BSF    x74.0
....................     
....................    return ; 
01EE8:  RETURN 0
.................... } 
....................  
.................... void SentDeviceDataACK(void) 
.................... { 
....................    HOS_CHKA = 0; 
*
01FAA:  CLRF   x8F
....................    HOS_CHKB = 0; 
01FAC:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01FAE:  MOVLW  02
01FB0:  MOVLB  6
01FB2:  MOVWF  xC5
....................    CheckSum(DataOut); 
01FB4:  MOVFF  6C5,7D2
01FB8:  MOVLB  0
01FBA:  RCALL  19F8
....................     
....................    DataOut = DeviceDataACK; 
01FBC:  MOVLW  84
01FBE:  MOVLB  6
01FC0:  MOVWF  xC5
....................    CheckSum(DataOut); 
01FC2:  MOVFF  6C5,7D2
01FC6:  MOVLB  0
01FC8:  RCALL  19F8
....................     
....................    DataOut = 0; //Longitud 
01FCA:  MOVLB  6
01FCC:  CLRF   xC5
....................    CheckSum(DataOut); 
01FCE:  MOVFF  6C5,7D2
01FD2:  MOVLB  0
01FD4:  RCALL  19F8
....................     
....................    putC(HOS_CHKA,IOX); 
01FD6:  MOVF   x8F,W
01FD8:  RCALL  19EE
....................    putC(HOS_CHKB,IOX); 
01FDA:  MOVF   x90,W
01FDC:  RCALL  19EE
....................    putC(0x03,IOX); 
01FDE:  MOVLW  03
01FE0:  RCALL  19EE
....................    return ; 
01FE2:  GOTO   3DAC (RETURN)
.................... } 
....................  
.................... void SentHandShakeRequest(void) 
.................... { 
....................    putC(0x55,IOX); 
*
01F20:  MOVLW  55
01F22:  RCALL  19EE
....................    return; 
01F24:  GOTO   3C3E (RETURN)
.................... } 
....................  
.................... void SentHandshakeConfirmation(unsigned int16 DeviceId, int1 ACKConfirmation, int1 BinaryDataWrapping) 
.................... { 
....................    HOS_CHKA = 0; 
01F28:  CLRF   x8F
....................    HOS_CHKB = 0; 
01F2A:  CLRF   x90
....................     
....................    unsigned int8 DataOut; 
....................     
....................    DataOut = 0x02; 
01F2C:  MOVLW  02
01F2E:  MOVLB  6
01F30:  MOVWF  xC9
....................    CheckSum(DataOut); 
01F32:  MOVFF  6C9,7D2
01F36:  MOVLB  0
01F38:  RCALL  19F8
....................     
....................    DataOut = HandshakeConfirmation; 
01F3A:  MOVLW  81
01F3C:  MOVLB  6
01F3E:  MOVWF  xC9
....................    CheckSum(DataOut); 
01F40:  MOVFF  6C9,7D2
01F44:  MOVLB  0
01F46:  RCALL  19F8
....................     
....................    DataOut = 4; //Longitud 
01F48:  MOVLW  04
01F4A:  MOVLB  6
01F4C:  MOVWF  xC9
....................    CheckSum(DataOut); 
01F4E:  MOVFF  6C9,7D2
01F52:  MOVLB  0
01F54:  RCALL  19F8
....................     
....................    DataOut = MAKE8(DeviceId, 0); //Id 
01F56:  MOVLB  6
01F58:  MOVFF  6C5,6C9
....................    CheckSum(DataOut); 
01F5C:  MOVFF  6C9,7D2
01F60:  MOVLB  0
01F62:  RCALL  19F8
....................     
....................    DataOut = MAKE8(DeviceId, 1); //Id 
01F64:  MOVLB  6
01F66:  MOVFF  6C6,6C9
....................    CheckSum(DataOut); 
01F6A:  MOVFF  6C9,7D2
01F6E:  MOVLB  0
01F70:  RCALL  19F8
....................     
....................    DataOut = ((0b00000000) | (ACKConfirmation & 0b00000001) | ((BinaryDataWrapping << 1) & 0b00000010)); 
01F72:  MOVLB  6
01F74:  MOVF   xC7,W
01F76:  ANDLW  01
01F78:  MOVWF  xCA
01F7A:  BCF    FD8.0
01F7C:  RLCF   xC8,W
01F7E:  ANDLW  02
01F80:  IORWF  xCA,W
01F82:  MOVWF  xC9
....................    CheckSum(DataOut); 
01F84:  MOVFF  6C9,7D2
01F88:  MOVLB  0
01F8A:  RCALL  19F8
....................     
....................    DataOut = 0; 
01F8C:  MOVLB  6
01F8E:  CLRF   xC9
....................    CheckSum(DataOut); 
01F90:  MOVFF  6C9,7D2
01F94:  MOVLB  0
01F96:  RCALL  19F8
....................     
....................    putC(HOS_CHKA,IOX); 
01F98:  MOVF   x8F,W
01F9A:  RCALL  19EE
....................    putC(HOS_CHKB,IOX); 
01F9C:  MOVF   x90,W
01F9E:  RCALL  19EE
....................    putC(0x03,IOX); 
01FA0:  MOVLW  03
01FA2:  RCALL  19EE
....................    GoIOXstatus.synchronized = True; 
01FA4:  BSF    x63.0
....................    return ; 
01FA6:  GOTO   3D0E (RETURN)
.................... } 
....................  
.................... void CheckSum(unsigned int8 Data) 
.................... { 
....................    HOS_CHKA = HOS_CHKA + Data; 
*
019F8:  MOVLB  7
019FA:  MOVF   xD2,W
019FC:  MOVLB  0
019FE:  ADDWF  x8F,F
....................    HOS_CHKB = HOS_CHKA + HOS_CHKB; 
01A00:  MOVF   x8F,W
01A02:  ADDWF  x90,F
....................    putC(Data,IOX); 
01A04:  MOVLB  7
01A06:  MOVF   xD2,W
01A08:  MOVLB  0
01A0A:  RCALL  19EE
01A0C:  RETURN 0
....................    //fprintf(Serial,"%X ",Data); 
.................... } 
....................  
.................... void GetParameters(HOS_DeviceData *Dato) 
.................... { 
....................    HOS_DeviceData Result;    
....................    Result.DateTime  = Make32(Msg_Data[0],Msg_Data[1],Msg_Data[2],Msg_Data[3]); 
*
01FE6:  MOVFF  94,6CA
01FEA:  MOVFF  95,6C9
01FEE:  MOVFF  96,6C8
01FF2:  MOVFF  97,6C7
....................    Result.Latitude  = Make32(Msg_Data[4],Msg_Data[5],Msg_Data[6],Msg_Data[7]); 
01FF6:  MOVFF  98,6CE
01FFA:  MOVFF  99,6CD
01FFE:  MOVFF  9A,6CC
02002:  MOVFF  9B,6CB
....................    Result.Longitud  = Make32(Msg_Data[8],Msg_Data[9],Msg_Data[10],Msg_Data[11]); 
02006:  MOVFF  9C,6D2
0200A:  MOVFF  9D,6D1
0200E:  MOVFF  9E,6D0
02012:  MOVFF  9F,6CF
....................    Result.Velocidad = Msg_Data[12]; 
02016:  MOVFF  A0,6D3
....................    Result.RPM       = Make16(Msg_Data[13],Msg_Data[14]); 
0201A:  MOVFF  A1,6D5
0201E:  MOVFF  A2,6D4
....................    Result.Odometro  = Make32(Msg_Data[15],Msg_Data[16],Msg_Data[17],Msg_Data[18]); 
02022:  MOVFF  A3,6D9
02026:  MOVFF  A4,6D8
0202A:  MOVFF  A5,6D7
0202E:  MOVFF  A6,6D6
....................    Result.GpsValid           =  Msg_Data[19] & 0b00000001; 
02032:  MOVF   xA7,W
02034:  ANDLW  01
02036:  MOVLB  6
02038:  BCF    xDA.0
0203A:  BTFSC  FE8.0
0203C:  BSF    xDA.0
....................    Result.Ignition           = (Msg_Data[19] & 0b00000010) >> 1; 
0203E:  MOVLB  0
02040:  MOVF   xA7,W
02042:  ANDLW  02
02044:  MOVWF  00
02046:  BCF    FD8.0
02048:  RRCF   00,F
0204A:  MOVLB  6
0204C:  BCF    xDA.1
0204E:  BTFSC  00.0
02050:  BSF    xDA.1
....................    Result.EngineActivity     = (Msg_Data[19] & 0b00000100) >> 2; 
02052:  MOVLB  0
02054:  MOVF   xA7,W
02056:  ANDLW  04
02058:  MOVWF  00
0205A:  RRCF   00,F
0205C:  RRCF   00,F
0205E:  MOVLW  3F
02060:  ANDWF  00,F
02062:  MOVLB  6
02064:  BCF    xDA.2
02066:  BTFSC  00.0
02068:  BSF    xDA.2
....................    Result.DateValid          = (Msg_Data[19] & 0b00001000) >> 3; 
0206A:  MOVLB  0
0206C:  MOVF   xA7,W
0206E:  ANDLW  08
02070:  MOVWF  00
02072:  RRCF   00,F
02074:  RRCF   00,F
02076:  RRCF   00,F
02078:  MOVLW  1F
0207A:  ANDWF  00,F
0207C:  MOVLB  6
0207E:  BCF    xDA.3
02080:  BTFSC  00.0
02082:  BSF    xDA.3
....................    Result.SpeedFromEngine    = (Msg_Data[19] & 0b00010000) >> 4; 
02084:  MOVLB  0
02086:  MOVF   xA7,W
02088:  ANDLW  10
0208A:  MOVWF  00
0208C:  SWAPF  00,F
0208E:  MOVLW  0F
02090:  ANDWF  00,F
02092:  MOVLB  6
02094:  BCF    xDA.4
02096:  BTFSC  00.0
02098:  BSF    xDA.4
....................    Result.OdometerFromEngine = (Msg_Data[19] & 0b00100000) >> 5; 
0209A:  MOVLB  0
0209C:  MOVF   xA7,W
0209E:  ANDLW  20
020A0:  MOVWF  00
020A2:  SWAPF  00,F
020A4:  RRCF   00,F
020A6:  MOVLW  07
020A8:  ANDWF  00,F
020AA:  MOVLB  6
020AC:  BCF    xDA.5
020AE:  BTFSC  00.0
020B0:  BSF    xDA.5
....................    Result.TripOdometer       = Make32(Msg_Data[20],Msg_Data[21],Msg_Data[22],Msg_Data[23]); 
020B2:  MOVFF  A8,6DE
020B6:  MOVFF  A9,6DD
020BA:  MOVFF  AA,6DC
020BE:  MOVFF  AB,6DB
....................    Result.TotalEngineHours   = Make32(Msg_Data[24],Msg_Data[25],Msg_Data[26],Msg_Data[27]); 
020C2:  MOVFF  AC,6E2
020C6:  MOVFF  AD,6E1
020CA:  MOVFF  AE,6E0
020CE:  MOVFF  AF,6DF
....................    Result.TripDuration       = Make32(Msg_Data[28],Msg_Data[29],Msg_Data[30],Msg_Data[31]); 
020D2:  MOVFF  B0,6E6
020D6:  MOVFF  B1,6E5
020DA:  MOVFF  B2,6E4
020DE:  MOVFF  B3,6E3
....................    Result.GoID               = Make32(Msg_Data[32],Msg_Data[33],Msg_Data[34],Msg_Data[35]); 
020E2:  MOVFF  B4,6EA
020E6:  MOVFF  B5,6E9
020EA:  MOVFF  B6,6E8
020EE:  MOVFF  B7,6E7
....................    Result.DriverId           = Make32(Msg_Data[36],Msg_Data[37],Msg_Data[38],Msg_Data[39]); 
020F2:  MOVFF  B8,6EE
020F6:  MOVFF  B9,6ED
020FA:  MOVFF  BA,6EC
020FE:  MOVFF  BB,6EB
....................    memcpy(Dato, &Result, sizeof(HOS_DeviceData)); 
02102:  MOVFF  6C6,FEA
02106:  MOVFF  6C5,FE9
0210A:  MOVLW  06
0210C:  MOVWF  FE2
0210E:  MOVLW  C7
02110:  MOVWF  FE1
02112:  MOVLW  28
02114:  MOVWF  01
02116:  MOVFF  FE6,FEE
0211A:  DECFSZ 01,F
0211C:  BRA    2116
....................    return; 
0211E:  MOVLB  0
02120:  GOTO   3DBC (RETURN)
.................... } 
....................  
.................... void SentFormatMIMEPacket(unsigned int8 comando, unsigned int8 Size, unsigned int8 *Data) 
*
01A92:  MOVLB  7
01A94:  CLRF   xC3
01A96:  CLRF   xC4
01A98:  CLRF   xC5
.................... { 
....................    unsigned int8  BufferOut[250]; 
....................    unsigned int8  index_dataOut = 0; 
....................    unsigned int8 ca = 0; 
....................    unsigned int8 cb = 0; 
....................     
....................    BufferOut[index_dataOut++]  = 0; 
01A9A:  MOVF   xC3,W
01A9C:  INCF   xC3,F
01A9E:  CLRF   03
01AA0:  ADDLW  C9
01AA2:  MOVWF  FE9
01AA4:  MOVLW  06
01AA6:  ADDWFC 03,W
01AA8:  MOVWF  FEA
01AAA:  CLRF   FEF
....................    BufferOut[index_dataOut++]  = Size_type; 
01AAC:  MOVF   xC3,W
01AAE:  INCF   xC3,F
01AB0:  CLRF   03
01AB2:  ADDLW  C9
01AB4:  MOVWF  FE9
01AB6:  MOVLW  06
01AB8:  ADDWFC 03,W
01ABA:  MOVWF  FEA
01ABC:  MOVFF  28C,FEF
....................    for(unsigned int8 i = 0; i < Size_type; i++) 
01AC0:  CLRF   xC6
01AC2:  MOVLB  2
01AC4:  MOVF   x8C,W
01AC6:  MOVLB  7
01AC8:  SUBWF  xC6,W
01ACA:  BC    1B00
....................    { 
....................       BufferOut[index_dataOut++] = (unsigned int8)type[i]; 
01ACC:  MOVF   xC3,W
01ACE:  INCF   xC3,F
01AD0:  CLRF   03
01AD2:  ADDLW  C9
01AD4:  MOVWF  01
01AD6:  MOVLW  06
01AD8:  ADDWFC 03,F
01ADA:  MOVFF  03,7CE
01ADE:  CLRF   03
01AE0:  MOVF   xC6,W
01AE2:  ADDLW  8D
01AE4:  MOVWF  FE9
01AE6:  MOVLW  02
01AE8:  ADDWFC 03,W
01AEA:  MOVWF  FEA
01AEC:  MOVFF  FEF,7CF
01AF0:  MOVFF  7CE,FEA
01AF4:  MOVFF  01,FE9
01AF8:  MOVFF  7CF,FEF
01AFC:  INCF   xC6,F
01AFE:  BRA    1AC2
....................    } 
....................    unsigned int32 Payload = Size + 4; 
01B00:  MOVLW  04
01B02:  MOVLB  6
01B04:  ADDWF  xC6,W
01B06:  MOVLB  7
01B08:  MOVWF  xC7
01B0A:  CLRF   xC8
01B0C:  CLRF   xC9
01B0E:  CLRF   xCA
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 0); 
01B10:  MOVF   xC3,W
01B12:  INCF   xC3,F
01B14:  CLRF   03
01B16:  ADDLW  C9
01B18:  MOVWF  FE9
01B1A:  MOVLW  06
01B1C:  ADDWFC 03,W
01B1E:  MOVWF  FEA
01B20:  MOVFF  7C7,FEF
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 1); 
01B24:  MOVF   xC3,W
01B26:  INCF   xC3,F
01B28:  CLRF   03
01B2A:  ADDLW  C9
01B2C:  MOVWF  FE9
01B2E:  MOVLW  06
01B30:  ADDWFC 03,W
01B32:  MOVWF  FEA
01B34:  MOVFF  7C8,FEF
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 2); 
01B38:  MOVF   xC3,W
01B3A:  INCF   xC3,F
01B3C:  CLRF   03
01B3E:  ADDLW  C9
01B40:  MOVWF  FE9
01B42:  MOVLW  06
01B44:  ADDWFC 03,W
01B46:  MOVWF  FEA
01B48:  MOVFF  7C9,FEF
....................    BufferOut[index_dataOut++]  = MAKE8(Payload, 3); 
01B4C:  MOVF   xC3,W
01B4E:  INCF   xC3,F
01B50:  CLRF   03
01B52:  ADDLW  C9
01B54:  MOVWF  FE9
01B56:  MOVLW  06
01B58:  ADDWFC 03,W
01B5A:  MOVWF  FEA
01B5C:  MOVFF  7CA,FEF
....................     
....................    BufferOut[index_dataOut++]  = comando; 
01B60:  MOVF   xC3,W
01B62:  INCF   xC3,F
01B64:  CLRF   03
01B66:  ADDLW  C9
01B68:  MOVWF  FE9
01B6A:  MOVLW  06
01B6C:  ADDWFC 03,W
01B6E:  MOVWF  FEA
01B70:  MOVFF  6C5,FEF
....................    ca = ca + comando; 
01B74:  MOVLB  6
01B76:  MOVF   xC5,W
01B78:  MOVLB  7
01B7A:  ADDWF  xC4,F
....................    cb = cb + ca; 
01B7C:  MOVF   xC4,W
01B7E:  ADDWF  xC5,F
....................    BufferOut[index_dataOut++]  = Size; 
01B80:  MOVF   xC3,W
01B82:  INCF   xC3,F
01B84:  CLRF   03
01B86:  ADDLW  C9
01B88:  MOVWF  FE9
01B8A:  MOVLW  06
01B8C:  ADDWFC 03,W
01B8E:  MOVWF  FEA
01B90:  MOVFF  6C6,FEF
....................    ca = ca + Size; 
01B94:  MOVLB  6
01B96:  MOVF   xC6,W
01B98:  MOVLB  7
01B9A:  ADDWF  xC4,F
....................    cb = cb + ca; 
01B9C:  MOVF   xC4,W
01B9E:  ADDWF  xC5,F
....................    for(unsigned int8 j = 0; j < Size ; j++) 
01BA0:  CLRF   xCB
01BA2:  MOVLB  6
01BA4:  MOVF   xC6,W
01BA6:  MOVLB  7
01BA8:  SUBWF  xCB,W
01BAA:  BC    1BE6
....................    { 
....................       unsigned int8 var = *Data++; 
01BAC:  MOVLB  6
01BAE:  MOVFF  6C8,03
01BB2:  MOVF   xC7,W
01BB4:  INCF   xC7,F
01BB6:  BTFSC  FD8.2
01BB8:  INCF   xC8,F
01BBA:  MOVWF  FE9
01BBC:  MOVFF  03,FEA
01BC0:  MOVFF  FEF,7CC
....................       BufferOut[index_dataOut] = var; 
01BC4:  CLRF   03
01BC6:  MOVLB  7
01BC8:  MOVF   xC3,W
01BCA:  ADDLW  C9
01BCC:  MOVWF  FE9
01BCE:  MOVLW  06
01BD0:  ADDWFC 03,W
01BD2:  MOVWF  FEA
01BD4:  MOVFF  7CC,FEF
....................       ca = ca + var; 
01BD8:  MOVF   xCC,W
01BDA:  ADDWF  xC4,F
....................       cb = cb + ca;   
01BDC:  MOVF   xC4,W
01BDE:  ADDWF  xC5,F
....................       index_dataOut ++; 
01BE0:  INCF   xC3,F
01BE2:  INCF   xCB,F
01BE4:  BRA    1BA2
....................    } 
....................    BufferOut[index_dataOut++]  = ca; 
01BE6:  MOVF   xC3,W
01BE8:  INCF   xC3,F
01BEA:  CLRF   03
01BEC:  ADDLW  C9
01BEE:  MOVWF  FE9
01BF0:  MOVLW  06
01BF2:  ADDWFC 03,W
01BF4:  MOVWF  FEA
01BF6:  MOVFF  7C4,FEF
....................    BufferOut[index_dataOut++]  = cb; 
01BFA:  MOVF   xC3,W
01BFC:  INCF   xC3,F
01BFE:  CLRF   03
01C00:  ADDLW  C9
01C02:  MOVWF  FE9
01C04:  MOVLW  06
01C06:  ADDWFC 03,W
01C08:  MOVWF  FEA
01C0A:  MOVFF  7C5,FEF
....................     
....................    SentBinaryDataPacket(index_dataOut, &BufferOut); 
01C0E:  MOVFF  7C3,7CD
01C12:  MOVLW  06
01C14:  MOVWF  xCF
01C16:  MOVLW  C9
01C18:  MOVWF  xCE
01C1A:  MOVLB  0
01C1C:  BRA    1A0E
....................    GoIOXstatus.MIMESent++; 
01C1E:  INCF   56,F
01C20:  BTFSC  FD8.2
01C22:  INCF   57,F
....................    return ; 
01C24:  RETURN 0
.................... } 
....................  
....................  
.................... #include <ActuadorRemoto.c> 
.................... #define Relay PIN_C4 
....................  
.................... #define ActuadorONOFF 3 
.................... #define ActuadorTemporizado 5 
....................  
.................... #define ON 3 
.................... #define OFF 4 
.................... #define TimedOutput 5 
.................... unsigned int8 A_LocalCMD = 0; 
.................... unsigned int1 valueToPutInOutput = false; 
.................... struct   
.................... { 
....................    unsigned int1  ActivateTimedOutput; 
....................    unsigned int32 TimeInReset; 
....................    unsigned int32 TimeToReset; //tiempo programado para resetear despues de mandar accion 
....................    unsigned int32 TimeNow; //tiempo contado para hacer reset 
....................    unsigned int1  ActivateOutput; 
....................    unsigned int1  CancelPetition; 
....................    unsigned int8  OutputMode; //3 = actuador 5 = Actuador temporizado 
....................    unsigned int1  OutputState; 
....................    unsigned int1  SaveValue; 
....................     
....................    unsigned int8  LastPetition; //3 = on, 4 = off, 5 = timedOutput 
....................    unsigned int16 Pass; 
....................    unsigned int32 P_TimeOutPass; 
....................    unsigned int32 N_TimeOutPass; 
....................    unsigned int1  WaittingPass; 
.................... }Actuator; 
....................  
.................... void Actuator_Init(); 
.................... void Actuator_SetTime(void); 
.................... void Actuator_Set_Value(unsigned int1 status); 
....................  
.................... void Actuator_Init() 
.................... { 
....................    Actuator.ActivateTimedOutput = false; 
*
0151A:  MOVLB  2
0151C:  BCF    x98.0
....................     
....................    Actuator.TimeNow = 0; 
0151E:  CLRF   xA4
01520:  CLRF   xA3
01522:  CLRF   xA2
01524:  CLRF   xA1
....................    Actuator.N_TimeOutPass = 0; 
01526:  CLRF   xB2
01528:  CLRF   xB1
0152A:  CLRF   xB0
0152C:  CLRF   xAF
....................    Actuator.ActivateOutput = false; 
0152E:  BCF    xA5.0
....................    Actuator.CancelPetition = false; 
01530:  BCF    xA5.1
....................    Actuator.LastPetition = 0; 
01532:  CLRF   xA8
....................    Actuator.SaveValue = false;  
01534:  BCF    xA7.1
....................    Actuator.Pass = 10000; 
01536:  MOVLW  27
01538:  MOVWF  xAA
0153A:  MOVLW  10
0153C:  MOVWF  xA9
....................    Actuator.WaittingPass = false; 
0153E:  BCF    xB3.0
....................     
....................    Actuator.OutputMode    = ValoresIniciales.ACTmode; 
01540:  MOVFF  37,2A6
....................    Actuator.OutputState   = ValoresIniciales.ACTstatus;    
01544:  BCF    xA7.0
01546:  BTFSC  44.0
01548:  BSF    xA7.0
....................    Actuator.TimeInReset   = ValoresIniciales.ACTinReset; 
0154A:  MOVFF  3F,29C
0154E:  MOVFF  3E,29B
01552:  MOVFF  3D,29A
01556:  MOVFF  3C,299
....................    Actuator.TimeToReset   = ValoresIniciales.ACTtoReset; 
0155A:  MOVFF  3B,2A0
0155E:  MOVFF  3A,29F
01562:  MOVFF  39,29E
01566:  MOVFF  38,29D
....................    Actuator.P_TimeOutPass = ValoresIniciales.ACTtimeOutPIN; 
0156A:  MOVFF  43,2AE
0156E:  MOVFF  42,2AD
01572:  MOVFF  41,2AC
01576:  MOVFF  40,2AB
....................     
....................    if(Actuator.OutputMode == ActuadorONOFF) 
0157A:  MOVF   xA6,W
0157C:  SUBLW  03
0157E:  BNZ   158E
....................    { 
....................       output_bit(Relay,Actuator.OutputState); 
01580:  BTFSC  xA7.0
01582:  BRA    1588
01584:  BCF    F8B.4
01586:  BRA    158A
01588:  BSF    F8B.4
0158A:  BCF    F94.4
....................    } 
0158C:  BRA    15A2
....................    else if(Actuator.OutputMode == ActuadorTemporizado) 
0158E:  MOVF   xA6,W
01590:  SUBLW  05
01592:  BNZ   15A2
....................    { 
....................       Actuator.OutputState = 0; 
01594:  BCF    xA7.0
....................       output_bit(Relay,Actuator.OutputState); 
01596:  BTFSC  xA7.0
01598:  BRA    159E
0159A:  BCF    F8B.4
0159C:  BRA    15A0
0159E:  BSF    F8B.4
015A0:  BCF    F94.4
....................    }  
015A2:  MOVLB  0
015A4:  GOTO   26F0 (RETURN)
.................... } 
....................  
.................... void Actuator_SetTime() 
.................... { 
....................    if(Actuator.WaittingPass == true) 
*
00210:  MOVLB  2
00212:  BTFSS  xB3.0
00214:  BRA    024C
....................    { 
....................       Actuator.N_TimeOutPass +=interruptTime; 
00216:  MOVLW  05
00218:  ADDWF  xAF,F
0021A:  MOVLW  00
0021C:  ADDWFC xB0,F
0021E:  ADDWFC xB1,F
00220:  ADDWFC xB2,F
....................       if(Actuator.N_TimeOutPass >= Actuator.P_TimeOutPass)  
00222:  MOVF   xAE,W
00224:  SUBWF  xB2,W
00226:  BNC   024A
00228:  BNZ   0240
0022A:  MOVF   xAD,W
0022C:  SUBWF  xB1,W
0022E:  BNC   024A
00230:  BNZ   0240
00232:  MOVF   xAC,W
00234:  SUBWF  xB0,W
00236:  BNC   024A
00238:  BNZ   0240
0023A:  MOVF   xAB,W
0023C:  SUBWF  xAF,W
0023E:  BNC   024A
....................       { 
....................          Actuator.N_TimeOutPass = 0; 
00240:  CLRF   xB2
00242:  CLRF   xB1
00244:  CLRF   xB0
00246:  CLRF   xAF
....................          Actuator.WaittingPass = false; 
00248:  BCF    xB3.0
....................       } 
....................    } 
0024A:  BRA    0254
....................    else 
....................    { 
....................       Actuator.N_TimeOutPass = 0; 
0024C:  CLRF   xB2
0024E:  CLRF   xB1
00250:  CLRF   xB0
00252:  CLRF   xAF
....................    } 
....................    if(Actuator.OutputMode == ActuadorTemporizado) 
00254:  MOVF   xA6,W
00256:  SUBLW  05
00258:  BNZ   02FA
....................    { 
....................       if(Actuator.ActivateTimedOutput == true) 
0025A:  BTFSS  x98.0
0025C:  BRA    02DC
....................       { 
....................          Actuator.TimeNow +=interruptTime; 
0025E:  MOVLW  05
00260:  ADDWF  xA1,F
00262:  MOVLW  00
00264:  ADDWFC xA2,F
00266:  ADDWFC xA3,F
00268:  ADDWFC xA4,F
....................           
....................          switch(A_LocalCMD) 
0026A:  MOVF   x97,W
0026C:  XORLW  00
0026E:  MOVLB  0
00270:  BZ    0278
00272:  XORLW  01
00274:  BZ    02AA
00276:  BRA    02D8
....................          { 
....................             case 0: 
....................             { 
....................                if(Actuator.TimeNow > Actuator.TimeToReset) 
00278:  MOVLB  2
0027A:  MOVF   xA0,W
0027C:  SUBWF  xA4,W
0027E:  BNC   02A6
00280:  BNZ   0298
00282:  MOVF   x9F,W
00284:  SUBWF  xA3,W
00286:  BNC   02A6
00288:  BNZ   0298
0028A:  MOVF   x9E,W
0028C:  SUBWF  xA2,W
0028E:  BNC   02A6
00290:  BNZ   0298
00292:  MOVF   xA1,W
00294:  SUBWF  x9D,W
00296:  BC    02A6
....................                { 
....................                   //se cumplio primer etapa, se apaga equipo 
....................                   Actuator.OutputState = true; 
00298:  BSF    xA7.0
....................                   Actuator.TimeNow = 0; 
0029A:  CLRF   xA4
0029C:  CLRF   xA3
0029E:  CLRF   xA2
002A0:  CLRF   xA1
....................                   A_LocalCMD = 1; 
002A2:  MOVLW  01
002A4:  MOVWF  x97
....................                } 
....................                break; 
002A6:  MOVLB  0
002A8:  BRA    02D8
....................             } 
....................             case 1: 
....................             { 
....................                if(Actuator.TimeNow > Actuator.TimeInReset) 
002AA:  MOVLB  2
002AC:  MOVF   x9C,W
002AE:  SUBWF  xA4,W
002B0:  BNC   02D6
002B2:  BNZ   02CA
002B4:  MOVF   x9B,W
002B6:  SUBWF  xA3,W
002B8:  BNC   02D6
002BA:  BNZ   02CA
002BC:  MOVF   x9A,W
002BE:  SUBWF  xA2,W
002C0:  BNC   02D6
002C2:  BNZ   02CA
002C4:  MOVF   xA1,W
002C6:  SUBWF  x99,W
002C8:  BC    02D6
....................                { 
....................                   Actuator.ActivateTimedOutput = false; 
002CA:  BCF    x98.0
....................                   A_LocalCMD = 0; 
002CC:  CLRF   x97
....................                   Actuator.TimeNow = 0; 
002CE:  CLRF   xA4
002D0:  CLRF   xA3
002D2:  CLRF   xA2
002D4:  CLRF   xA1
....................                } 
....................                break; 
002D6:  MOVLB  0
....................             } 
....................          } 
....................       } 
002D8:  BRA    02EA
002DA:  MOVLB  2
....................       else 
....................       { 
....................          Actuator.OutputState = false; 
002DC:  BCF    xA7.0
....................          A_LocalCMD = 0; 
002DE:  CLRF   x97
....................          Actuator.TimeNow = 0; 
002E0:  CLRF   xA4
002E2:  CLRF   xA3
002E4:  CLRF   xA2
002E6:  CLRF   xA1
002E8:  MOVLB  0
....................       } 
....................       output_bit(Relay,Actuator.OutputState); 
002EA:  MOVLB  2
002EC:  BTFSC  xA7.0
002EE:  BRA    02F4
002F0:  BCF    F8B.4
002F2:  BRA    02F6
002F4:  BSF    F8B.4
002F6:  BCF    F94.4
....................    } 
002F8:  BRA    0346
....................    else if(Actuator.OutputMode == ActuadorONOFF) 
002FA:  MOVF   xA6,W
002FC:  SUBLW  03
002FE:  BNZ   0346
....................    { 
....................       if(Actuator.ActivateOutput == true) 
00300:  BTFSS  xA5.0
00302:  BRA    0346
....................       { 
....................          Actuator.TimeNow +=interruptTime; 
00304:  MOVLW  05
00306:  ADDWF  xA1,F
00308:  MOVLW  00
0030A:  ADDWFC xA2,F
0030C:  ADDWFC xA3,F
0030E:  ADDWFC xA4,F
....................          if(Actuator.TimeNow > 3000) 
00310:  MOVF   xA4,F
00312:  BNZ   0328
00314:  MOVF   xA3,F
00316:  BNZ   0328
00318:  MOVF   xA2,W
0031A:  SUBLW  0A
0031C:  BC    0346
0031E:  XORLW  FF
00320:  BNZ   0328
00322:  MOVF   xA1,W
00324:  SUBLW  B8
00326:  BC    0346
....................          { 
....................             Actuator.OutputState = valueToPutInOutput; 
00328:  BCF    xA7.0
0032A:  BTFSC  4D.2
0032C:  BSF    xA7.0
....................             Actuator.TimeNow = 0; 
0032E:  CLRF   xA4
00330:  CLRF   xA3
00332:  CLRF   xA2
00334:  CLRF   xA1
....................             output_bit(Relay,Actuator.OutputState); 
00336:  BTFSC  xA7.0
00338:  BRA    033E
0033A:  BCF    F8B.4
0033C:  BRA    0340
0033E:  BSF    F8B.4
00340:  BCF    F94.4
....................             Actuator.ActivateOutput = false; 
00342:  BCF    xA5.0
....................             Actuator.SaveValue = true;             
00344:  BSF    xA7.1
....................          } 
....................       } 
....................    }   
00346:  MOVLB  0
00348:  GOTO   0398 (RETURN)
.................... } 
....................  
.................... void Actuator_Set_Value(unsigned int1 status) 
.................... { 
....................    Actuator.TimeNow = 0; 
*
01EEA:  MOVLB  2
01EEC:  CLRF   xA4
01EEE:  CLRF   xA3
01EF0:  CLRF   xA2
01EF2:  CLRF   xA1
....................    Actuator.ActivateOutput = true; 
01EF4:  BSF    xA5.0
....................    valueToPutInOutput = status; 
01EF6:  BCF    4D.2
01EF8:  MOVLB  6
01EFA:  BTFSC  xC5.0
01EFC:  BSF    4D.2
....................    return; 
01EFE:  MOVLB  0
01F00:  RETURN 0
.................... } 
....................  
....................  
.................... #include <MessageFromPC.c> 
.................... #define msjOK       1 
.................... #define chkFail     2 
.................... #define formatFail  3 
.................... #define free        255 
....................  
.................... #define PingRequest            0x00    //< 
.................... #define Pingresponse           0x01    //> 
....................  
.................... #define MsgFailACK             0x08    //> 
.................... #define MsgFailFormat          0x09    //> 
....................  
.................... #define TextMsg                0x10    //< 
.................... #define TextMsgFromServer      0x11    //> 
.................... #define TextMsgReceived        0x12    //> 
.................... #define TextMsgSent            0x13    //> 
.................... #define TextMsgDelivered       0x15    //> 
.................... #define TextMsgFailed          0x16    //> 
.................... #define TextMsgFromServerNotSupported      0x17    //> 
.................... #define TextMsgLimitReached    0x18    //> 
....................  
....................  
.................... #define ShowGoInfoError        0x29    //> 
.................... #define GetVehicleInfo         0x30    //< 
.................... #define ShowVehicleInfo        0x31    //> 
.................... #define GetIOXStatus           0x32    //< 
.................... #define ShowIOXstatus          0x33    //> 
.................... #define SendStatusData         0x34    //< 
.................... #define StatusDataReceived     0x35    //> 
.................... #define StatusDataSent         0x36    //> 
.................... #define SendCustomData         0x37    //< 
.................... #define CustomDataReceived     0x38    //> 
.................... #define CustomDataSent         0x39    //> 
.................... #define CustomDataLimitReached 0x40    //> 
.................... #define CommandNotAllowed      0x41    //> 
.................... #define StopWattingMIMEACK     0x42    //<  
.................... #define MIMEACKWattingStopped  0x43    //> 
.................... #define MIMEWattingACK         0x44    //> 
.................... #define StopWattingCSACK       0x45    //< 
.................... #define CSACKWattingStopped    0x46    //> 
.................... #define CSWattingACK           0x47    //> 
.................... #define GetIgnitionstatus      0x48    //> 
.................... #define ShowIgnitionStatus     0x49    //> 
....................  
.................... #define GetActuatorMode        0x50  //< 
.................... #define ShowActuatorMode       0x51  //> 
.................... #define SetTimedOutput         0x52  //< 
.................... #define SetOuputOnOff          0x53  //< 
.................... #define ShowTimedOutputReason  0x54  //> 
.................... #define ShowOutputReason       0x55  //> 
.................... #define CancelOutput           0x56  //< 
.................... #define CancelResult           0x57  //> 
.................... #define GetOutputStatus        0x58  //< 
.................... #define ShowOutputStatus       0x59  //> 
....................  
.................... #define ResetDBI            0x60   //< 
.................... #define ResetDBIByServer    0x61   //> 
.................... #define ResetDBIByClient    0x62   //> 
.................... #define ResetDBIByAutomatic 0x63   //> 
.................... #define DBIInitialized      0x64   //> 
.................... #define RqstFW              0x65   //< 
.................... #define AsnwFW              0x66   //> 
.................... #define RqstHW              0x67   //< 
.................... #define AsnwHW              0x68   //> 
.................... #define DBIGetSerie         0x69   //<> 
....................  
.................... #define InputGetStatus      0x70   //<  
.................... #define InputShowStatus     0x71   //> 
....................  
.................... #define LengthInvalid       0xFE   //> 
.................... #define ComandoUnidentified 0xFF   //> 
....................  
.................... unsigned int1 sentByPC = false; 
....................  
.................... unsigned int8 pc_CMD = 0; 
.................... unsigned int8 pc_Index  = 0; 
.................... unsigned int8 chkA = 0; 
.................... unsigned int8 chkB = 0; 
.................... unsigned int8 pc_result = free; 
.................... struct   
.................... { 
....................    unsigned int8 chkA; 
....................    unsigned int8 chkB; 
....................    unsigned int8 comando; 
....................    unsigned int8 longitud; 
....................    unsigned int8 Dato[200]; 
.................... }msgFromPC; 
....................  
.................... void set_BufferPC(unsigned int8 data); 
.................... void sendToPC(unsigned int8 Command, unsigned int8 length, unsigned int8 *Data); 
....................  
.................... void set_BufferPC(unsigned int8 data) 
.................... { 
....................    switch(pc_CMD) 
*
003E8:  MOVLB  2
003EA:  MOVF   xB4,W
003EC:  XORLW  00
003EE:  MOVLB  0
003F0:  BZ    0408
003F2:  XORLW  01
003F4:  BZ    0440
003F6:  XORLW  03
003F8:  BZ    046E
003FA:  XORLW  01
003FC:  BZ    0484
003FE:  XORLW  07
00400:  BZ    04B8
00402:  XORLW  01
00404:  BZ    04C4
00406:  BRA    04F4
....................    { 
....................       case 0: 
....................       { 
....................          if(data == 0x02) //Inicio de trama 
00408:  MOVLB  7
0040A:  MOVF   xDF,W
0040C:  SUBLW  02
0040E:  BNZ   0416
....................          { 
....................             pc_CMD++; 
00410:  MOVLB  2
00412:  INCF   xB4,F
00414:  MOVLB  7
....................          } 
....................          chkA = data; 
00416:  MOVFF  7DF,2B6
....................          chkB = data; 
0041A:  MOVFF  7DF,2B7
....................          msgFromPC.comando = 0; 
0041E:  MOVLB  2
00420:  CLRF   xBB
....................          msgFromPC.longitud = 0; 
00422:  CLRF   xBC
....................          memset(msgFromPC.Dato, 0xFF, 200); 
00424:  MOVLW  02
00426:  MOVWF  FEA
00428:  MOVLW  BD
0042A:  MOVWF  FE9
0042C:  SETF   00
0042E:  CLRF   02
00430:  MOVLW  C8
00432:  MOVWF  01
00434:  MOVLB  0
00436:  RCALL  03CE
....................          pc_Index = 0; 
00438:  MOVLB  2
0043A:  CLRF   xB5
....................          break;   
0043C:  BRA    04F8
0043E:  MOVLB  0
....................       } 
....................       case 1: 
....................       { 
....................          msgFromPC.comando = data; 
00440:  MOVFF  7DF,2BB
....................          pc_CMD++; 
00444:  MOVLB  2
00446:  INCF   xB4,F
....................          chkA = chkA + data; 
00448:  MOVLB  7
0044A:  MOVF   xDF,W
0044C:  MOVLB  2
0044E:  ADDWF  xB6,F
....................          chkB = chkA + chkB; 
00450:  MOVF   xB6,W
00452:  ADDWF  xB7,F
....................          memset(msgFromPC.Dato, 0xFF, 200); //esto lo hago aqui para no estar limpiando el buffer en cada byte de msj incompleto 
00454:  MOVLW  02
00456:  MOVWF  FEA
00458:  MOVLW  BD
0045A:  MOVWF  FE9
0045C:  SETF   00
0045E:  CLRF   02
00460:  MOVLW  C8
00462:  MOVWF  01
00464:  MOVLB  0
00466:  RCALL  03CE
....................          break;   
00468:  MOVLB  2
0046A:  BRA    04F8
0046C:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          msgFromPC.longitud = data; 
0046E:  MOVFF  7DF,2BC
....................          chkA = chkA + data; 
00472:  MOVLB  7
00474:  MOVF   xDF,W
00476:  MOVLB  2
00478:  ADDWF  xB6,F
....................          chkB = chkA + chkB; 
0047A:  MOVF   xB6,W
0047C:  ADDWF  xB7,F
....................          pc_CMD++; 
0047E:  INCF   xB4,F
....................          break;   
00480:  BRA    04F8
00482:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          if(pc_Index < msgFromPC.longitud) 
00484:  MOVLB  2
00486:  MOVF   xBC,W
00488:  SUBWF  xB5,W
0048A:  BC    04AE
....................          { 
....................             msgFromPC.Dato[pc_Index] = data; 
0048C:  CLRF   03
0048E:  MOVF   xB5,W
00490:  ADDLW  BD
00492:  MOVWF  FE9
00494:  MOVLW  02
00496:  ADDWFC 03,W
00498:  MOVWF  FEA
0049A:  MOVFF  7DF,FEF
....................             chkA = chkA + data; 
0049E:  MOVLB  7
004A0:  MOVF   xDF,W
004A2:  MOVLB  2
004A4:  ADDWF  xB6,F
....................             chkB = chkA + chkB; 
004A6:  MOVF   xB6,W
004A8:  ADDWF  xB7,F
....................             pc_Index++; 
004AA:  INCF   xB5,F
....................          } 
004AC:  BRA    04B4
....................          else 
....................          { 
....................             msgFromPC.chkA = data; 
004AE:  MOVFF  7DF,2B9
....................             pc_CMD++; 
004B2:  INCF   xB4,F
....................          } 
....................          break;   
004B4:  BRA    04F8
004B6:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          msgFromPC.chkB = data; 
004B8:  MOVFF  7DF,2BA
....................          pc_CMD++; 
004BC:  MOVLB  2
004BE:  INCF   xB4,F
....................          break;   
004C0:  BRA    04F8
004C2:  MOVLB  0
....................       } 
....................       case 5: 
....................       { 
....................          if(data == 0x03) //Final de trama 
004C4:  MOVLB  7
004C6:  MOVF   xDF,W
004C8:  SUBLW  03
004CA:  BNZ   04E8
....................          { 
....................             if(msgFromPC.chkA == chkA && msgFromPC.chkB == chkB) 
004CC:  MOVLB  2
004CE:  MOVF   xB6,W
004D0:  SUBWF  xB9,W
004D2:  BNZ   04E0
004D4:  MOVF   xB7,W
004D6:  SUBWF  xBA,W
004D8:  BNZ   04E0
....................             { 
....................                pc_result = msjOK; 
004DA:  MOVLW  01
004DC:  MOVWF  xB8
....................                //enviar formato ok 
....................             } 
004DE:  BRA    04E4
....................             else 
....................             { 
....................                pc_result = chkFail; 
004E0:  MOVLW  02
004E2:  MOVWF  xB8
....................                //enviar checksum fail 
....................             } 
....................          } 
004E4:  BRA    04EE
004E6:  MOVLB  7
....................          else 
....................          { 
....................             pc_result = formatFail; 
004E8:  MOVLW  03
004EA:  MOVLB  2
004EC:  MOVWF  xB8
....................             //enviar formato invalido 
....................          } 
....................          pc_CMD = 0; 
004EE:  CLRF   xB4
....................          break;   
004F0:  BRA    04F8
004F2:  MOVLB  0
....................       } 
....................       default: 
....................       { 
....................          pc_CMD = 0; 
004F4:  MOVLB  2
004F6:  CLRF   xB4
....................          break; 
....................       } 
....................        
....................    } 
004F8:  MOVLB  0
004FA:  GOTO   050E (RETURN)
.................... } 
....................  
.................... void sendToPC(unsigned int8 Command, unsigned int8 length, unsigned int8 *Data) 
*
017D0:  MOVLB  6
017D2:  CLRF   xD3
017D4:  MOVLB  7
017D6:  CLRF   xCE
.................... { 
....................    char aux[10]; 
....................    unsigned int8 auxSize = 0; 
....................    char datos[250]; 
....................    unsigned int8 index = 0; 
....................     
....................    datos[index++] = 0x02; 
017D8:  MOVF   xCE,W
017DA:  INCF   xCE,F
017DC:  CLRF   03
017DE:  ADDLW  D4
017E0:  MOVWF  FE9
017E2:  MOVLW  06
017E4:  ADDWFC 03,W
017E6:  MOVWF  FEA
017E8:  MOVLW  02
017EA:  MOVWF  FEF
....................    datos[index++] = 0x1F; 
017EC:  MOVF   xCE,W
017EE:  INCF   xCE,F
017F0:  CLRF   03
017F2:  ADDLW  D4
017F4:  MOVWF  FE9
017F6:  MOVLW  06
017F8:  ADDWFC 03,W
017FA:  MOVWF  FEA
017FC:  MOVLW  1F
017FE:  MOVWF  FEF
....................    auxSize = sprintf(aux, "%X", Command); 
01800:  MOVLW  06
01802:  MOVLB  3
01804:  MOVWF  x86
01806:  MOVLW  C9
01808:  MOVWF  x85
0180A:  MOVFF  6C5,7D9
0180E:  MOVLW  37
01810:  MOVLB  7
01812:  MOVWF  xDA
01814:  MOVLB  0
01816:  RCALL  16D8
01818:  MOVLW  C9
0181A:  MOVLB  3
0181C:  SUBWF  x85,W
0181E:  MOVLB  6
01820:  MOVWF  xD3
....................    for(unsigned int8 i = 0; i < auxSize; i++) 
01822:  MOVLB  7
01824:  CLRF   xCF
01826:  MOVLB  6
01828:  MOVF   xD3,W
0182A:  MOVLB  7
0182C:  SUBWF  xCF,W
0182E:  BC    1864
....................    { 
....................       datos[index++] = aux[i]; 
01830:  MOVF   xCE,W
01832:  INCF   xCE,F
01834:  CLRF   03
01836:  ADDLW  D4
01838:  MOVWF  01
0183A:  MOVLW  06
0183C:  ADDWFC 03,F
0183E:  MOVFF  03,7DA
01842:  CLRF   03
01844:  MOVF   xCF,W
01846:  ADDLW  C9
01848:  MOVWF  FE9
0184A:  MOVLW  06
0184C:  ADDWFC 03,W
0184E:  MOVWF  FEA
01850:  MOVFF  FEF,7DB
01854:  MOVFF  7DA,FEA
01858:  MOVFF  01,FE9
0185C:  MOVFF  7DB,FEF
01860:  INCF   xCF,F
01862:  BRA    1826
....................    } 
....................     
....................    datos[index++] = 0x1F; 
01864:  MOVF   xCE,W
01866:  INCF   xCE,F
01868:  CLRF   03
0186A:  ADDLW  D4
0186C:  MOVWF  FE9
0186E:  MOVLW  06
01870:  ADDWFC 03,W
01872:  MOVWF  FEA
01874:  MOVLW  1F
01876:  MOVWF  FEF
....................    auxSize = sprintf(aux, "%u", length); 
01878:  MOVLW  06
0187A:  MOVLB  3
0187C:  MOVWF  x86
0187E:  MOVLW  C9
01880:  MOVWF  x85
01882:  MOVFF  6C6,7D9
01886:  MOVLW  1B
01888:  MOVLB  7
0188A:  MOVWF  xDA
0188C:  MOVLB  0
0188E:  RCALL  174A
01890:  MOVLW  C9
01892:  MOVLB  3
01894:  SUBWF  x85,W
01896:  MOVLB  6
01898:  MOVWF  xD3
....................    for(unsigned int8 i = 0; i < auxSize; i++) 
0189A:  MOVLB  7
0189C:  CLRF   xD0
0189E:  MOVLB  6
018A0:  MOVF   xD3,W
018A2:  MOVLB  7
018A4:  SUBWF  xD0,W
018A6:  BC    18DC
....................    { 
....................       datos[index++] = aux[i]; 
018A8:  MOVF   xCE,W
018AA:  INCF   xCE,F
018AC:  CLRF   03
018AE:  ADDLW  D4
018B0:  MOVWF  01
018B2:  MOVLW  06
018B4:  ADDWFC 03,F
018B6:  MOVFF  03,7DA
018BA:  CLRF   03
018BC:  MOVF   xD0,W
018BE:  ADDLW  C9
018C0:  MOVWF  FE9
018C2:  MOVLW  06
018C4:  ADDWFC 03,W
018C6:  MOVWF  FEA
018C8:  MOVFF  FEF,7DB
018CC:  MOVFF  7DA,FEA
018D0:  MOVFF  01,FE9
018D4:  MOVFF  7DB,FEF
018D8:  INCF   xD0,F
018DA:  BRA    189E
....................    } 
....................     
....................    datos[index++] = 0x1F; 
018DC:  MOVF   xCE,W
018DE:  INCF   xCE,F
018E0:  CLRF   03
018E2:  ADDLW  D4
018E4:  MOVWF  FE9
018E6:  MOVLW  06
018E8:  ADDWFC 03,W
018EA:  MOVWF  FEA
018EC:  MOVLW  1F
018EE:  MOVWF  FEF
....................    for(unsigned int8 i = 0; i < length; i++) 
018F0:  CLRF   xD1
018F2:  MOVLB  6
018F4:  MOVF   xC6,W
018F6:  MOVLB  7
018F8:  SUBWF  xD1,W
018FA:  BC    1938
....................    { 
....................       datos[index++] = *Data++; 
018FC:  MOVF   xCE,W
018FE:  INCF   xCE,F
01900:  CLRF   03
01902:  ADDLW  D4
01904:  MOVWF  01
01906:  MOVLW  06
01908:  ADDWFC 03,F
0190A:  MOVFF  03,7DA
0190E:  MOVLB  6
01910:  MOVFF  6C8,03
01914:  MOVF   xC7,W
01916:  INCF   xC7,F
01918:  BTFSC  FD8.2
0191A:  INCF   xC8,F
0191C:  MOVWF  FE9
0191E:  MOVFF  03,FEA
01922:  MOVFF  FEF,7DB
01926:  MOVLB  7
01928:  MOVFF  7DA,FEA
0192C:  MOVFF  01,FE9
01930:  MOVFF  7DB,FEF
01934:  INCF   xD1,F
01936:  BRA    18F2
....................    } 
....................    datos[index++] = 0x1F; 
01938:  MOVF   xCE,W
0193A:  INCF   xCE,F
0193C:  CLRF   03
0193E:  ADDLW  D4
01940:  MOVWF  FE9
01942:  MOVLW  06
01944:  ADDWFC 03,W
01946:  MOVWF  FEA
01948:  MOVLW  1F
0194A:  MOVWF  FEF
....................     
....................    unsigned int8 localchkA = 0; 
....................    unsigned int8 localchkB = 0; 
0194C:  CLRF   xD2
0194E:  CLRF   xD3
....................    for(unsigned int8 i = 0; i < index; i++) 
01950:  CLRF   xD4
01952:  MOVF   xCE,W
01954:  SUBWF  xD4,W
01956:  BC    197E
....................    {   
....................       unsigned int8 out = datos[i]; 
01958:  CLRF   03
0195A:  MOVF   xD4,W
0195C:  ADDLW  D4
0195E:  MOVWF  FE9
01960:  MOVLW  06
01962:  ADDWFC 03,W
01964:  MOVWF  FEA
01966:  MOVFF  FEF,7D5
....................       localchkA = localchkA + out; 
0196A:  MOVF   xD5,W
0196C:  ADDWF  xD2,F
....................       localchkB = localchkA + localchkB; 
0196E:  MOVF   xD2,W
01970:  ADDWF  xD3,F
....................       putc(out,Serial); 
01972:  MOVF   xD5,W
01974:  MOVLB  0
01976:  RCALL  17C6
01978:  MOVLB  7
0197A:  INCF   xD4,F
0197C:  BRA    1952
....................    } 
....................     
....................    unsigned int16 checksum = make16(localchkA,localchkB); 
0197E:  MOVFF  7D2,7D7
01982:  MOVFF  7D3,7D6
....................    auxSize = sprintf(aux, "%LX", checksum); 
01986:  MOVLW  06
01988:  MOVLB  3
0198A:  MOVWF  x86
0198C:  MOVLW  C9
0198E:  MOVWF  x85
01990:  MOVFF  7D7,7D9
01994:  MOVLW  37
01996:  MOVLB  7
01998:  MOVWF  xDA
0199A:  MOVLB  0
0199C:  RCALL  16D8
0199E:  MOVFF  7D6,7D9
019A2:  MOVLW  37
019A4:  MOVLB  7
019A6:  MOVWF  xDA
019A8:  MOVLB  0
019AA:  RCALL  16D8
019AC:  MOVLW  C9
019AE:  MOVLB  3
019B0:  SUBWF  x85,W
019B2:  MOVLB  6
019B4:  MOVWF  xD3
....................    for(unsigned int8 i = 0; i < auxSize; i++) 
019B6:  MOVLB  7
019B8:  CLRF   xD8
019BA:  MOVLB  6
019BC:  MOVF   xD3,W
019BE:  MOVLB  7
019C0:  SUBWF  xD8,W
019C2:  BC    19E2
....................    { 
....................       putc(aux[i],Serial); 
019C4:  CLRF   03
019C6:  MOVF   xD8,W
019C8:  ADDLW  C9
019CA:  MOVWF  FE9
019CC:  MOVLW  06
019CE:  ADDWFC 03,W
019D0:  MOVWF  FEA
019D2:  MOVFF  FEF,7D9
019D6:  MOVF   xD9,W
019D8:  MOVLB  0
019DA:  RCALL  17C6
019DC:  MOVLB  7
019DE:  INCF   xD8,F
019E0:  BRA    19BA
....................    } 
....................    putc(0x1F,Serial); 
019E2:  MOVLW  1F
019E4:  MOVLB  0
019E6:  RCALL  17C6
....................    putc(0x03,Serial); 
019E8:  MOVLW  03
019EA:  RCALL  17C6
019EC:  RETURN 0
.................... } 
....................  
.................... #include <MessageFormServer.c> 
....................  
.................... #define MimeMsgFromServer        0xA1 //< 
.................... #define MimeMsgFromPC            0xA2 //> 
.................... #define MimeSetTimeOutBinary     0xA3 //< 
.................... #define MimeGetTimeOutBinary     0xA4 //<> 
.................... #define MimeSetTimeOutACKServer  0xA5 //< 
.................... #define MimeGetTimeOutACKServer  0xA6 //<> 
.................... #define MimeSetMaxMimes          0xA7 //< 
.................... #define MimeGetMaxMimes          0xA8 //<> 
.................... #define MimeSetEnableOut         0xA9 //< 
.................... #define MimeGetEnableOut         0xAA //<> 
.................... #define MimeSetEnableIn          0xAB //< 
.................... #define MimeGetEnableIn          0xAC //<> 
.................... #define MimeSetMsgACKFromServer  0xAD //> 
.................... #define MimeGetMsgACKFromServer  0xAE //<> 
.................... #define MimeSetWaitACKFromServer 0xAF //< 
.................... #define MimeGetWaitACKFromServer 0xA0 //<> 
....................  
.................... #define CSSetTimeOut             0xB0 //< 
.................... #define CSGetTimeOut             0xB1 //<> 
.................... #define CSSetMaxCustoms          0xB2 //< 
.................... #define CSGatMaxCustoms          0xB3 //<> 
.................... #define CSSetAllowedCustoms      0xB4 //< 
.................... #define CSGetAllowedCustoms      0xB5 //<> 
.................... #define CSSetAllowedStatusData   0xB6 //< 
.................... #define CSGetAllowedStatusData   0xB7 //<> 
....................  
.................... #define ActSetMode               0xC0 //< 
.................... #define ActGetMode               0xC1 //<> 
.................... #define ActSetConfigTimedOutput  0xC2 //< 
.................... #define ActGetConfigTimedOutput  0xC3 //<> 
.................... #define ActSetTimeOutPass        0xC4 //< 
.................... #define ActGetTimeOutPass        0xC5 //<> 
.................... #define ActGetActualValue        0xC6 //<> 
.................... #define ActSetOutput             0xC7 //< 
.................... #define ActSettimedOutput        0xC8 //< 
.................... #define ActSetPass               0xC9 //<> 
.................... #define ActError                 0xCA //> 
.................... #define ActSetEnableClientRqst   0xCB //> 
.................... #define ActGetEnableClientRqst   0xCD //<> 
....................  
.................... #define DBISetTimeHeartBeat      0xD0 //< 
.................... #define DBIGetTimeHeartBeat      0xD1 //<> 
.................... #define DBISetEnableHeartBeat    0xD2 //> 
.................... #define DBIGetEnableHeartBeat    0xD3 //<> 
.................... #define DBIGetFwVersion          0xD4 //<> 
.................... #define DBIGetHwVersion          0xD5 //<> 
.................... #define DBIResetHardware         0xD6 //< 
.................... #define DBIForceToSentHearbeat   0xD7 //< 
.................... #define DBIGetAllInfo            0xD8 //<> 
.................... #define DBIGetDeviceSerie        0xD9 //<> 
....................  
.................... #define GoInfoSetRequestTime     0xE0 //< 
.................... #define GoInfoGetRequestTime     0xE1 //> 
.................... #define GoInfoSetEnableShow      0xE2 //< 
.................... #define GoInfoGetEnableShow      0xE3 //> 
.................... #define GoInfoSetEnableRqst      0xE4 //< 
.................... #define GoInfoGetEnableRqst      0xE5 //> 
....................  
.................... #define InputSetEnableShow       0x80 //< 
.................... #define InputGetEnableShow       0x81 //<> 
.................... #define InputSetEnableStatus     0x82 //< 
.................... #define InputGetEnableStatus     0x83 //<> 
.................... #define InputSetStatusDataId     0x84 //< 
.................... #define InputGetStatusDataId     0x85 //<> 
.................... #define InputSetTimeToSense      0x86 //< 
.................... #define InputGetTimeToSense      0x87 //<> 
....................  
.................... #define InputSetEnableSaveEeprom 0x90 //< 
.................... #define InputGetEnableSaveEeprom 0x91 //<> 
.................... #define InputSetValueToSave      0x92 //< 
.................... #define InputGetValueToSave      0x93 //<> 
.................... #define EepromSaveAll            0x94 //< 
.................... #define EepromAllSaved           0x95 //> 
.................... #define EepromBlockError         0x96 //> 
....................  
.................... #define ACK                      0xFB //> 
....................  
.................... unsigned int1 isFormatedMessage(unsigned int8 *dato); 
....................  
.................... unsigned int1 isFormatedMessage(unsigned int8 *dato) 
*
02124:  MOVLB  6
02126:  BCF    xC7.0
02128:  CLRF   xC8
0212A:  CLRF   xC9
0212C:  CLRF   xCA
0212E:  CLRF   xCB
02130:  MOVFF  6C6,03
02134:  MOVF   xC5,W
02136:  INCF   xC5,F
02138:  BTFSC  FD8.2
0213A:  INCF   xC6,F
0213C:  MOVWF  FE9
0213E:  MOVFF  03,FEA
02142:  MOVFF  FEF,6CC
02146:  MOVFF  6C6,03
0214A:  MOVF   xC5,W
0214C:  INCF   xC5,F
0214E:  BTFSC  FD8.2
02150:  INCF   xC6,F
02152:  MOVWF  FE9
02154:  MOVFF  03,FEA
02158:  MOVFF  FEF,6CD
.................... { 
....................    unsigned int1 result = false; 
....................    unsigned int8 cA = 0; 
....................    unsigned int8 cB = 0; 
....................    unsigned int8 ccA = 0; 
....................    unsigned int8 ccB = 0; 
....................    unsigned int8 comando = *dato++; 
....................    unsigned int8 lengh = *dato++; 
....................     
....................    ccA = ccA + comando; 
0215C:  MOVF   xCC,W
0215E:  ADDWF  xCA,F
....................    ccB = ccA + ccB; 
02160:  MOVF   xCA,W
02162:  ADDWF  xCB,F
....................    ccA = ccA + lengh; 
02164:  MOVF   xCD,W
02166:  ADDWF  xCA,F
....................    ccB = ccA + ccB; 
02168:  MOVF   xCA,W
0216A:  ADDWF  xCB,F
....................     
....................    if(lengh <= 200) 
0216C:  MOVF   xCD,W
0216E:  SUBLW  C8
02170:  BNC   21DE
....................    { 
....................       unsigned int8 dt; 
....................       for(unsigned int8 i = 0; i < lengh; i++) 
02172:  CLRF   xCF
02174:  MOVF   xCD,W
02176:  SUBWF  xCF,W
02178:  BC    219C
....................       { 
....................          dt = *dato++; 
0217A:  MOVFF  6C6,03
0217E:  MOVF   xC5,W
02180:  INCF   xC5,F
02182:  BTFSC  FD8.2
02184:  INCF   xC6,F
02186:  MOVWF  FE9
02188:  MOVFF  03,FEA
0218C:  MOVFF  FEF,6CE
....................          ccA = ccA + dt; 
02190:  MOVF   xCE,W
02192:  ADDWF  xCA,F
....................          ccB = ccA + ccB; 
02194:  MOVF   xCA,W
02196:  ADDWF  xCB,F
02198:  INCF   xCF,F
0219A:  BRA    2174
....................          //fprintf(Serial,"%X",dt); 
....................       } 
....................       dt = *dato++; 
0219C:  MOVFF  6C6,03
021A0:  MOVF   xC5,W
021A2:  INCF   xC5,F
021A4:  BTFSC  FD8.2
021A6:  INCF   xC6,F
021A8:  MOVWF  FE9
021AA:  MOVFF  03,FEA
021AE:  MOVFF  FEF,6CE
....................       cA = dt; 
021B2:  MOVFF  6CE,6C8
....................       //fprintf(Serial,"%X",dt); 
....................       dt = *dato++; 
021B6:  MOVFF  6C6,03
021BA:  MOVF   xC5,W
021BC:  INCF   xC5,F
021BE:  BTFSC  FD8.2
021C0:  INCF   xC6,F
021C2:  MOVWF  FE9
021C4:  MOVFF  03,FEA
021C8:  MOVFF  FEF,6CE
....................       cB = dt; 
021CC:  MOVFF  6CE,6C9
....................       //fprintf(Serial,"%X",dt); 
....................        
....................       if(cA == ccA && cB == ccB) 
021D0:  MOVF   xCA,W
021D2:  SUBWF  xC8,W
021D4:  BNZ   21DE
021D6:  MOVF   xCB,W
021D8:  SUBWF  xC9,W
021DA:  BNZ   21DE
....................       { 
....................          result = true; 
021DC:  BSF    xC7.0
....................       } 
....................    } 
....................     
....................    return result; 
021DE:  MOVLW  00
021E0:  BTFSC  xC7.0
021E2:  MOVLW  01
021E4:  MOVWF  01
021E6:  MOVLB  0
021E8:  GOTO   3F98 (RETURN)
.................... } 
....................  
.................... #include <Eeprom.c> 
....................  
.................... unsigned int1 EepromInit() 
.................... { 
....................    ValoresIniciales.ACTstatus     = false; 
*
012A2:  BCF    44.0
....................    ValoresIniciales.ACTmode       = ActuadorTemporizado; 
012A4:  MOVLW  05
012A6:  MOVWF  37
....................    ValoresIniciales.ACTtoReset    = 5000; 
012A8:  CLRF   3B
012AA:  CLRF   3A
012AC:  MOVLW  13
012AE:  MOVWF  39
012B0:  MOVLW  88
012B2:  MOVWF  38
....................    ValoresIniciales.ACTinReset    = 15000; 
012B4:  CLRF   3F
012B6:  CLRF   3E
012B8:  MOVLW  3A
012BA:  MOVWF  3D
012BC:  MOVLW  98
012BE:  MOVWF  3C
....................    ValoresIniciales.ACTtimeOutPIN = 60000; 
012C0:  CLRF   43
012C2:  CLRF   42
012C4:  MOVLW  EA
012C6:  MOVWF  41
012C8:  MOVLW  60
012CA:  MOVWF  40
....................    ValoresIniciales.ACTenableClientRequest = true; 
012CC:  BSF    44.1
....................     
....................    ValoresIniciales.DBItimeToHeartBeat  = 900000; 
012CE:  CLRF   48
012D0:  MOVLW  0D
012D2:  MOVWF  47
012D4:  MOVLW  BB
012D6:  MOVWF  46
012D8:  MOVLW  A0
012DA:  MOVWF  45
....................    ValoresIniciales.DBIheartBeatEnabled = true; 
012DC:  BSF    44.2
....................     
....................    ValoresIniciales.HOStimeToResquest  = 2000; 
012DE:  CLRF   36
012E0:  CLRF   35
012E2:  MOVLW  07
012E4:  MOVWF  34
012E6:  MOVLW  D0
012E8:  MOVWF  33
....................    ValoresIniciales.HOSrqstEnabled     = true; 
012EA:  BSF    2E.7
....................    ValoresIniciales.HOSautoShowEnabled = false; 
012EC:  BCF    2E.6
....................     
....................    ValoresIniciales.CSackByGo = 5000; 
012EE:  MOVLW  13
012F0:  MOVWF  30
012F2:  MOVLW  88
012F4:  MOVWF  2F
....................    ValoresIniciales.CSmax     = 200; 
012F6:  CLRF   32
012F8:  MOVLW  C8
012FA:  MOVWF  31
....................    ValoresIniciales.CScustomEnabled = true; 
012FC:  BSF    2E.4
....................    ValoresIniciales.CSstatusEnabled = true; 
012FE:  BSF    2E.5
....................     
....................    ValoresIniciales.MIMEackByGo     = 5000; 
01300:  MOVLW  13
01302:  MOVWF  27
01304:  MOVLW  88
01306:  MOVWF  26
....................    ValoresIniciales.MIMEackByServer = 60000; 
01308:  CLRF   2B
0130A:  CLRF   2A
0130C:  MOVLW  EA
0130E:  MOVWF  29
01310:  MOVLW  60
01312:  MOVWF  28
....................    ValoresIniciales.MIMEmax         = 2000; 
01314:  MOVLW  07
01316:  MOVWF  2D
01318:  MOVLW  D0
0131A:  MOVWF  2C
....................    ValoresIniciales.MIMEoutEnabled  = true; 
0131C:  BSF    2E.0
....................    ValoresIniciales.MIMEinEnabled   = true; 
0131E:  BSF    2E.1
....................    ValoresIniciales.MIMEWaitACKtoSend   = true; 
01320:  BSF    2E.2
....................    ValoresIniciales.MIMEautoResponseACK = false; 
01322:  BCF    2E.3
....................     
....................    ValoresIniciales.InputEnableShow        = true; 
01324:  BSF    44.3
....................    ValoresIniciales.InputEnablestatus      = true; 
01326:  BSF    44.4
....................    ValoresIniciales.InputEnableSaveEeprom  = true; 
01328:  BSF    44.5
....................    ValoresIniciales.InputTimeToSense       = 250; 
0132A:  CLRF   4C
0132C:  MOVLW  FA
0132E:  MOVWF  4B
....................    ValoresIniciales.InputStatusDataId      = 30091; 
01330:  MOVLW  75
01332:  MOVWF  4A
01334:  MOVLW  8B
01336:  MOVWF  49
....................    ValoresIniciales.InputValueToSave       = false; 
01338:  BCF    44.6
....................    ValoresIniciales.empty = 0; 
0133A:  BCF    44.7
....................     
....................    EepromInputValueToSave = ValoresIniciales.InputValueToSave; 
0133C:  BCF    4D.0
0133E:  BTFSC  44.6
01340:  BSF    4D.0
....................     
....................    unsigned int1 BlockResult = false; 
01342:  MOVLB  6
01344:  BCF    xC7.0
....................    do 
....................    { 
....................       BloqueEeprom++; 
01346:  INCF   4E,F
....................       if(EeepromleerBloque(BloqueEeprom,&ValoresIniciales)) 
01348:  MOVFF  4E,6C9
0134C:  CLRF   xCB
0134E:  MOVLW  26
01350:  MOVWF  xCA
01352:  MOVLB  0
01354:  BRA    1046
01356:  MOVF   01,F
01358:  BZ    1360
....................       { 
....................          BlockResult = true; 
0135A:  MOVLB  6
0135C:  BSF    xC7.0
....................          //fprintf(Serial,"Valid Value in: %u%c%c",BloqueEeprom,0x1f,0x03); 
....................       } 
0135E:  MOVLB  0
....................       else 
....................       { 
....................          //fprintf(Serial,"Invalid Value in: %u%c%c",BloqueEeprom,0x1f,0x03); 
....................       } 
....................        
....................    }while((BlockResult == false) && (BloqueEeprom < MaxBlocks)); 
01360:  MOVLB  6
01362:  BTFSC  xC7.0
01364:  BRA    136C
01366:  MOVF   4E,W
01368:  SUBLW  17
0136A:  BC    1346
....................     
....................    if(BloqueEeprom > 1) 
0136C:  MOVF   4E,W
0136E:  SUBLW  01
01370:  BC    142E
....................    {   
....................       for(unsigned int8 i = 1; i < (BloqueEeprom + 3); i++) 
01372:  MOVLW  01
01374:  MOVWF  xC8
01376:  MOVLW  03
01378:  ADDWF  4E,W
0137A:  SUBWF  xC8,W
0137C:  BC    142E
....................       { 
....................          if(i <= MaxBlocks) 
0137E:  MOVF   xC8,W
01380:  SUBLW  18
01382:  BNC   142A
....................          { 
....................             EepromEscribirBloque(i, ValoresIniciales); 
01384:  MOVFF  6C8,6ED
01388:  MOVFF  26,6EE
0138C:  MOVFF  27,6EF
01390:  MOVFF  28,6F0
01394:  MOVFF  29,6F1
01398:  MOVFF  2A,6F2
0139C:  MOVFF  2B,6F3
013A0:  MOVFF  2C,6F4
013A4:  MOVFF  2D,6F5
013A8:  MOVFF  2E,6F6
013AC:  MOVFF  2F,6F7
013B0:  MOVFF  30,6F8
013B4:  MOVFF  31,6F9
013B8:  MOVFF  32,6FA
013BC:  MOVFF  33,6FB
013C0:  MOVFF  34,6FC
013C4:  MOVFF  35,6FD
013C8:  MOVFF  36,6FE
013CC:  MOVFF  37,6FF
013D0:  MOVFF  38,700
013D4:  MOVFF  39,701
013D8:  MOVFF  3A,702
013DC:  MOVFF  3B,703
013E0:  MOVFF  3C,704
013E4:  MOVFF  3D,705
013E8:  MOVFF  3E,706
013EC:  MOVFF  3F,707
013F0:  MOVFF  40,708
013F4:  MOVFF  41,709
013F8:  MOVFF  42,70A
013FC:  MOVFF  43,70B
01400:  MOVFF  44,70C
01404:  MOVFF  45,70D
01408:  MOVFF  46,70E
0140C:  MOVFF  47,70F
01410:  MOVFF  48,710
01414:  MOVFF  49,711
01418:  MOVFF  4A,712
0141C:  MOVFF  4B,713
01420:  MOVFF  4C,714
01424:  MOVLB  0
01426:  RCALL  11CA
01428:  MOVLB  6
....................             //fprintf(Serial,"guardado en %u%c%c",i,0x1f,0x03); 
....................          } 
0142A:  INCF   xC8,F
0142C:  BRA    1376
....................       }       
....................    } 
....................     
....................    if(BlockResult == false) 
0142E:  BTFSC  xC7.0
01430:  BRA    1434
....................    { 
....................       BloqueEeprom = 255; 
01432:  SETF   4E
....................    } 
....................    EepromInputValueToSave = ValoresIniciales.InputValueToSave; 
01434:  BCF    4D.0
01436:  BTFSC  44.6
01438:  BSF    4D.0
....................    return BlockResult; 
0143A:  MOVLW  00
0143C:  BTFSC  xC7.0
0143E:  MOVLW  01
01440:  MOVWF  01
01442:  MOVLB  0
01444:  GOTO   14C4 (RETURN)
.................... } 
....................  
.................... void EepromSave(Variables Structura) 
.................... { 
....................    if(BloqueEeprom == 255) 
*
02552:  INCFSZ 4E,W
02554:  BRA    255A
....................    { 
....................       BloqueEeprom = 250; 
02556:  MOVLW  FA
02558:  MOVWF  4E
....................    } 
....................    for(unsigned int8 i = 1; i < (BloqueEeprom + 3); i++) 
0255A:  MOVLW  01
0255C:  MOVLB  6
0255E:  MOVWF  xEC
02560:  MOVLW  03
02562:  ADDWF  4E,W
02564:  SUBWF  xEC,W
02566:  BC    261A
....................    { 
....................       if(i <= MaxBlocks) 
02568:  MOVF   xEC,W
0256A:  SUBLW  18
0256C:  BNC   2616
....................       { 
....................          EepromEscribirBloque(i, Structura); 
0256E:  MOVFF  6EC,6ED
02572:  MOVFF  6C5,6EE
02576:  MOVFF  6C6,6EF
0257A:  MOVFF  6C7,6F0
0257E:  MOVFF  6C8,6F1
02582:  MOVFF  6C9,6F2
02586:  MOVFF  6CA,6F3
0258A:  MOVFF  6CB,6F4
0258E:  MOVFF  6CC,6F5
02592:  MOVFF  6CD,6F6
02596:  MOVFF  6CE,6F7
0259A:  MOVFF  6CF,6F8
0259E:  MOVFF  6D0,6F9
025A2:  MOVFF  6D1,6FA
025A6:  MOVFF  6D2,6FB
025AA:  MOVFF  6D3,6FC
025AE:  MOVFF  6D4,6FD
025B2:  MOVFF  6D5,6FE
025B6:  MOVFF  6D6,6FF
025BA:  MOVFF  6D7,700
025BE:  MOVFF  6D8,701
025C2:  MOVFF  6D9,702
025C6:  MOVFF  6DA,703
025CA:  MOVFF  6DB,704
025CE:  MOVFF  6DC,705
025D2:  MOVFF  6DD,706
025D6:  MOVFF  6DE,707
025DA:  MOVFF  6DF,708
025DE:  MOVFF  6E0,709
025E2:  MOVFF  6E1,70A
025E6:  MOVFF  6E2,70B
025EA:  MOVFF  6E3,70C
025EE:  MOVFF  6E4,70D
025F2:  MOVFF  6E5,70E
025F6:  MOVFF  6E6,70F
025FA:  MOVFF  6E7,710
025FE:  MOVFF  6E8,711
02602:  MOVFF  6E9,712
02606:  MOVFF  6EA,713
0260A:  MOVFF  6EB,714
0260E:  MOVLB  0
02610:  CALL   11CA
02614:  MOVLB  6
....................          //fprintf(Serial,"guardado en %u%c%c",i,0x1f,0x03); 
....................       } 
02616:  INCF   xEC,F
02618:  BRA    2560
....................    } 
....................    if(BloqueEeprom == 250) 
0261A:  MOVF   4E,W
0261C:  SUBLW  FA
0261E:  BNZ   2622
....................    { 
....................       BloqueEeprom = 255; 
02620:  SETF   4E
....................    } 
02622:  MOVLB  0
02624:  RETURN 0
.................... } 
....................  
.................... unsigned int1 CompareStructs(Variables StructA, Variables StructB) 
*
024F0:  MOVLB  7
024F2:  BCF    x13.0
024F4:  MOVLW  06
024F6:  MOVWF  x15
024F8:  MOVLW  C5
024FA:  MOVWF  x14
024FC:  MOVLW  06
024FE:  MOVWF  x17
02500:  MOVLW  EC
02502:  MOVWF  x16
.................... { 
....................    unsigned int1 result = false; 
....................    unsigned int8 *punteroA = &StructA; 
....................    unsigned int8 *punteroB = &StructB; 
....................    //unsigned int8 sizee = sizeof(Variables); 
....................    //fprintf(Serial,"Valores %u:  ",sizee); 
....................    for(unsigned int8 i = 0; i < sizeof(Variables); i++) 
02504:  CLRF   x18
02506:  MOVF   x18,W
02508:  SUBLW  26
0250A:  BNC   2546
....................    { 
....................        unsigned int8 nByteA = *punteroA++; 
....................        unsigned int8 nByteB = *punteroB++; 
0250C:  MOVFF  715,03
02510:  MOVF   x14,W
02512:  INCF   x14,F
02514:  BTFSC  FD8.2
02516:  INCF   x15,F
02518:  MOVWF  FE9
0251A:  MOVFF  03,FEA
0251E:  MOVFF  FEF,719
02522:  MOVFF  717,03
02526:  MOVF   x16,W
02528:  INCF   x16,F
0252A:  BTFSC  FD8.2
0252C:  INCF   x17,F
0252E:  MOVWF  FE9
02530:  MOVFF  03,FEA
02534:  MOVFF  FEF,71A
....................        //fprintf(Serial,"%X,%X ",nByteA,nByteB); 
....................        if(nByteA != nByteB) 
02538:  MOVF   x1A,W
0253A:  SUBWF  x19,W
0253C:  BZ    2540
....................        { 
....................           result = true; 
0253E:  BSF    x13.0
....................        } 
....................        restart_wdt(); 
02540:  CLRWDT
02542:  INCF   x18,F
02544:  BRA    2506
....................    } 
....................    //fprintf(Serial,"%c%c",0x1f,0x03);     
....................    return result; 
02546:  MOVLW  00
02548:  BTFSC  x13.0
0254A:  MOVLW  01
0254C:  MOVWF  01
0254E:  MOVLB  0
02550:  RETURN 0
.................... } 
....................  
.................... unsigned int1 EeepromleerBloque(unsigned int8 bloque, Variables *Structura) 
*
01046:  MOVLB  6
01048:  CLRF   xF4
0104A:  MOVLW  27
0104C:  MOVWF  xF3
0104E:  MOVLW  06
01050:  MOVWF  xF6
01052:  MOVLW  CC
01054:  MOVWF  xF5
01056:  BCF    xF7.0
01058:  CLRF   xF8
0105A:  CLRF   xF9
0105C:  MOVLW  01
0105E:  SUBWF  xC9,W
*
01064:  CLRF   x24
01066:  MOVWF  x23
01068:  MOVFF  6F4,726
0106C:  MOVFF  6F3,725
01070:  MOVLB  0
01072:  RCALL  0FF8
01074:  MOVFF  02,6FB
01078:  MOVFF  01,6FA
.................... { 
....................    Variables ValuesSaved; 
....................    unsigned int16 BlockSize = sizeof(Variables); 
....................    unsigned int8 *Puntero = &ValuesSaved; 
....................    unsigned int1 result = false; 
....................    unsigned int8 cA = 0, cB=0; 
....................    unsigned int16 startAddress = (bloque - 1) * BlockSize; 
....................    if(bloque > 1) 
0107C:  MOVLB  6
0107E:  MOVF   xC9,W
01080:  SUBLW  01
01082:  BC    10BC
....................    { 
....................       startAddress = ((bloque - 1) * BlockSize) + ((bloque - 1) * 2); 
01084:  MOVLW  01
01086:  SUBWF  xC9,W
01088:  MOVLB  7
0108A:  MOVWF  x01
0108C:  CLRF   x24
0108E:  MOVWF  x23
01090:  MOVFF  6F4,726
01094:  MOVFF  6F3,725
01098:  MOVLB  0
0109A:  RCALL  0FF8
0109C:  MOVLW  01
0109E:  MOVLB  6
010A0:  SUBWF  xC9,W
010A2:  MOVWF  00
010A4:  BCF    FD8.0
010A6:  RLCF   00,F
010A8:  MOVF   00,W
010AA:  MOVLB  7
010AC:  ADDWF  01,W
010AE:  MOVLB  6
010B0:  MOVWF  xFA
010B2:  MOVLW  00
010B4:  MOVLB  7
010B6:  ADDWFC 02,W
010B8:  MOVLB  6
010BA:  MOVWF  xFB
....................    } 
....................     
....................    //fprintf(Serial,"Bloque %u ",bloque); 
....................    for(unsigned int8 i = 0; i < BlockSize; i++) 
010BC:  CLRF   xFC
010BE:  MOVF   xF4,F
010C0:  BNZ   10C8
010C2:  MOVF   xF3,W
010C4:  SUBWF  xFC,W
010C6:  BC    110E
....................    { 
....................       unsigned int8 nByte = LeerEeprom(startAddress + i); 
010C8:  MOVF   xFC,W
010CA:  ADDWF  xFA,W
010CC:  MOVLB  7
010CE:  MOVWF  x00
010D0:  MOVLW  00
010D2:  MOVLB  6
010D4:  ADDWFC xFB,W
010D6:  MOVLB  7
010D8:  MOVWF  x01
010DA:  MOVWF  x03
010DC:  MOVFF  700,702
010E0:  MOVLB  0
010E2:  RCALL  101A
010E4:  MOVFF  01,6FD
....................       *Puntero = nByte; 
010E8:  MOVFF  6F6,03
010EC:  MOVLB  6
010EE:  MOVFF  6F5,FE9
010F2:  MOVFF  03,FEA
010F6:  MOVFF  6FD,FEF
....................       Puntero++; 
010FA:  INCF   xF5,F
010FC:  BTFSC  FD8.2
010FE:  INCF   xF6,F
....................       cA = cA + nByte; 
01100:  MOVF   xFD,W
01102:  ADDWF  xF8,F
....................       cB = cA + cB; 
01104:  MOVF   xF8,W
01106:  ADDWF  xF9,F
....................       restart_wdt(); 
01108:  CLRWDT
0110A:  INCF   xFC,F
0110C:  BRA    10BE
....................       //fprintf(Serial,"%X ",nByte); 
....................    } 
....................    unsigned int8 cAreal = LeerEeprom(startAddress + BlockSize); 
....................    unsigned int8 cBreal = LeerEeprom(startAddress + BlockSize + 1); 
0110E:  MOVF   xF3,W
01110:  ADDWF  xFA,W
01112:  MOVLB  7
01114:  MOVWF  x00
01116:  MOVLB  6
01118:  MOVF   xF4,W
0111A:  ADDWFC xFB,W
0111C:  MOVLB  7
0111E:  MOVWF  x01
01120:  MOVWF  x03
01122:  MOVFF  700,702
01126:  MOVLB  0
01128:  RCALL  101A
0112A:  MOVFF  01,6FE
0112E:  MOVLB  6
01130:  MOVF   xF3,W
01132:  ADDWF  xFA,W
01134:  MOVLB  7
01136:  MOVWF  x00
01138:  MOVLB  6
0113A:  MOVF   xF4,W
0113C:  ADDWFC xFB,W
0113E:  MOVLB  7
01140:  MOVWF  x01
01142:  MOVLW  01
01144:  ADDWF  x00,F
01146:  MOVLW  00
01148:  ADDWFC x01,F
0114A:  MOVFF  701,703
0114E:  MOVFF  700,702
01152:  MOVLB  0
01154:  RCALL  101A
01156:  MOVFF  01,6FF
....................    //fprintf(Serial," -%x%x- -%x%X-%c%c",cAreal,cBreal,cA,cB,0x1f,0x03); 
....................    if(cA == cAreal && cB == cBreal) 
0115A:  MOVLB  6
0115C:  MOVF   xFE,W
0115E:  SUBWF  xF8,W
01160:  BNZ   1186
01162:  MOVF   xFF,W
01164:  SUBWF  xF9,W
01166:  BNZ   1186
....................    { 
....................       //fprintf(Serial,"Checksum OK%c%c",0x1f,0x03); 
....................       memcpy(Structura, &ValuesSaved, sizeof(Variables)); 
01168:  MOVFF  6CB,FEA
0116C:  MOVFF  6CA,FE9
01170:  MOVLW  06
01172:  MOVWF  FE2
01174:  MOVLW  CC
01176:  MOVWF  FE1
01178:  MOVLW  27
0117A:  MOVWF  01
0117C:  MOVFF  FE6,FEE
01180:  DECFSZ 01,F
01182:  BRA    117C
....................       result = true; 
01184:  BSF    xF7.0
....................    } 
....................    return result; 
01186:  MOVLW  00
01188:  BTFSC  xF7.0
0118A:  MOVLW  01
0118C:  MOVWF  01
0118E:  MOVLB  0
01190:  GOTO   1356 (RETURN)
.................... } 
....................  
.................... void EepromEscribirBloque(unsigned int8 bloque, Variables Structura) 
*
011CA:  MOVLB  7
011CC:  CLRF   x16
011CE:  MOVLW  27
011D0:  MOVWF  x15
011D2:  CLRF   x17
011D4:  CLRF   x18
011D6:  CLRF   x1A
011D8:  CLRF   x19
.................... { 
....................    unsigned int16 BlockSize = sizeof(Variables); 
....................    unsigned int8 cA = 0, cB=0; 
....................    unsigned int16 startAddress = 0; 
....................    if(bloque > 1) 
011DA:  MOVLB  6
011DC:  MOVF   xED,W
011DE:  SUBLW  01
011E0:  BC    1216
....................    { 
....................       startAddress = ((bloque - 1) * BlockSize) + ((bloque - 1) * 2); 
011E2:  MOVLW  01
011E4:  SUBWF  xED,W
011E6:  MOVLB  7
011E8:  MOVWF  x22
011EA:  CLRF   x24
011EC:  MOVWF  x23
011EE:  MOVFF  716,726
011F2:  MOVFF  715,725
011F6:  MOVLB  0
011F8:  RCALL  0FF8
011FA:  MOVLW  01
011FC:  MOVLB  6
011FE:  SUBWF  xED,W
01200:  MOVWF  00
01202:  BCF    FD8.0
01204:  RLCF   00,F
01206:  MOVF   00,W
01208:  MOVLB  7
0120A:  ADDWF  01,W
0120C:  MOVWF  x19
0120E:  MOVLW  00
01210:  ADDWFC 02,W
01212:  MOVWF  x1A
01214:  MOVLB  6
....................    } 
....................     
....................    //fprintf(Serial,"Escribo en Bloque %u, direccion %lu ",bloque,startAddress); 
....................    unsigned int8 *puntero = &Structura; 
01216:  MOVLW  06
01218:  MOVLB  7
0121A:  MOVWF  x1C
0121C:  MOVLW  EE
0121E:  MOVWF  x1B
....................    for(unsigned int8 i = 0; i < BlockSize; i++) 
01220:  CLRF   x1D
01222:  MOVF   x16,F
01224:  BNZ   122C
01226:  MOVF   x15,W
01228:  SUBWF  x1D,W
0122A:  BC    126C
....................    { 
....................        unsigned int8 nByte = *puntero++; 
0122C:  MOVFF  71C,03
01230:  MOVF   x1B,W
01232:  INCF   x1B,F
01234:  BTFSC  FD8.2
01236:  INCF   x1C,F
01238:  MOVWF  FE9
0123A:  MOVFF  03,FEA
0123E:  MOVFF  FEF,71E
....................        EcribirEeprom((startAddress + i),nByte); 
01242:  MOVF   x1D,W
01244:  ADDWF  x19,W
01246:  MOVWF  x21
01248:  MOVLW  00
0124A:  ADDWFC x1A,W
0124C:  MOVWF  x22
0124E:  MOVWF  x24
01250:  MOVFF  721,723
01254:  MOVFF  71E,725
01258:  MOVLB  0
0125A:  RCALL  1194
....................        cA = cA + nByte; 
0125C:  MOVLB  7
0125E:  MOVF   x1E,W
01260:  ADDWF  x17,F
....................        cB = cA + cB; 
01262:  MOVF   x17,W
01264:  ADDWF  x18,F
....................        restart_wdt(); 
01266:  CLRWDT
01268:  INCF   x1D,F
0126A:  BRA    1222
....................    } 
....................    unsigned int16 addChk = startAddress + BlockSize; 
0126C:  MOVF   x15,W
0126E:  ADDWF  x19,W
01270:  MOVWF  x1F
01272:  MOVF   x16,W
01274:  ADDWFC x1A,W
01276:  MOVWF  x20
....................    EcribirEeprom(addChk,cA); 
01278:  MOVFF  720,724
0127C:  MOVFF  71F,723
01280:  MOVFF  717,725
01284:  MOVLB  0
01286:  RCALL  1194
....................    addChk++; 
01288:  MOVLB  7
0128A:  INCF   x1F,F
0128C:  BTFSC  FD8.2
0128E:  INCF   x20,F
....................    EcribirEeprom(addChk,cB); 
01290:  MOVFF  720,724
01294:  MOVFF  71F,723
01298:  MOVFF  718,725
0129C:  MOVLB  0
0129E:  RCALL  1194
....................    //fprintf(Serial,"Termino en %lu %c%c",addChk,0x1f,0x03); 
....................    return; 
012A0:  RETURN 0
.................... } 
....................  
.................... void EcribirEeprom(unsigned int16 add, unsigned int8 value) 
*
01194:  MOVLB  7
01196:  MOVFF  724,726
0119A:  MOVFF  723,727
.................... { 
....................    //write_eeprom (add, value);  
....................     
....................    unsigned int8 aH = (add >> 8) & 0xFF; 
....................    unsigned int8 aL = (add >> 0) & 0xFF; 
....................    #asm  
....................       MOVF aH,W ;  
0119E:  MOVF   x26,W
....................       MOVWF EEADRH ; //Upper bits of Data Memory Address to write 
011A0:  MOVWF  F75
....................       MOVF aL,W ;  
011A2:  MOVF   x27,W
....................       MOVWF EEADR ; //Lower bits of Data Memory Address to write 
011A4:  MOVWF  F74
....................       MOVF value,W ;  
011A6:  MOVF   x25,W
....................       MOVWF EEDATA ; //Data Memory Value to write 
011A8:  MOVWF  F73
....................       BCF EECON1, EEPGD; //Point to DATA memory 
011AA:  BCF    F7F.7
....................       BCF EECON1, CFGS ; //Access EEPROM 
011AC:  BCF    F7F.6
....................       BSF EECON1, WREN ; //Enable writes 
011AE:  BSF    F7F.2
....................          
....................       BCF INTCON, GIE ; //Disable Interrupts 
011B0:  BCF    FF2.7
....................       MOVLW 0x55 ; 
011B2:  MOVLW  55
....................       MOVWF EECON2 ; //Write 55h 
011B4:  MOVWF  F7E
....................       MOVLW 0xAA ; 
011B6:  MOVLW  AA
....................       MOVWF EECON2 ; //Write 0AAh 
011B8:  MOVWF  F7E
....................       BSF EECON1, WR ; //Set WR bit to begin write 
011BA:  BSF    F7F.1
....................       loop: 
....................       BTFSC EECON1, WR ; //Wait for write to complete  
011BC:  BTFSC  F7F.1
....................       goto loop; 
011BE:  BRA    11BC
....................       BSF INTCON, GIE ; //Enable Interrupts 
011C0:  BSF    FF2.7
....................       BCF EECON1, WREN ; //Disable writes on write complete (EEIF set) 
011C2:  BCF    F7F.2
011C4:  MOVLB  0
....................    #endasm 
....................    restart_wdt(); 
011C6:  CLRWDT
....................    return; 
011C8:  RETURN 0
.................... } 
....................  
.................... unsigned int8 LeerEeprom(unsigned int16 add) 
*
0101A:  MOVLB  7
0101C:  MOVFF  703,705
01020:  MOVFF  702,706
.................... { 
....................    unsigned int8 result; //= read_EEPROM(add); 
....................     
....................    unsigned int8 aH = (add >> 8) & 0xFF; 
....................    unsigned int8 aL = (add >> 0) & 0xFF; 
....................    #asm  
....................       MOVF aH,W ;  
01024:  MOVF   x05,W
....................       MOVWF EEADRH ; //Upper bits of Data Memory Address to write 
01026:  MOVWF  F75
....................       MOVF aL,W ;  
01028:  MOVF   x06,W
....................       MOVWF EEADR ; //Lower bits of Data Memory Address to write 
0102A:  MOVWF  F74
....................       BCF EECON1, EEPGD ; Point to DATA memory 
0102C:  BCF    F7F.7
....................       BCF EECON1, CFGS ; Access EEPROM 
0102E:  BCF    F7F.6
....................       BSF EECON1, RD ; EEPROM Read 
01030:  BSF    F7F.0
01032:  NOP   
....................       NOP 
....................       MOVFF EEDATA, result; 
01034:  MOVFF  F73,704
01038:  MOVLB  0
....................    #endasm 
....................    restart_wdt(); 
0103A:  CLRWDT
....................    return result; 
0103C:  MOVLB  7
0103E:  MOVFF  704,01
01042:  MOVLB  0
01044:  RETURN 0
.................... } 
....................  
.................... #include <EntradaDigital.c> 
.................... unsigned int1 InputEventDetected; 
.................... unsigned int1 InputStatus; 
.................... struct 
.................... { 
....................    unsigned int1  ActualSatus; 
....................    unsigned int1  LastStatus; 
....................    unsigned int16 TimeToSense; 
....................    unsigned int16 TimeNow; 
....................    unsigned int16 StatusDataID; 
....................     
.................... }EntradaDigital; 
....................  
.................... void InputInit(void); 
.................... void InputSetTime(void); 
....................  
.................... void InputInit() 
.................... { 
....................    EntradaDigital.ActualSatus = true; 
*
01672:  MOVLB  3
01674:  BSF    x87.0
....................    EntradaDigital.LastStatus  = true; 
01676:  BSF    x87.1
....................    EntradaDigital.TimeToSense = ValoresIniciales.InputTimeToSense; 
01678:  MOVFF  4C,389
0167C:  MOVFF  4B,388
....................    EntradaDigital.TimeNow     = 0; 
01680:  CLRF   x8B
01682:  CLRF   x8A
....................    EntradaDigital.StatusDataID = ValoresIniciales.InputStatusDataId; 
01684:  MOVFF  4A,38D
01688:  MOVFF  49,38C
....................     
....................    InputEventDetected = false; 
0168C:  BCF    4D.4
....................    InputStatus = true; 
0168E:  BSF    4D.5
01690:  MOVLB  0
01692:  GOTO   26F8 (RETURN)
.................... } 
....................  
.................... void InputSetTime() 
.................... { 
....................    EntradaDigital.ActualSatus = input(PIN_B0); 
*
0034C:  BSF    F93.0
0034E:  MOVLB  3
00350:  BCF    x87.0
00352:  BTFSC  F81.0
00354:  BSF    x87.0
....................    if(EntradaDigital.ActualSatus != EntradaDigital.LastStatus) 
00356:  CLRF   00
00358:  BTFSC  x87.1
0035A:  BSF    00.0
0035C:  MOVF   x87,W
0035E:  XORWF  00,W
00360:  ANDLW  01
00362:  BZ    036E
....................    { 
....................       EntradaDigital.TimeNow += interruptTime; 
00364:  MOVLW  05
00366:  ADDWF  x8A,F
00368:  MOVLW  00
0036A:  ADDWFC x8B,F
....................    } 
0036C:  BRA    0372
....................    else 
....................    { 
....................       EntradaDigital.TimeNow = 0; 
0036E:  CLRF   x8B
00370:  CLRF   x8A
....................    } 
....................     
....................    if(EntradaDigital.TimeNow >= EntradaDigital.TimeToSense) 
00372:  MOVF   x89,W
00374:  SUBWF  x8B,W
00376:  BNC   038E
00378:  BNZ   0380
0037A:  MOVF   x88,W
0037C:  SUBWF  x8A,W
0037E:  BNC   038E
....................    { 
....................       EntradaDigital.LastStatus = EntradaDigital.ActualSatus; 
00380:  BCF    x87.1
00382:  BTFSC  x87.0
00384:  BSF    x87.1
....................       InputStatus = EntradaDigital.ActualSatus; 
00386:  BCF    4D.5
00388:  BTFSC  x87.0
0038A:  BSF    4D.5
....................       InputEventDetected = true; 
0038C:  BSF    4D.4
....................    } 
0038E:  MOVLB  0
00390:  GOTO   039A (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... static unsigned int16 deviceType = 0x1000; 
....................  
.................... //Varialbles para mostrar mensaje en string 
.................... char cdmMessage[70]; 
.................... unsigned int8 cmdSize = 0; 
....................  
.................... char GoInfo[255]; 
.................... unsigned int8 GoInfoSize = 0; 
....................  
.................... unsigned int16 timeToShow = 5000; 
.................... unsigned int1  showDevice = true; 
....................  
.................... HOS_DeviceData GoDeviceInfo; 
....................  
.................... #int_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    //interrupcion cada 5 ms 
....................    HOS_Set_Time(); 
00394:  BRA    00C6
....................    Actuator_SetTime(); 
00396:  BRA    0210
....................    InputSetTime(); 
00398:  BRA    034C
....................     
....................    if(GoIOXstatus.synchronized == true && showDevice == true) 
0039A:  BTFSS  x63.0
0039C:  BRA    03AE
0039E:  BTFSS  4D.6
003A0:  BRA    03AE
....................    { 
....................       timeToShow -= interruptTime; 
003A2:  MOVLW  05
003A4:  MOVLB  4
003A6:  SUBWF  xD7,F
003A8:  MOVLW  00
003AA:  SUBWFB xD8,F
003AC:  MOVLB  0
....................    } 
.................... } 
....................  
003AE:  BCF    F9E.1
003B0:  GOTO   0078
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................    if(kbhit(Serial)) 
*
004FE:  BTFSS  F9E.5
00500:  BRA    050E
....................    { 
....................       unsigned int8 dato = getc(serial); 
00502:  BRA    03B4
00504:  MOVFF  01,7DE
....................       set_BufferPC(dato); 
00508:  MOVFF  7DE,7DF
0050C:  BRA    03E8
....................    } 
....................     
.................... } 
....................  
0050E:  BCF    F9E.5
00510:  GOTO   0078
.................... #int_RDA2 
.................... void  RDA2_isr(void)  
.................... { 
....................    if(kbhit(IOX)) 
*
00638:  BTFSS  FA4.5
0063A:  BRA    0648
....................    { 
....................       unsigned int8 dato = getc(IOX); 
0063C:  BRA    0514
0063E:  MOVFF  01,7DE
....................       HOS_Set_Buffer(dato); 
00642:  MOVFF  7DE,7DF
00646:  BRA    052E
....................    } 
00648:  BCF    FA4.5
0064A:  GOTO   0078
.................... } 
....................  
.................... Variables upDateVariables(); 
....................  
.................... void setup(void) 
.................... { 
....................    setup_timer_2(T2_DIV_BY_16,195,16);      //313 us overflow, 5.0 ms interrupt 
*
01448:  MOVLW  78
0144A:  IORLW  06
0144C:  MOVWF  FCA
0144E:  MOVLW  C3
01450:  MOVWF  FCB
....................    setup_comparator(NC_NC_NC_NC);           //This device COMP currently not supported by the PICWizard 
01452:  MOVLW  04
01454:  MOVLB  F
01456:  MOVWF  x5E
01458:  MOVWF  x5F
....................    enable_interrupts(INT_TIMER2); 
0145A:  BSF    F9D.1
....................    enable_interrupts(INT_RDA); 
0145C:  BSF    F9D.5
....................    enable_interrupts(INT_RDA2); 
0145E:  BSF    FA3.5
....................    enable_interrupts(GLOBAL); 
01460:  MOVLW  C0
01462:  IORWF  FF2,F
....................    setup_wdt(WDT_ON); 
01464:  BSF    FD1.0
....................     
....................    set_tris_c(0); 
01466:  MOVLW  00
01468:  MOVWF  F94
....................    set_tris_a(0); 
0146A:  MOVWF  F92
....................    output_low(led); 
0146C:  BCF    F92.0
0146E:  BCF    F89.0
....................    output_bit(Relay,0); 
01470:  BCF    F8B.4
01472:  BCF    F94.4
....................    for(unsigned int16 i = 0; i < 10; i++) 
01474:  MOVLB  6
01476:  CLRF   xC6
01478:  CLRF   xC5
0147A:  MOVF   xC6,F
0147C:  BNZ   14C0
0147E:  MOVF   xC5,W
01480:  SUBLW  09
01482:  BNC   14C0
....................    { 
....................       output_toggle(led); 
01484:  BCF    F92.0
01486:  BTG    F89.0
....................       delay_ms(25); 
01488:  MOVLW  19
0148A:  MOVWF  xC7
0148C:  MOVLB  0
0148E:  RCALL  0FC8
....................       restart_wdt(); 
01490:  CLRWDT
....................       delay_ms(25); 
01492:  MOVLW  19
01494:  MOVLB  6
01496:  MOVWF  xC7
01498:  MOVLB  0
0149A:  RCALL  0FC8
....................       restart_wdt(); 
0149C:  CLRWDT
....................       delay_ms(25); 
0149E:  MOVLW  19
014A0:  MOVLB  6
014A2:  MOVWF  xC7
014A4:  MOVLB  0
014A6:  RCALL  0FC8
....................       restart_wdt(); 
014A8:  CLRWDT
....................       delay_ms(25); 
014AA:  MOVLW  19
014AC:  MOVLB  6
014AE:  MOVWF  xC7
014B0:  MOVLB  0
014B2:  RCALL  0FC8
....................       restart_wdt(); 
014B4:  CLRWDT
014B6:  MOVLB  6
014B8:  INCF   xC5,F
014BA:  BTFSC  FD8.2
014BC:  INCF   xC6,F
014BE:  BRA    147A
....................    } 
....................     
....................    if(EepromInit() == false)  //regresa true si encontro valor valido, si no regresa false y los valores inicializados por default 
014C0:  MOVLB  0
014C2:  BRA    12A2
014C4:  MOVF   01,F
014C6:  BNZ   14C8
....................    { 
....................       //fprintf(Serial,"Eeprom Valida%c%c",0x1f,0x03); 
....................    } 
....................     
....................    AllowedFuntions.customData      = ValoresIniciales.CScustomEnabled; 
014C8:  BCF    20.0
014CA:  BTFSC  2E.4
014CC:  BSF    20.0
....................    AllowedFuntions.StatusData      = ValoresIniciales.CSstatusEnabled; 
014CE:  BCF    20.1
014D0:  BTFSC  2E.5
014D2:  BSF    20.1
....................    AllowedFuntions.MIMEin          = ValoresIniciales.MIMEinEnabled; 
014D4:  BCF    20.2
014D6:  BTFSC  2E.1
014D8:  BSF    20.2
....................    AllowedFuntions.MIMEout         = ValoresIniciales.MIMEoutEnabled; 
014DA:  BCF    20.3
014DC:  BTFSC  2E.0
014DE:  BSF    20.3
....................    AllowedFuntions.MimeACKResponse = ValoresIniciales.MIMEautoResponseACK; 
014E0:  BCF    20.4
014E2:  BTFSC  2E.3
014E4:  BSF    20.4
....................    AllowedFuntions.blockMIMEByACK  = ValoresIniciales.MIMEWaitACKtoSend; 
014E6:  BCF    21.0
014E8:  BTFSC  2E.2
014EA:  BSF    21.0
....................    AllowedFuntions.rqstGoInfo      = ValoresIniciales.HOSrqstEnabled; 
014EC:  BCF    20.5
014EE:  BTFSC  2E.7
014F0:  BSF    20.5
....................    AllowedFuntions.showGoInfo      = ValoresIniciales.HOSautoShowEnabled; 
014F2:  BCF    20.7
014F4:  BTFSC  2E.6
014F6:  BSF    20.7
....................    AllowedFuntions.rqstActuator    = ValoresIniciales.ACTenableClientRequest; 
014F8:  BCF    20.6
014FA:  BTFSC  44.1
014FC:  BSF    20.6
....................    AllowedFuntions.showInputstatus = ValoresIniciales.InputEnableShow; 
014FE:  BCF    21.1
01500:  BTFSC  44.3
01502:  BSF    21.1
....................    AllowedFuntions.sendInputstatus = ValoresIniciales.InputEnablestatus; 
01504:  BCF    21.2
01506:  BTFSC  44.4
01508:  BSF    21.2
....................    AllowedFuntions.saveEepromDueInput = ValoresIniciales.InputEnableSaveEeprom; 
0150A:  BCF    21.3
0150C:  BTFSC  44.5
0150E:  BSF    21.3
....................    GoDeviceInfo.Ignition = false;; 
01510:  MOVLB  4
01512:  BCF    xEC.1
01514:  MOVLB  0
01516:  GOTO   26EC (RETURN)
.................... } 
....................  
.................... void main() 
*
02626:  CLRF   FF8
02628:  BCF    FD0.7
0262A:  BSF    07.7
0262C:  CLRF   1F
0262E:  BSF    FA7.3
02630:  MOVLW  11
02632:  MOVWF  FAF
02634:  MOVLW  04
02636:  MOVWF  F7D
02638:  MOVLW  A6
0263A:  MOVWF  FAC
0263C:  MOVLW  90
0263E:  MOVWF  FAB
02640:  BSF    FB9.3
02642:  MOVLW  08
02644:  MOVWF  F7B
02646:  MOVLW  02
02648:  MOVWF  F7C
0264A:  MOVLW  A6
0264C:  MOVWF  FBA
0264E:  MOVLW  90
02650:  MOVWF  FA6
02652:  MOVLW  01
02654:  MOVWF  22
02656:  MOVWF  23
02658:  MOVWF  24
0265A:  CLRF   25
0265C:  CLRF   4E
0265E:  BCF    4D.1
02660:  CLRF   x91
02662:  CLRF   x92
02664:  CLRF   x93
02666:  MOVLB  1
02668:  CLRF   x8E
0266A:  CLRF   x8F
0266C:  CLRF   x90
0266E:  CLRF   x91
02670:  MOVLW  0A
02672:  MOVLB  2
02674:  MOVWF  x8C
02676:  CLRF   x97
02678:  BCF    4D.2
0267A:  BCF    4D.3
0267C:  CLRF   xB4
0267E:  CLRF   xB5
02680:  CLRF   xB6
02682:  CLRF   xB7
02684:  SETF   xB8
02686:  MOVLB  3
02688:  CLRF   x86
0268A:  CLRF   x85
0268C:  MOVLW  10
0268E:  MOVWF  x8F
02690:  CLRF   x8E
02692:  CLRF   xD6
02694:  MOVLB  4
02696:  CLRF   xD6
02698:  MOVLW  13
0269A:  MOVWF  xD8
0269C:  MOVLW  88
0269E:  MOVWF  xD7
026A0:  BSF    4D.6
026A2:  MOVLB  F
026A4:  MOVF   x5C,W
026A6:  ANDLW  80
026A8:  MOVWF  x5C
026AA:  MOVLW  00
026AC:  MOVWF  x5D
026AE:  BCF    FC1.3
026B0:  BCF    FC1.4
026B2:  BCF    FC1.5
026B4:  CLRF   x5E
026B6:  CLRF   x5F
026B8:  CLRF   19
026BA:  CLRF   1A
026BC:  MOVLW  74
026BE:  MOVLB  2
026C0:  MOVWF  x8D
026C2:  MOVLW  65
026C4:  MOVWF  x8E
026C6:  MOVLW  78
026C8:  MOVWF  x8F
026CA:  MOVLW  74
026CC:  MOVWF  x90
026CE:  MOVLW  2F
026D0:  MOVWF  x91
026D2:  MOVLW  70
026D4:  MOVWF  x92
026D6:  MOVLW  6C
026D8:  MOVWF  x93
026DA:  MOVLW  61
026DC:  MOVWF  x94
026DE:  MOVLW  69
026E0:  MOVWF  x95
026E2:  MOVLW  6E
026E4:  MOVWF  x96
.................... { 
....................    setup();    
026E6:  MOVLB  0
026E8:  GOTO   1448
....................    Actuator_Init(); 
026EC:  GOTO   151A
....................    HOS_Init(); 
026F0:  GOTO   15A8
....................    InputInit(); 
026F4:  GOTO   1672
....................     
....................    cmdSize = sprintf(cdmMessage, "The DBI is turned ON"); 
026F8:  MOVLW  03
026FA:  MOVLB  3
026FC:  MOVWF  x86
026FE:  MOVLW  90
02700:  MOVWF  x85
02702:  MOVLW  4E
02704:  MOVWF  FF6
02706:  MOVLW  06
02708:  MOVWF  FF7
0270A:  MOVLB  0
0270C:  CALL   16B8
02710:  MOVLW  90
02712:  MOVLB  3
02714:  SUBWF  x85,W
02716:  MOVWF  xD6
....................    sendToPC(DBIInitialized,cmdSize,&cdmMessage); 
02718:  MOVLW  64
0271A:  MOVLB  6
0271C:  MOVWF  xC5
0271E:  MOVFF  3D6,6C6
02722:  MOVLW  03
02724:  MOVWF  xC8
02726:  MOVLW  90
02728:  MOVWF  xC7
0272A:  MOVLB  0
0272C:  CALL   17D0
....................  
....................    while(true) 
....................    {       
....................       if(pc_result != free) 
02730:  MOVLB  2
02732:  INCFSZ xB8,W
02734:  BRA    273A
02736:  GOTO   3C24
....................       { 
....................          switch(pc_result) 
0273A:  MOVF   xB8,W
0273C:  XORLW  01
0273E:  MOVLB  0
02740:  BZ    2756
02742:  XORLW  03
02744:  BTFSC  FD8.2
02746:  GOTO   3BAC
0274A:  XORLW  01
0274C:  BTFSC  FD8.2
0274E:  GOTO   3BE6
02752:  GOTO   3C20
....................          { 
....................             case msjOK: 
....................             { 
....................                switch(msgFromPC.comando) 
02756:  MOVLB  2
02758:  MOVF   xBB,W
0275A:  XORLW  10
0275C:  MOVLB  0
0275E:  BZ    27EA
02760:  XORLW  27
02762:  BTFSC  FD8.2
02764:  BRA    2A0C
02766:  XORLW  03
02768:  BTFSC  FD8.2
0276A:  BRA    2C78
0276C:  XORLW  71
0276E:  BTFSC  FD8.2
02770:  BRA    2E32
02772:  XORLW  45
02774:  BTFSC  FD8.2
02776:  BRA    2E74
02778:  XORLW  30
0277A:  BTFSC  FD8.2
0277C:  BRA    2EB0
0277E:  XORLW  72
02780:  BTFSC  FD8.2
02782:  GOTO   3008
02786:  XORLW  12
02788:  BTFSC  FD8.2
0278A:  GOTO   304E
0278E:  XORLW  02
02790:  BTFSC  FD8.2
02792:  GOTO   3110
02796:  XORLW  01
02798:  BTFSC  FD8.2
0279A:  GOTO   354E
0279E:  XORLW  05
027A0:  BTFSC  FD8.2
027A2:  GOTO   36A8
027A6:  XORLW  0E
027A8:  BTFSC  FD8.2
027AA:  GOTO   3768
027AE:  XORLW  38
027B0:  BTFSC  FD8.2
027B2:  GOTO   37C4
027B6:  XORLW  52
027B8:  BTFSC  FD8.2
027BA:  GOTO   382A
027BE:  XORLW  57
027C0:  BTFSC  FD8.2
027C2:  GOTO   38A2
027C6:  XORLW  02
027C8:  BTFSC  FD8.2
027CA:  GOTO   390E
027CE:  XORLW  2F
027D0:  BTFSC  FD8.2
027D2:  GOTO   397A
027D6:  XORLW  38
027D8:  BTFSC  FD8.2
027DA:  GOTO   39DE
027DE:  XORLW  19
027E0:  BTFSC  FD8.2
027E2:  GOTO   3A76
027E6:  GOTO   3B74
....................                { 
....................                   case TextMsg: 
....................                   { 
....................                      if(AllowedFuntions.MIMEout == true) 
027EA:  BTFSS  20.3
027EC:  BRA    29D0
....................                      { 
....................                            if(GoIOXstatus.MIMESent < GoIOXstatus.maxMIMEs) 
027EE:  MOVF   57,W
027F0:  SUBWF  55,W
027F2:  BTFSS  FD8.0
027F4:  BRA    2916
027F6:  BNZ   2800
027F8:  MOVF   54,W
027FA:  SUBWF  56,W
027FC:  BTFSC  FD8.0
027FE:  BRA    2916
....................                            { 
....................                               if(GoIOXstatus.synchronized == true) 
02800:  BTFSS  x63.0
02802:  BRA    28DC
....................                               { 
....................                                  if(msgFromPC.Longitud > 200) 
02804:  MOVLB  2
02806:  MOVF   xBC,W
02808:  SUBLW  C8
0280A:  BC    2846
....................                                  { 
....................                                     cmdSize = sprintf(cdmMessage, "Data Length Not Allowed"); 
0280C:  MOVLW  03
0280E:  MOVLB  3
02810:  MOVWF  x86
02812:  MOVLW  90
02814:  MOVWF  x85
02816:  MOVLW  64
02818:  MOVWF  FF6
0281A:  MOVLW  06
0281C:  MOVWF  FF7
0281E:  MOVLB  0
02820:  CALL   16B8
02824:  MOVLW  90
02826:  MOVLB  3
02828:  SUBWF  x85,W
0282A:  MOVWF  xD6
....................                                     sendToPC(LengthInvalid,cmdSize,&cdmMessage); 
0282C:  MOVLW  FE
0282E:  MOVLB  6
02830:  MOVWF  xC5
02832:  MOVFF  3D6,6C6
02836:  MOVLW  03
02838:  MOVWF  xC8
0283A:  MOVLW  90
0283C:  MOVWF  xC7
0283E:  MOVLB  0
02840:  CALL   17D0
....................                                  } 
02844:  BRA    28DA
....................                                  else if(GoIOXstatus.WattingACKmimeFromServer == false || AllowedFuntions.blockMIMEByACK == false) 
02846:  MOVLB  0
02848:  BTFSS  x7D.1
0284A:  BRA    2850
0284C:  BTFSC  21.0
0284E:  BRA    28A2
....................                                  { 
....................                                     cmdSize = sprintf(cdmMessage, "MIME Message Received"); 
02850:  MOVLW  03
02852:  MOVLB  3
02854:  MOVWF  x86
02856:  MOVLW  90
02858:  MOVWF  x85
0285A:  MOVLW  7C
0285C:  MOVWF  FF6
0285E:  MOVLW  06
02860:  MOVWF  FF7
02862:  MOVLB  0
02864:  CALL   16B8
02868:  MOVLW  90
0286A:  MOVLB  3
0286C:  SUBWF  x85,W
0286E:  MOVWF  xD6
....................                                     sendToPC(TextMsgReceived,cmdSize,&cdmMessage);  
02870:  MOVLW  12
02872:  MOVLB  6
02874:  MOVWF  xC5
02876:  MOVFF  3D6,6C6
0287A:  MOVLW  03
0287C:  MOVWF  xC8
0287E:  MOVLW  90
02880:  MOVWF  xC7
02882:  MOVLB  0
02884:  CALL   17D0
....................                                     SentFormatMIMEPacket(MimeMsgFromPC, msgFromPC.Longitud, &msgFromPC.Dato); 
02888:  MOVLW  A2
0288A:  MOVLB  6
0288C:  MOVWF  xC5
0288E:  MOVFF  2BC,6C6
02892:  MOVLW  02
02894:  MOVWF  xC8
02896:  MOVLW  BD
02898:  MOVWF  xC7
0289A:  MOVLB  0
0289C:  CALL   1A92
....................                                  } 
028A0:  BRA    28DA
....................                                  else 
....................                                  { 
....................                                     cmdSize = sprintf(cdmMessage, "Waiting MIME ACK"); 
028A2:  MOVLW  03
028A4:  MOVLB  3
028A6:  MOVWF  x86
028A8:  MOVLW  90
028AA:  MOVWF  x85
028AC:  MOVLW  92
028AE:  MOVWF  FF6
028B0:  MOVLW  06
028B2:  MOVWF  FF7
028B4:  MOVLB  0
028B6:  CALL   16B8
028BA:  MOVLW  90
028BC:  MOVLB  3
028BE:  SUBWF  x85,W
028C0:  MOVWF  xD6
....................                                     sendToPC(MIMEWattingACK,cmdSize,&cdmMessage);  
028C2:  MOVLW  44
028C4:  MOVLB  6
028C6:  MOVWF  xC5
028C8:  MOVFF  3D6,6C6
028CC:  MOVLW  03
028CE:  MOVWF  xC8
028D0:  MOVLW  90
028D2:  MOVWF  xC7
028D4:  MOVLB  0
028D6:  CALL   17D0
....................                                  } 
....................                               } 
028DA:  BRA    2914
....................                               else 
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
028DC:  MOVLW  03
028DE:  MOVLB  3
028E0:  MOVWF  x86
028E2:  MOVLW  90
028E4:  MOVWF  x85
028E6:  MOVLW  A4
028E8:  MOVWF  FF6
028EA:  MOVLW  06
028EC:  MOVWF  FF7
028EE:  MOVLB  0
028F0:  CALL   16B8
028F4:  MOVLW  90
028F6:  MOVLB  3
028F8:  SUBWF  x85,W
028FA:  MOVWF  xD6
....................                                  sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
028FC:  MOVLW  33
028FE:  MOVLB  6
02900:  MOVWF  xC5
02902:  MOVFF  3D6,6C6
02906:  MOVLW  03
02908:  MOVWF  xC8
0290A:  MOVLW  90
0290C:  MOVWF  xC7
0290E:  MOVLB  0
02910:  CALL   17D0
....................                               }    
....................                            } 
02914:  BRA    29CE
....................                            else 
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Wait %lu S To Send a Text Message Again",(600000-GoIOXstatus.MIMETime)/1000); 
02916:  MOVLW  C0
02918:  BSF    FD8.0
0291A:  SUBFWB 58,W
0291C:  MOVLB  6
0291E:  MOVWF  xC5
02920:  MOVLW  27
02922:  SUBFWB 59,W
02924:  MOVWF  xC6
02926:  MOVLW  09
02928:  SUBFWB 5A,W
0292A:  MOVWF  xC7
0292C:  MOVLW  00
0292E:  SUBFWB 5B,W
02930:  MOVWF  xC8
02932:  BCF    FD8.1
02934:  MOVWF  xDC
02936:  MOVFF  6C7,6DB
0293A:  MOVFF  6C6,6DA
0293E:  MOVFF  6C5,6D9
02942:  CLRF   xE0
02944:  CLRF   xDF
02946:  MOVLW  03
02948:  MOVWF  xDE
0294A:  MOVLW  E8
0294C:  MOVWF  xDD
0294E:  MOVLB  0
02950:  CALL   1C26
02954:  MOVFF  03,6C8
02958:  MOVFF  02,6C7
0295C:  MOVFF  01,6C6
02960:  MOVFF  00,6C5
02964:  MOVLW  03
02966:  MOVLB  3
02968:  MOVWF  x86
0296A:  MOVLW  90
0296C:  MOVWF  x85
0296E:  MOVLW  C0
02970:  MOVWF  FF6
02972:  MOVLW  06
02974:  MOVWF  FF7
02976:  MOVLW  05
02978:  MOVLB  6
0297A:  MOVWF  xCD
0297C:  MOVLB  0
0297E:  CALL   1CBA
02982:  MOVLW  41
02984:  MOVWF  FE9
02986:  MOVFF  6C8,6D0
0298A:  MOVFF  6C7,6CF
0298E:  MOVFF  6C6,6CE
02992:  MOVFF  6C5,6CD
02996:  CALL   1CE2
0299A:  MOVLW  C8
0299C:  MOVWF  FF6
0299E:  MOVLW  06
029A0:  MOVWF  FF7
029A2:  MOVLW  1F
029A4:  MOVLB  6
029A6:  MOVWF  xCD
029A8:  MOVLB  0
029AA:  CALL   1CBA
029AE:  MOVLW  90
029B0:  MOVLB  3
029B2:  SUBWF  x85,W
029B4:  MOVWF  xD6
....................                               sendToPC(TextMsgLimitReached,cmdSize,&cdmMessage); 
029B6:  MOVLW  18
029B8:  MOVLB  6
029BA:  MOVWF  xC5
029BC:  MOVFF  3D6,6C6
029C0:  MOVLW  03
029C2:  MOVWF  xC8
029C4:  MOVLW  90
029C6:  MOVWF  xC7
029C8:  MOVLB  0
029CA:  CALL   17D0
....................                            } 
....................                      } 
029CE:  BRA    2A08
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "MIME Message to Server Not Allowed"); 
029D0:  MOVLW  03
029D2:  MOVLB  3
029D4:  MOVWF  x86
029D6:  MOVLW  90
029D8:  MOVWF  x85
029DA:  MOVLW  E8
029DC:  MOVWF  FF6
029DE:  MOVLW  06
029E0:  MOVWF  FF7
029E2:  MOVLB  0
029E4:  CALL   16B8
029E8:  MOVLW  90
029EA:  MOVLB  3
029EC:  SUBWF  x85,W
029EE:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
029F0:  MOVLW  41
029F2:  MOVLB  6
029F4:  MOVWF  xC5
029F6:  MOVFF  3D6,6C6
029FA:  MOVLW  03
029FC:  MOVWF  xC8
029FE:  MOVLW  90
02A00:  MOVWF  xC7
02A02:  MOVLB  0
02A04:  CALL   17D0
....................                      } 
....................                      break; 
02A08:  GOTO   3BAA
....................                   } 
....................                   case SendCustomData: 
....................                   { 
....................                      if(AllowedFuntions.customData == true) 
02A0C:  BTFSS  20.0
02A0E:  BRA    2C3C
....................                      { 
....................                         if(GoIOXstatus.customsSent < GoIOXstatus.maxCustoms) 
02A10:  MOVF   x67,W
02A12:  SUBWF  x65,W
02A14:  BTFSS  FD8.0
02A16:  BRA    2B76
02A18:  BNZ   2A22
02A1A:  MOVF   x64,W
02A1C:  SUBWF  x66,W
02A1E:  BTFSC  FD8.0
02A20:  BRA    2B76
....................                         { 
....................                            if(msgFromPC.Longitud > 27) 
02A22:  MOVLB  2
02A24:  MOVF   xBC,W
02A26:  SUBLW  1B
02A28:  BC    2A64
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Data Length Not Allowed"); 
02A2A:  MOVLW  03
02A2C:  MOVLB  3
02A2E:  MOVWF  x86
02A30:  MOVLW  90
02A32:  MOVWF  x85
02A34:  MOVLW  0C
02A36:  MOVWF  FF6
02A38:  MOVLW  07
02A3A:  MOVWF  FF7
02A3C:  MOVLB  0
02A3E:  CALL   16B8
02A42:  MOVLW  90
02A44:  MOVLB  3
02A46:  SUBWF  x85,W
02A48:  MOVWF  xD6
....................                               sendToPC(LengthInvalid,cmdSize,&cdmMessage); 
02A4A:  MOVLW  FE
02A4C:  MOVLB  6
02A4E:  MOVWF  xC5
02A50:  MOVFF  3D6,6C6
02A54:  MOVLW  03
02A56:  MOVWF  xC8
02A58:  MOVLW  90
02A5A:  MOVWF  xC7
02A5C:  MOVLB  0
02A5E:  CALL   17D0
....................                            } 
02A62:  BRA    2B74
....................                            else if(GoIOXstatus.WattingACK == 0) 
02A64:  MOVLB  0
02A66:  MOVF   x60,F
02A68:  BNZ   2AF8
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Custom Data Received"); 
02A6A:  MOVLW  03
02A6C:  MOVLB  3
02A6E:  MOVWF  x86
02A70:  MOVLW  90
02A72:  MOVWF  x85
02A74:  MOVLW  24
02A76:  MOVWF  FF6
02A78:  MOVLW  07
02A7A:  MOVWF  FF7
02A7C:  MOVLB  0
02A7E:  CALL   16B8
02A82:  MOVLW  90
02A84:  MOVLB  3
02A86:  SUBWF  x85,W
02A88:  MOVWF  xD6
....................                               sendToPC(CustomDataReceived,cmdSize,&cdmMessage);  
02A8A:  MOVLW  38
02A8C:  MOVLB  6
02A8E:  MOVWF  xC5
02A90:  MOVFF  3D6,6C6
02A94:  MOVLW  03
02A96:  MOVWF  xC8
02A98:  MOVLW  90
02A9A:  MOVWF  xC7
02A9C:  MOVLB  0
02A9E:  CALL   17D0
....................                               if(GoIOXstatus.synchronized == true) 
02AA2:  BTFSS  x63.0
02AA4:  BRA    2ABE
....................                               { 
....................                                  //enviamos  custom 
....................                                  SentFreeFormatThirdPartyData(msgFromPC.Longitud, &msgFromPC.Dato);  
02AA6:  MOVFF  2BC,6C5
02AAA:  MOVLW  02
02AAC:  MOVLB  6
02AAE:  MOVWF  xC7
02AB0:  MOVLW  BD
02AB2:  MOVWF  xC6
02AB4:  MOVLB  0
02AB6:  CALL   1DA0
....................                                  sentByPC = true; 
02ABA:  BSF    4D.3
....................                               } 
02ABC:  BRA    2AF6
....................                               else 
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
02ABE:  MOVLW  03
02AC0:  MOVLB  3
02AC2:  MOVWF  x86
02AC4:  MOVLW  90
02AC6:  MOVWF  x85
02AC8:  MOVLW  3A
02ACA:  MOVWF  FF6
02ACC:  MOVLW  07
02ACE:  MOVWF  FF7
02AD0:  MOVLB  0
02AD2:  CALL   16B8
02AD6:  MOVLW  90
02AD8:  MOVLB  3
02ADA:  SUBWF  x85,W
02ADC:  MOVWF  xD6
....................                                  sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
02ADE:  MOVLW  33
02AE0:  MOVLB  6
02AE2:  MOVWF  xC5
02AE4:  MOVFF  3D6,6C6
02AE8:  MOVLW  03
02AEA:  MOVWF  xC8
02AEC:  MOVLW  90
02AEE:  MOVWF  xC7
02AF0:  MOVLB  0
02AF2:  CALL   17D0
....................                               } 
....................                            } 
02AF6:  BRA    2B74
....................                            else if(GoIOXstatus.WattingACK == 1) 
02AF8:  DECFSZ x60,W
02AFA:  BRA    2B36
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Watting Custom Data ACK"); 
02AFC:  MOVLW  03
02AFE:  MOVLB  3
02B00:  MOVWF  x86
02B02:  MOVLW  90
02B04:  MOVWF  x85
02B06:  MOVLW  56
02B08:  MOVWF  FF6
02B0A:  MOVLW  07
02B0C:  MOVWF  FF7
02B0E:  MOVLB  0
02B10:  CALL   16B8
02B14:  MOVLW  90
02B16:  MOVLB  3
02B18:  SUBWF  x85,W
02B1A:  MOVWF  xD6
....................                               sendToPC(CSWattingACK,cmdSize,&cdmMessage);  
02B1C:  MOVLW  47
02B1E:  MOVLB  6
02B20:  MOVWF  xC5
02B22:  MOVFF  3D6,6C6
02B26:  MOVLW  03
02B28:  MOVWF  xC8
02B2A:  MOVLW  90
02B2C:  MOVWF  xC7
02B2E:  MOVLB  0
02B30:  CALL   17D0
....................                            } 
02B34:  BRA    2B74
....................                            else if(GoIOXstatus.WattingACK == 2) 
02B36:  MOVF   x60,W
02B38:  SUBLW  02
02B3A:  BNZ   2B74
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Watting Status Data ACK"); 
02B3C:  MOVLW  03
02B3E:  MOVLB  3
02B40:  MOVWF  x86
02B42:  MOVLW  90
02B44:  MOVWF  x85
02B46:  MOVLW  6E
02B48:  MOVWF  FF6
02B4A:  MOVLW  07
02B4C:  MOVWF  FF7
02B4E:  MOVLB  0
02B50:  CALL   16B8
02B54:  MOVLW  90
02B56:  MOVLB  3
02B58:  SUBWF  x85,W
02B5A:  MOVWF  xD6
....................                               sendToPC(CSWattingACK,cmdSize,&cdmMessage);  
02B5C:  MOVLW  47
02B5E:  MOVLB  6
02B60:  MOVWF  xC5
02B62:  MOVFF  3D6,6C6
02B66:  MOVLW  03
02B68:  MOVWF  xC8
02B6A:  MOVLW  90
02B6C:  MOVWF  xC7
02B6E:  MOVLB  0
02B70:  CALL   17D0
....................                            } 
....................                         } 
02B74:  BRA    2C3A
....................                         else 
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Wait %lu S To Send a Custom Data Again",(600000-GoIOXstatus.CustomsTime)/1000); 
02B76:  MOVLW  C0
02B78:  BSF    FD8.0
02B7A:  SUBFWB x68,W
02B7C:  MOVLB  6
02B7E:  MOVWF  xC5
02B80:  MOVLW  27
02B82:  MOVLB  0
02B84:  SUBFWB x69,W
02B86:  MOVLB  6
02B88:  MOVWF  xC6
02B8A:  MOVLW  09
02B8C:  MOVLB  0
02B8E:  SUBFWB x6A,W
02B90:  MOVLB  6
02B92:  MOVWF  xC7
02B94:  MOVLW  00
02B96:  MOVLB  0
02B98:  SUBFWB x6B,W
02B9A:  MOVLB  6
02B9C:  MOVWF  xC8
02B9E:  BCF    FD8.1
02BA0:  MOVWF  xDC
02BA2:  MOVFF  6C7,6DB
02BA6:  MOVFF  6C6,6DA
02BAA:  MOVFF  6C5,6D9
02BAE:  CLRF   xE0
02BB0:  CLRF   xDF
02BB2:  MOVLW  03
02BB4:  MOVWF  xDE
02BB6:  MOVLW  E8
02BB8:  MOVWF  xDD
02BBA:  MOVLB  0
02BBC:  CALL   1C26
02BC0:  MOVFF  03,6C8
02BC4:  MOVFF  02,6C7
02BC8:  MOVFF  01,6C6
02BCC:  MOVFF  00,6C5
02BD0:  MOVLW  03
02BD2:  MOVLB  3
02BD4:  MOVWF  x86
02BD6:  MOVLW  90
02BD8:  MOVWF  x85
02BDA:  MOVLW  86
02BDC:  MOVWF  FF6
02BDE:  MOVLW  07
02BE0:  MOVWF  FF7
02BE2:  MOVLW  05
02BE4:  MOVLB  6
02BE6:  MOVWF  xCD
02BE8:  MOVLB  0
02BEA:  CALL   1CBA
02BEE:  MOVLW  41
02BF0:  MOVWF  FE9
02BF2:  MOVFF  6C8,6D0
02BF6:  MOVFF  6C7,6CF
02BFA:  MOVFF  6C6,6CE
02BFE:  MOVFF  6C5,6CD
02C02:  CALL   1CE2
02C06:  MOVLW  8E
02C08:  MOVWF  FF6
02C0A:  MOVLW  07
02C0C:  MOVWF  FF7
02C0E:  MOVLW  1E
02C10:  MOVLB  6
02C12:  MOVWF  xCD
02C14:  MOVLB  0
02C16:  CALL   1CBA
02C1A:  MOVLW  90
02C1C:  MOVLB  3
02C1E:  SUBWF  x85,W
02C20:  MOVWF  xD6
....................                            sendToPC(CustomDataLimitReached,cmdSize,&cdmMessage); 
02C22:  MOVLW  40
02C24:  MOVLB  6
02C26:  MOVWF  xC5
02C28:  MOVFF  3D6,6C6
02C2C:  MOVLW  03
02C2E:  MOVWF  xC8
02C30:  MOVLW  90
02C32:  MOVWF  xC7
02C34:  MOVLB  0
02C36:  CALL   17D0
....................                         } 
....................                      } 
02C3A:  BRA    2C74
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Custom Data Not Supported"); 
02C3C:  MOVLW  03
02C3E:  MOVLB  3
02C40:  MOVWF  x86
02C42:  MOVLW  90
02C44:  MOVWF  x85
02C46:  MOVLW  AE
02C48:  MOVWF  FF6
02C4A:  MOVLW  07
02C4C:  MOVWF  FF7
02C4E:  MOVLB  0
02C50:  CALL   16B8
02C54:  MOVLW  90
02C56:  MOVLB  3
02C58:  SUBWF  x85,W
02C5A:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
02C5C:  MOVLW  41
02C5E:  MOVLB  6
02C60:  MOVWF  xC5
02C62:  MOVFF  3D6,6C6
02C66:  MOVLW  03
02C68:  MOVWF  xC8
02C6A:  MOVLW  90
02C6C:  MOVWF  xC7
02C6E:  MOVLB  0
02C70:  CALL   17D0
....................                      } 
....................                      break; 
02C74:  GOTO   3BAA
....................                   } 
....................                   case SendStatusData: 
....................                   { 
....................                      if(AllowedFuntions.StatusData == true) 
02C78:  BTFSS  20.1
02C7A:  BRA    2DF6
....................                      { 
....................                         if(msgFromPC.Longitud != 6) 
02C7C:  MOVLB  2
02C7E:  MOVF   xBC,W
02C80:  SUBLW  06
02C82:  BZ    2CBE
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Data Length Not Allowed"); 
02C84:  MOVLW  03
02C86:  MOVLB  3
02C88:  MOVWF  x86
02C8A:  MOVLW  90
02C8C:  MOVWF  x85
02C8E:  MOVLW  C8
02C90:  MOVWF  FF6
02C92:  MOVLW  07
02C94:  MOVWF  FF7
02C96:  MOVLB  0
02C98:  CALL   16B8
02C9C:  MOVLW  90
02C9E:  MOVLB  3
02CA0:  SUBWF  x85,W
02CA2:  MOVWF  xD6
....................                            sendToPC(LengthInvalid,cmdSize,&cdmMessage); 
02CA4:  MOVLW  FE
02CA6:  MOVLB  6
02CA8:  MOVWF  xC5
02CAA:  MOVFF  3D6,6C6
02CAE:  MOVLW  03
02CB0:  MOVWF  xC8
02CB2:  MOVLW  90
02CB4:  MOVWF  xC7
02CB6:  MOVLB  0
02CB8:  CALL   17D0
....................                         } 
02CBC:  BRA    2DF4
....................                         else if(GoIOXstatus.WattingACK == 0) 
02CBE:  MOVLB  0
02CC0:  MOVF   x60,F
02CC2:  BNZ   2D78
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Status Data Received"); 
02CC4:  MOVLW  03
02CC6:  MOVLB  3
02CC8:  MOVWF  x86
02CCA:  MOVLW  90
02CCC:  MOVWF  x85
02CCE:  MOVLW  E0
02CD0:  MOVWF  FF6
02CD2:  MOVLW  07
02CD4:  MOVWF  FF7
02CD6:  MOVLB  0
02CD8:  CALL   16B8
02CDC:  MOVLW  90
02CDE:  MOVLB  3
02CE0:  SUBWF  x85,W
02CE2:  MOVWF  xD6
....................                            sendToPC(StatusDataReceived,cmdSize,&cdmMessage);  
02CE4:  MOVLW  35
02CE6:  MOVLB  6
02CE8:  MOVWF  xC5
02CEA:  MOVFF  3D6,6C6
02CEE:  MOVLW  03
02CF0:  MOVWF  xC8
02CF2:  MOVLW  90
02CF4:  MOVWF  xC7
02CF6:  MOVLB  0
02CF8:  CALL   17D0
....................                             
....................                            if(GoIOXstatus.synchronized == true) 
02CFC:  BTFSS  x63.0
02CFE:  BRA    2D3E
....................                            { 
....................                               unsigned int16 idStatus = make16(msgFromPC.Dato[0],msgFromPC.Dato[1]); 
....................                               unsigned int32 dataStatus = make32(msgFromPC.Dato[2],msgFromPC.Dato[3],msgFromPC.Dato[4],msgFromPC.Dato[5]); 
02D00:  MOVFF  2BD,502
02D04:  MOVFF  2BE,501
02D08:  MOVFF  2BF,506
02D0C:  MOVFF  2C0,505
02D10:  MOVFF  2C1,504
02D14:  MOVFF  2C2,503
....................                               SentThirdPartyDataStatusData(0,idStatus, dataStatus);  
02D18:  MOVLB  6
02D1A:  CLRF   xC5
02D1C:  MOVFF  502,6C7
02D20:  MOVFF  501,6C6
02D24:  MOVFF  506,6CB
02D28:  MOVFF  505,6CA
02D2C:  MOVFF  504,6C9
02D30:  MOVFF  503,6C8
02D34:  MOVLB  0
02D36:  CALL   1E20
....................                               sentByPC = true; 
02D3A:  BSF    4D.3
....................                            } 
02D3C:  BRA    2D76
....................                            else 
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
02D3E:  MOVLW  03
02D40:  MOVLB  3
02D42:  MOVWF  x86
02D44:  MOVLW  90
02D46:  MOVWF  x85
02D48:  MOVLW  F6
02D4A:  MOVWF  FF6
02D4C:  MOVLW  07
02D4E:  MOVWF  FF7
02D50:  MOVLB  0
02D52:  CALL   16B8
02D56:  MOVLW  90
02D58:  MOVLB  3
02D5A:  SUBWF  x85,W
02D5C:  MOVWF  xD6
....................                               sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
02D5E:  MOVLW  33
02D60:  MOVLB  6
02D62:  MOVWF  xC5
02D64:  MOVFF  3D6,6C6
02D68:  MOVLW  03
02D6A:  MOVWF  xC8
02D6C:  MOVLW  90
02D6E:  MOVWF  xC7
02D70:  MOVLB  0
02D72:  CALL   17D0
....................                            } 
....................                         } 
02D76:  BRA    2DF4
....................                         else if(GoIOXstatus.WattingACK == 1) 
02D78:  DECFSZ x60,W
02D7A:  BRA    2DB6
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Waiting Custom Data ACK"); 
02D7C:  MOVLW  03
02D7E:  MOVLB  3
02D80:  MOVWF  x86
02D82:  MOVLW  90
02D84:  MOVWF  x85
02D86:  MOVLW  12
02D88:  MOVWF  FF6
02D8A:  MOVLW  08
02D8C:  MOVWF  FF7
02D8E:  MOVLB  0
02D90:  CALL   16B8
02D94:  MOVLW  90
02D96:  MOVLB  3
02D98:  SUBWF  x85,W
02D9A:  MOVWF  xD6
....................                            sendToPC(CSWattingACK,cmdSize,&cdmMessage);  
02D9C:  MOVLW  47
02D9E:  MOVLB  6
02DA0:  MOVWF  xC5
02DA2:  MOVFF  3D6,6C6
02DA6:  MOVLW  03
02DA8:  MOVWF  xC8
02DAA:  MOVLW  90
02DAC:  MOVWF  xC7
02DAE:  MOVLB  0
02DB0:  CALL   17D0
....................                         } 
02DB4:  BRA    2DF4
....................                         else if(GoIOXstatus.WattingACK == 2) 
02DB6:  MOVF   x60,W
02DB8:  SUBLW  02
02DBA:  BNZ   2DF4
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Waiting Status Data ACK"); 
02DBC:  MOVLW  03
02DBE:  MOVLB  3
02DC0:  MOVWF  x86
02DC2:  MOVLW  90
02DC4:  MOVWF  x85
02DC6:  MOVLW  2A
02DC8:  MOVWF  FF6
02DCA:  MOVLW  08
02DCC:  MOVWF  FF7
02DCE:  MOVLB  0
02DD0:  CALL   16B8
02DD4:  MOVLW  90
02DD6:  MOVLB  3
02DD8:  SUBWF  x85,W
02DDA:  MOVWF  xD6
....................                            sendToPC(CSWattingACK,cmdSize,&cdmMessage);  
02DDC:  MOVLW  47
02DDE:  MOVLB  6
02DE0:  MOVWF  xC5
02DE2:  MOVFF  3D6,6C6
02DE6:  MOVLW  03
02DE8:  MOVWF  xC8
02DEA:  MOVLW  90
02DEC:  MOVWF  xC7
02DEE:  MOVLB  0
02DF0:  CALL   17D0
....................                         } 
....................                      } 
02DF4:  BRA    2E2E
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Status Data Not Supported"); 
02DF6:  MOVLW  03
02DF8:  MOVLB  3
02DFA:  MOVWF  x86
02DFC:  MOVLW  90
02DFE:  MOVWF  x85
02E00:  MOVLW  42
02E02:  MOVWF  FF6
02E04:  MOVLW  08
02E06:  MOVWF  FF7
02E08:  MOVLB  0
02E0A:  CALL   16B8
02E0E:  MOVLW  90
02E10:  MOVLB  3
02E12:  SUBWF  x85,W
02E14:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
02E16:  MOVLW  41
02E18:  MOVLB  6
02E1A:  MOVWF  xC5
02E1C:  MOVFF  3D6,6C6
02E20:  MOVLW  03
02E22:  MOVWF  xC8
02E24:  MOVLW  90
02E26:  MOVWF  xC7
02E28:  MOVLB  0
02E2A:  CALL   17D0
....................                      } 
....................                      break; 
02E2E:  GOTO   3BAA
....................                   } 
....................                   case StopWattingCSACK: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Waiting Custom and Status Data Cancelled"); 
02E32:  MOVLW  03
02E34:  MOVLB  3
02E36:  MOVWF  x86
02E38:  MOVLW  90
02E3A:  MOVWF  x85
02E3C:  MOVLW  5C
02E3E:  MOVWF  FF6
02E40:  MOVLW  08
02E42:  MOVWF  FF7
02E44:  MOVLB  0
02E46:  CALL   16B8
02E4A:  MOVLW  90
02E4C:  MOVLB  3
02E4E:  SUBWF  x85,W
02E50:  MOVWF  xD6
....................                      sendToPC(CSACKWattingStopped,cmdSize,&cdmMessage);  
02E52:  MOVLW  46
02E54:  MOVLB  6
02E56:  MOVWF  xC5
02E58:  MOVFF  3D6,6C6
02E5C:  MOVLW  03
02E5E:  MOVWF  xC8
02E60:  MOVLW  90
02E62:  MOVWF  xC7
02E64:  MOVLB  0
02E66:  CALL   17D0
....................                      GoIOXstatus.n_timeOutCustom = 0; 
02E6A:  CLRF   5F
02E6C:  CLRF   5E
....................                      GoIOXstatus.WattingACK = 0;  
02E6E:  CLRF   x60
....................                      break; 
02E70:  GOTO   3BAA
....................                   } 
....................                   case PingRequest: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Ping Ok"); 
02E74:  MOVLW  03
02E76:  MOVLB  3
02E78:  MOVWF  x86
02E7A:  MOVLW  90
02E7C:  MOVWF  x85
02E7E:  MOVLW  86
02E80:  MOVWF  FF6
02E82:  MOVLW  08
02E84:  MOVWF  FF7
02E86:  MOVLB  0
02E88:  CALL   16B8
02E8C:  MOVLW  90
02E8E:  MOVLB  3
02E90:  SUBWF  x85,W
02E92:  MOVWF  xD6
....................                      sendToPC(Pingresponse,cmdSize,&cdmMessage);  
02E94:  MOVLW  01
02E96:  MOVLB  6
02E98:  MOVWF  xC5
02E9A:  MOVFF  3D6,6C6
02E9E:  MOVLW  03
02EA0:  MOVWF  xC8
02EA2:  MOVLW  90
02EA4:  MOVWF  xC7
02EA6:  MOVLB  0
02EA8:  CALL   17D0
....................                      break; 
02EAC:  GOTO   3BAA
....................                   } 
....................                   case GetVehicleInfo: 
....................                   { 
....................                      if(AllowedFuntions.rqstGoInfo == true) 
02EB0:  BTFSS  20.5
02EB2:  BRA    2FCC
....................                      { 
....................                        if(GoIOXstatus.synchronized == true) 
02EB4:  BTFSS  x63.0
02EB6:  BRA    2F92
....................                         { 
....................                            if(GoInfoDataReady == true) 
02EB8:  BTFSS  4D.1
02EBA:  BRA    2F50
....................                            { 
....................                               GoInfoSize = 0; 
02EBC:  MOVLB  4
02EBE:  CLRF   xD6
....................                               for(int8 i= 0; i< GoInfo_Leng; i++) 
02EC0:  MOVLB  5
02EC2:  CLRF   x07
02EC4:  MOVLB  1
02EC6:  MOVF   x91,W
02EC8:  MOVLB  5
02ECA:  SUBWF  x07,W
02ECC:  BC    2F26
....................                               { 
....................                                  char cdmMessage[2]; 
....................                                  sprintf(cdmMessage, "%X",GoInfo_Data[i]); 
02ECE:  CLRF   03
02ED0:  MOVF   x07,W
02ED2:  ADDLW  92
02ED4:  MOVWF  FE9
02ED6:  MOVLW  01
02ED8:  ADDWFC 03,W
02EDA:  MOVWF  FEA
02EDC:  MOVFF  FEF,7D9
02EE0:  MOVLW  05
02EE2:  MOVLB  3
02EE4:  MOVWF  x86
02EE6:  MOVLW  08
02EE8:  MOVWF  x85
02EEA:  MOVLW  37
02EEC:  MOVLB  7
02EEE:  MOVWF  xDA
02EF0:  MOVLB  0
02EF2:  CALL   16D8
....................                                  GoInfo[GoInfoSize++] = cdmMessage[0]; 
02EF6:  MOVLB  4
02EF8:  MOVF   xD6,W
02EFA:  INCF   xD6,F
02EFC:  CLRF   03
02EFE:  ADDLW  D7
02F00:  MOVWF  FE9
02F02:  MOVLW  03
02F04:  ADDWFC 03,W
02F06:  MOVWF  FEA
02F08:  MOVFF  508,FEF
....................                                  GoInfo[GoInfoSize++] = cdmMessage[1]; 
02F0C:  MOVF   xD6,W
02F0E:  INCF   xD6,F
02F10:  CLRF   03
02F12:  ADDLW  D7
02F14:  MOVWF  FE9
02F16:  MOVLW  03
02F18:  ADDWFC 03,W
02F1A:  MOVWF  FEA
02F1C:  MOVFF  509,FEF
02F20:  MOVLB  5
02F22:  INCF   x07,F
02F24:  BRA    2EC4
....................                               } 
....................                               sendToPC(ShowVehicleInfo,GoInfoSize,&GoInfo); 
02F26:  MOVLW  31
02F28:  MOVLB  6
02F2A:  MOVWF  xC5
02F2C:  MOVFF  4D6,6C6
02F30:  MOVLW  03
02F32:  MOVWF  xC8
02F34:  MOVLW  D7
02F36:  MOVWF  xC7
02F38:  MOVLB  0
02F3A:  CALL   17D0
....................                               GoIOXstatus.n_TimetoRqstHOS = 0 ; 
02F3E:  CLRF   x73
02F40:  CLRF   x72
02F42:  CLRF   x71
02F44:  CLRF   x70
....................                               GoInfoDataReady = false; 
02F46:  BCF    4D.1
....................                               GoInfo_Leng = 0; 
02F48:  MOVLB  1
02F4A:  CLRF   x91
....................                            } 
02F4C:  BRA    2F8A
02F4E:  MOVLB  0
....................                            else 
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "No Go Info Data Available"); 
02F50:  MOVLW  03
02F52:  MOVLB  3
02F54:  MOVWF  x86
02F56:  MOVLW  90
02F58:  MOVWF  x85
02F5A:  MOVLW  8E
02F5C:  MOVWF  FF6
02F5E:  MOVLW  08
02F60:  MOVWF  FF7
02F62:  MOVLB  0
02F64:  CALL   16B8
02F68:  MOVLW  90
02F6A:  MOVLB  3
02F6C:  SUBWF  x85,W
02F6E:  MOVWF  xD6
....................                               sendToPC(ShowGoInfoError,cmdSize,&cdmMessage); 
02F70:  MOVLW  29
02F72:  MOVLB  6
02F74:  MOVWF  xC5
02F76:  MOVFF  3D6,6C6
02F7A:  MOVLW  03
02F7C:  MOVWF  xC8
02F7E:  MOVLW  90
02F80:  MOVWF  xC7
02F82:  MOVLB  0
02F84:  CALL   17D0
02F88:  MOVLB  1
....................                            } 
....................                            SentRequestDeviceDataMessage(); 
02F8A:  MOVLB  0
02F8C:  CALL   1EAE
....................                         } 
02F90:  BRA    2FCA
....................                         else 
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
02F92:  MOVLW  03
02F94:  MOVLB  3
02F96:  MOVWF  x86
02F98:  MOVLW  90
02F9A:  MOVWF  x85
02F9C:  MOVLW  A8
02F9E:  MOVWF  FF6
02FA0:  MOVLW  08
02FA2:  MOVWF  FF7
02FA4:  MOVLB  0
02FA6:  CALL   16B8
02FAA:  MOVLW  90
02FAC:  MOVLB  3
02FAE:  SUBWF  x85,W
02FB0:  MOVWF  xD6
....................                            sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
02FB2:  MOVLW  33
02FB4:  MOVLB  6
02FB6:  MOVWF  xC5
02FB8:  MOVFF  3D6,6C6
02FBC:  MOVLW  03
02FBE:  MOVWF  xC8
02FC0:  MOVLW  90
02FC2:  MOVWF  xC7
02FC4:  MOVLB  0
02FC6:  CALL   17D0
....................                         } 
....................                      } 
02FCA:  BRA    3004
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Go Info Request Not Supported"); 
02FCC:  MOVLW  03
02FCE:  MOVLB  3
02FD0:  MOVWF  x86
02FD2:  MOVLW  90
02FD4:  MOVWF  x85
02FD6:  MOVLW  C4
02FD8:  MOVWF  FF6
02FDA:  MOVLW  08
02FDC:  MOVWF  FF7
02FDE:  MOVLB  0
02FE0:  CALL   16B8
02FE4:  MOVLW  90
02FE6:  MOVLB  3
02FE8:  SUBWF  x85,W
02FEA:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
02FEC:  MOVLW  41
02FEE:  MOVLB  6
02FF0:  MOVWF  xC5
02FF2:  MOVFF  3D6,6C6
02FF6:  MOVLW  03
02FF8:  MOVWF  xC8
02FFA:  MOVLW  90
02FFC:  MOVWF  xC7
02FFE:  MOVLB  0
03000:  CALL   17D0
....................                      } 
....................                      break; 
03004:  GOTO   3BAA
....................                   } 
....................                   case StopWattingMIMEACK: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "MIME Waiting ACK From Server Cancelled"); 
03008:  MOVLW  03
0300A:  MOVLB  3
0300C:  MOVWF  x86
0300E:  MOVLW  90
03010:  MOVWF  x85
03012:  MOVLW  E2
03014:  MOVWF  FF6
03016:  MOVLW  08
03018:  MOVWF  FF7
0301A:  MOVLB  0
0301C:  CALL   16B8
03020:  MOVLW  90
03022:  MOVLB  3
03024:  SUBWF  x85,W
03026:  MOVWF  xD6
....................                      sendToPC(MIMEACKWattingStopped,cmdSize,&cdmMessage);  
03028:  MOVLW  43
0302A:  MOVLB  6
0302C:  MOVWF  xC5
0302E:  MOVFF  3D6,6C6
03032:  MOVLW  03
03034:  MOVWF  xC8
03036:  MOVLW  90
03038:  MOVWF  xC7
0303A:  MOVLB  0
0303C:  CALL   17D0
....................                      GoIOXstatus.n_timeOutACKFromServer = 0; 
03040:  CLRF   x85
03042:  CLRF   x84
03044:  CLRF   x83
03046:  CLRF   x82
....................                      GoIOXstatus.WattingACKmimeFromServer = false; 
03048:  BCF    x7D.1
....................                      break; 
0304A:  GOTO   3BAA
....................                   } 
....................                   case GetActuatorMode: 
....................                   { 
....................                      if(Actuator.OutputMode == ActuadorTemporizado) 
0304E:  MOVLB  2
03050:  MOVF   xA6,W
03052:  SUBLW  05
03054:  BNZ   3092
....................                      { 
....................                          cmdSize = sprintf(cdmMessage, "The Actuator is Configured as Timed Output"); 
03056:  MOVLW  03
03058:  MOVLB  3
0305A:  MOVWF  x86
0305C:  MOVLW  90
0305E:  MOVWF  x85
03060:  MOVLW  0A
03062:  MOVWF  FF6
03064:  MOVLW  09
03066:  MOVWF  FF7
03068:  MOVLB  0
0306A:  CALL   16B8
0306E:  MOVLW  90
03070:  MOVLB  3
03072:  SUBWF  x85,W
03074:  MOVWF  xD6
....................                          sendToPC(ShowActuatorMode,cmdSize,&cdmMessage);  
03076:  MOVLW  51
03078:  MOVLB  6
0307A:  MOVWF  xC5
0307C:  MOVFF  3D6,6C6
03080:  MOVLW  03
03082:  MOVWF  xC8
03084:  MOVLW  90
03086:  MOVWF  xC7
03088:  MOVLB  0
0308A:  CALL   17D0
....................                      } 
0308E:  BRA    310C
03090:  MOVLB  2
....................                      else if(Actuator.OutputMode == ActuadorONOFF) 
03092:  MOVF   xA6,W
03094:  SUBLW  03
03096:  BNZ   30D4
....................                      { 
....................                          cmdSize = sprintf(cdmMessage, "The Actuator is Configured as Output"); 
03098:  MOVLW  03
0309A:  MOVLB  3
0309C:  MOVWF  x86
0309E:  MOVLW  90
030A0:  MOVWF  x85
030A2:  MOVLW  36
030A4:  MOVWF  FF6
030A6:  MOVLW  09
030A8:  MOVWF  FF7
030AA:  MOVLB  0
030AC:  CALL   16B8
030B0:  MOVLW  90
030B2:  MOVLB  3
030B4:  SUBWF  x85,W
030B6:  MOVWF  xD6
....................                          sendToPC(ShowActuatorMode,cmdSize,&cdmMessage);  
030B8:  MOVLW  51
030BA:  MOVLB  6
030BC:  MOVWF  xC5
030BE:  MOVFF  3D6,6C6
030C2:  MOVLW  03
030C4:  MOVWF  xC8
030C6:  MOVLW  90
030C8:  MOVWF  xC7
030CA:  MOVLB  0
030CC:  CALL   17D0
....................                      } 
030D0:  BRA    310C
030D2:  MOVLB  2
....................                      else 
....................                      { 
....................                          cmdSize = sprintf(cdmMessage, "The Actuator is Not Configured"); 
030D4:  MOVLW  03
030D6:  MOVLB  3
030D8:  MOVWF  x86
030DA:  MOVLW  90
030DC:  MOVWF  x85
030DE:  MOVLW  5C
030E0:  MOVWF  FF6
030E2:  MOVLW  09
030E4:  MOVWF  FF7
030E6:  MOVLB  0
030E8:  CALL   16B8
030EC:  MOVLW  90
030EE:  MOVLB  3
030F0:  SUBWF  x85,W
030F2:  MOVWF  xD6
....................                          sendToPC(ShowActuatorMode,cmdSize,&cdmMessage);  
030F4:  MOVLW  51
030F6:  MOVLB  6
030F8:  MOVWF  xC5
030FA:  MOVFF  3D6,6C6
030FE:  MOVLW  03
03100:  MOVWF  xC8
03102:  MOVLW  90
03104:  MOVWF  xC7
03106:  MOVLB  0
03108:  CALL   17D0
....................                      } 
....................                      break; 
0310C:  GOTO   3BAA
....................                   } 
....................                   case SetTimedOutput: 
....................                   { 
....................                      if(AllowedFuntions.rqstActuator == true) 
03110:  BTFSS  20.6
03112:  BRA    3514
....................                      { 
....................                         if(Actuator.OutputMode == ActuadorTemporizado) 
03114:  MOVLB  2
03116:  MOVF   xA6,W
03118:  SUBLW  05
0311A:  BTFSS  FD8.2
0311C:  BRA    34DA
....................                         { 
....................                            if(msgFromPC.Longitud == 8) 
0311E:  MOVF   xBC,W
03120:  SUBLW  08
03122:  BTFSS  FD8.2
03124:  BRA    3348
....................                            { 
....................                               unsigned int32 toReset = make32(msgFromPC.Dato[0],msgFromPC.Dato[1],msgFromPC.Dato[2],msgFromPC.Dato[3]); 
....................                               unsigned int32 inReset = make32(msgFromPC.Dato[4],msgFromPC.Dato[5],msgFromPC.Dato[6],msgFromPC.Dato[7]); 
03126:  MOVFF  2BD,50D
0312A:  MOVFF  2BE,50C
0312E:  MOVFF  2BF,50B
03132:  MOVFF  2C0,50A
03136:  MOVFF  2C1,511
0313A:  MOVFF  2C2,510
0313E:  MOVFF  2C3,50F
03142:  MOVFF  2C4,50E
....................                               if(Actuator.TimeToReset != toReset || Actuator.TimeInReset != inReset) 
03146:  MOVLB  5
03148:  MOVF   x0A,W
0314A:  MOVLB  2
0314C:  SUBWF  x9D,W
0314E:  BNZ   3196
03150:  MOVLB  5
03152:  MOVF   x0B,W
03154:  MOVLB  2
03156:  SUBWF  x9E,W
03158:  BNZ   3196
0315A:  MOVLB  5
0315C:  MOVF   x0C,W
0315E:  MOVLB  2
03160:  SUBWF  x9F,W
03162:  BNZ   3196
03164:  MOVLB  5
03166:  MOVF   x0D,W
03168:  MOVLB  2
0316A:  SUBWF  xA0,W
0316C:  BNZ   3196
0316E:  MOVLB  5
03170:  MOVF   x0E,W
03172:  MOVLB  2
03174:  SUBWF  x99,W
03176:  BNZ   3196
03178:  MOVLB  5
0317A:  MOVF   x0F,W
0317C:  MOVLB  2
0317E:  SUBWF  x9A,W
03180:  BNZ   3196
03182:  MOVLB  5
03184:  MOVF   x10,W
03186:  MOVLB  2
03188:  SUBWF  x9B,W
0318A:  BNZ   3196
0318C:  MOVLB  5
0318E:  MOVF   x11,W
03190:  MOVLB  2
03192:  SUBWF  x9C,W
03194:  BZ    31B6
....................                               { 
....................                                  Actuator.TimeToReset = toReset; 
03196:  MOVFF  50D,2A0
0319A:  MOVFF  50C,29F
0319E:  MOVFF  50B,29E
031A2:  MOVFF  50A,29D
....................                                  Actuator.TimeInReset = inReset; 
031A6:  MOVFF  511,29C
031AA:  MOVFF  510,29B
031AE:  MOVFF  50F,29A
031B2:  MOVFF  50E,299
....................                                  //guardar valor en eeprom 
....................                               } 
....................                               cmdSize = sprintf(cdmMessage, "The Timed Actuator is Going to be Applied in %LU S During %LU S by PC", Actuator.TimeToReset/1000,Actuator.TimeInReset/1000); 
031B6:  BCF    FD8.1
031B8:  MOVFF  2A0,6DC
031BC:  MOVFF  29F,6DB
031C0:  MOVFF  29E,6DA
031C4:  MOVFF  29D,6D9
031C8:  MOVLB  6
031CA:  CLRF   xE0
031CC:  CLRF   xDF
031CE:  MOVLW  03
031D0:  MOVWF  xDE
031D2:  MOVLW  E8
031D4:  MOVWF  xDD
031D6:  MOVLB  0
031D8:  CALL   1C26
031DC:  MOVFF  03,6C8
031E0:  MOVFF  02,6C7
031E4:  MOVFF  01,6C6
031E8:  MOVFF  00,6C5
031EC:  BCF    FD8.1
031EE:  MOVFF  29C,6DC
031F2:  MOVFF  29B,6DB
031F6:  MOVFF  29A,6DA
031FA:  MOVFF  299,6D9
031FE:  MOVLB  6
03200:  CLRF   xE0
03202:  CLRF   xDF
03204:  MOVLW  03
03206:  MOVWF  xDE
03208:  MOVLW  E8
0320A:  MOVWF  xDD
0320C:  MOVLB  0
0320E:  CALL   1C26
03212:  MOVFF  03,6CC
03216:  MOVFF  02,6CB
0321A:  MOVFF  01,6CA
0321E:  MOVFF  00,6C9
03222:  MOVLW  03
03224:  MOVLB  3
03226:  MOVWF  x86
03228:  MOVLW  90
0322A:  MOVWF  x85
0322C:  MOVLW  7C
0322E:  MOVWF  FF6
03230:  MOVLW  09
03232:  MOVWF  FF7
03234:  MOVLW  2D
03236:  MOVLB  6
03238:  MOVWF  xCD
0323A:  MOVLB  0
0323C:  CALL   1CBA
03240:  MOVLW  41
03242:  MOVWF  FE9
03244:  MOVFF  6C8,6D0
03248:  MOVFF  6C7,6CF
0324C:  MOVFF  6C6,6CE
03250:  MOVFF  6C5,6CD
03254:  CALL   1CE2
03258:  MOVLW  AC
0325A:  MOVWF  FF6
0325C:  MOVLW  09
0325E:  MOVWF  FF7
03260:  MOVLW  0A
03262:  MOVLB  6
03264:  MOVWF  xCD
03266:  MOVLB  0
03268:  CALL   1CBA
0326C:  MOVLW  41
0326E:  MOVWF  FE9
03270:  MOVFF  6CC,6D0
03274:  MOVFF  6CB,6CF
03278:  MOVFF  6CA,6CE
0327C:  MOVFF  6C9,6CD
03280:  CALL   1CE2
03284:  MOVLW  B9
03286:  MOVWF  FF6
03288:  MOVLW  09
0328A:  MOVWF  FF7
0328C:  MOVLW  08
0328E:  MOVLB  6
03290:  MOVWF  xCD
03292:  MOVLB  0
03294:  CALL   1CBA
03298:  MOVLW  90
0329A:  MOVLB  3
0329C:  SUBWF  x85,W
0329E:  MOVWF  xD6
....................                               sendToPC(ShowTimedOutputReason,cmdSize,&cdmMessage);  
032A0:  MOVLW  54
032A2:  MOVLB  6
032A4:  MOVWF  xC5
032A6:  MOVFF  3D6,6C6
032AA:  MOVLW  03
032AC:  MOVWF  xC8
032AE:  MOVLW  90
032B0:  MOVWF  xC7
032B2:  MOVLB  0
032B4:  CALL   17D0
....................                               Actuator.ActivateTimedOutput = true; 
032B8:  MOVLB  2
032BA:  BSF    x98.0
....................                               if(GoIOXstatus.synchronized == true) 
032BC:  MOVLB  0
032BE:  BTFSS  x63.0
032C0:  BRA    3344
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "Act PC TO %Lu %Lu!",Actuator.TimeToReset,Actuator.TimeInReset); 
032C2:  MOVLW  03
032C4:  MOVLB  3
032C6:  MOVWF  x86
032C8:  MOVLW  90
032CA:  MOVWF  x85
032CC:  MOVLW  C2
032CE:  MOVWF  FF6
032D0:  MOVLW  09
032D2:  MOVWF  FF7
032D4:  MOVLW  0A
032D6:  MOVLB  6
032D8:  MOVWF  xCD
032DA:  MOVLB  0
032DC:  CALL   1CBA
032E0:  MOVLW  41
032E2:  MOVWF  FE9
032E4:  MOVFF  2A0,6D0
032E8:  MOVFF  29F,6CF
032EC:  MOVFF  29E,6CE
032F0:  MOVFF  29D,6CD
032F4:  CALL   1CE2
032F8:  MOVLW  20
032FA:  MOVLB  7
032FC:  MOVWF  xDB
032FE:  MOVLB  0
03300:  CALL   1696
03304:  MOVLW  41
03306:  MOVWF  FE9
03308:  MOVFF  29C,6D0
0330C:  MOVFF  29B,6CF
03310:  MOVFF  29A,6CE
03314:  MOVFF  299,6CD
03318:  CALL   1CE2
0331C:  MOVLW  21
0331E:  MOVLB  7
03320:  MOVWF  xDB
03322:  MOVLB  0
03324:  CALL   1696
03328:  MOVLW  90
0332A:  MOVLB  3
0332C:  SUBWF  x85,W
0332E:  MOVWF  xD6
....................                                  SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
03330:  MOVFF  3D6,6C5
03334:  MOVLW  03
03336:  MOVLB  6
03338:  MOVWF  xC7
0333A:  MOVLW  90
0333C:  MOVWF  xC6
0333E:  MOVLB  0
03340:  CALL   1DA0
....................                               } 
....................                            } 
03344:  BRA    34D6
03346:  MOVLB  2
....................                            else 
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "The Timed Actuator is Going to be Applied in %LU S During %LU S by PC", Actuator.TimeToReset/1000,Actuator.TimeInReset/1000); 
03348:  BCF    FD8.1
0334A:  MOVFF  2A0,6DC
0334E:  MOVFF  29F,6DB
03352:  MOVFF  29E,6DA
03356:  MOVFF  29D,6D9
0335A:  MOVLB  6
0335C:  CLRF   xE0
0335E:  CLRF   xDF
03360:  MOVLW  03
03362:  MOVWF  xDE
03364:  MOVLW  E8
03366:  MOVWF  xDD
03368:  MOVLB  0
0336A:  CALL   1C26
0336E:  MOVFF  03,6C8
03372:  MOVFF  02,6C7
03376:  MOVFF  01,6C6
0337A:  MOVFF  00,6C5
0337E:  BCF    FD8.1
03380:  MOVFF  29C,6DC
03384:  MOVFF  29B,6DB
03388:  MOVFF  29A,6DA
0338C:  MOVFF  299,6D9
03390:  MOVLB  6
03392:  CLRF   xE0
03394:  CLRF   xDF
03396:  MOVLW  03
03398:  MOVWF  xDE
0339A:  MOVLW  E8
0339C:  MOVWF  xDD
0339E:  MOVLB  0
033A0:  CALL   1C26
033A4:  MOVFF  03,6CC
033A8:  MOVFF  02,6CB
033AC:  MOVFF  01,6CA
033B0:  MOVFF  00,6C9
033B4:  MOVLW  03
033B6:  MOVLB  3
033B8:  MOVWF  x86
033BA:  MOVLW  90
033BC:  MOVWF  x85
033BE:  MOVLW  D6
033C0:  MOVWF  FF6
033C2:  MOVLW  09
033C4:  MOVWF  FF7
033C6:  MOVLW  2D
033C8:  MOVLB  6
033CA:  MOVWF  xCD
033CC:  MOVLB  0
033CE:  CALL   1CBA
033D2:  MOVLW  41
033D4:  MOVWF  FE9
033D6:  MOVFF  6C8,6D0
033DA:  MOVFF  6C7,6CF
033DE:  MOVFF  6C6,6CE
033E2:  MOVFF  6C5,6CD
033E6:  CALL   1CE2
033EA:  MOVLW  06
033EC:  MOVWF  FF6
033EE:  MOVLW  0A
033F0:  MOVWF  FF7
033F2:  MOVLW  0A
033F4:  MOVLB  6
033F6:  MOVWF  xCD
033F8:  MOVLB  0
033FA:  CALL   1CBA
033FE:  MOVLW  41
03400:  MOVWF  FE9
03402:  MOVFF  6CC,6D0
03406:  MOVFF  6CB,6CF
0340A:  MOVFF  6CA,6CE
0340E:  MOVFF  6C9,6CD
03412:  CALL   1CE2
03416:  MOVLW  13
03418:  MOVWF  FF6
0341A:  MOVLW  0A
0341C:  MOVWF  FF7
0341E:  MOVLW  08
03420:  MOVLB  6
03422:  MOVWF  xCD
03424:  MOVLB  0
03426:  CALL   1CBA
0342A:  MOVLW  90
0342C:  MOVLB  3
0342E:  SUBWF  x85,W
03430:  MOVWF  xD6
....................                               sendToPC(ShowTimedOutputReason,cmdSize,&cdmMessage);  
03432:  MOVLW  54
03434:  MOVLB  6
03436:  MOVWF  xC5
03438:  MOVFF  3D6,6C6
0343C:  MOVLW  03
0343E:  MOVWF  xC8
03440:  MOVLW  90
03442:  MOVWF  xC7
03444:  MOVLB  0
03446:  CALL   17D0
....................                               Actuator.ActivateTimedOutput = true; 
0344A:  MOVLB  2
0344C:  BSF    x98.0
....................                               if(GoIOXstatus.synchronized == true) 
0344E:  MOVLB  0
03450:  BTFSS  x63.0
03452:  BRA    34D6
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "Act PC TO %Lu %Lu!",Actuator.TimeToReset,Actuator.TimeInReset); 
03454:  MOVLW  03
03456:  MOVLB  3
03458:  MOVWF  x86
0345A:  MOVLW  90
0345C:  MOVWF  x85
0345E:  MOVLW  1C
03460:  MOVWF  FF6
03462:  MOVLW  0A
03464:  MOVWF  FF7
03466:  MOVLW  0A
03468:  MOVLB  6
0346A:  MOVWF  xCD
0346C:  MOVLB  0
0346E:  CALL   1CBA
03472:  MOVLW  41
03474:  MOVWF  FE9
03476:  MOVFF  2A0,6D0
0347A:  MOVFF  29F,6CF
0347E:  MOVFF  29E,6CE
03482:  MOVFF  29D,6CD
03486:  CALL   1CE2
0348A:  MOVLW  20
0348C:  MOVLB  7
0348E:  MOVWF  xDB
03490:  MOVLB  0
03492:  CALL   1696
03496:  MOVLW  41
03498:  MOVWF  FE9
0349A:  MOVFF  29C,6D0
0349E:  MOVFF  29B,6CF
034A2:  MOVFF  29A,6CE
034A6:  MOVFF  299,6CD
034AA:  CALL   1CE2
034AE:  MOVLW  21
034B0:  MOVLB  7
034B2:  MOVWF  xDB
034B4:  MOVLB  0
034B6:  CALL   1696
034BA:  MOVLW  90
034BC:  MOVLB  3
034BE:  SUBWF  x85,W
034C0:  MOVWF  xD6
....................                                  SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
034C2:  MOVFF  3D6,6C5
034C6:  MOVLW  03
034C8:  MOVLB  6
034CA:  MOVWF  xC7
034CC:  MOVLW  90
034CE:  MOVWF  xC6
034D0:  MOVLB  0
034D2:  CALL   1DA0
....................                               } 
....................                            } 
....................                         } 
034D6:  BRA    3512
034D8:  MOVLB  2
....................                         else 
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "The Actuator is Configured as Output"); 
034DA:  MOVLW  03
034DC:  MOVLB  3
034DE:  MOVWF  x86
034E0:  MOVLW  90
034E2:  MOVWF  x85
034E4:  MOVLW  30
034E6:  MOVWF  FF6
034E8:  MOVLW  0A
034EA:  MOVWF  FF7
034EC:  MOVLB  0
034EE:  CALL   16B8
034F2:  MOVLW  90
034F4:  MOVLB  3
034F6:  SUBWF  x85,W
034F8:  MOVWF  xD6
....................                            sendToPC(ShowActuatorMode,cmdSize,&cdmMessage);  
034FA:  MOVLW  51
034FC:  MOVLB  6
034FE:  MOVWF  xC5
03500:  MOVFF  3D6,6C6
03504:  MOVLW  03
03506:  MOVWF  xC8
03508:  MOVLW  90
0350A:  MOVWF  xC7
0350C:  MOVLB  0
0350E:  CALL   17D0
....................                         } 
....................                      } 
03512:  BRA    354C
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Local Timed Actuator Control Not Supported"); 
03514:  MOVLW  03
03516:  MOVLB  3
03518:  MOVWF  x86
0351A:  MOVLW  90
0351C:  MOVWF  x85
0351E:  MOVLW  56
03520:  MOVWF  FF6
03522:  MOVLW  0A
03524:  MOVWF  FF7
03526:  MOVLB  0
03528:  CALL   16B8
0352C:  MOVLW  90
0352E:  MOVLB  3
03530:  SUBWF  x85,W
03532:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
03534:  MOVLW  41
03536:  MOVLB  6
03538:  MOVWF  xC5
0353A:  MOVFF  3D6,6C6
0353E:  MOVLW  03
03540:  MOVWF  xC8
03542:  MOVLW  90
03544:  MOVWF  xC7
03546:  MOVLB  0
03548:  CALL   17D0
....................                      } 
....................                      break; 
0354C:  BRA    3BAA
....................                   } 
....................                   case SetOuputOnOff: 
....................                   { 
....................                      if(AllowedFuntions.rqstActuator == true) 
0354E:  BTFSS  20.6
03550:  BRA    366A
....................                      { 
....................                         if(Actuator.OutputMode == ActuadorONOFF) 
03552:  MOVLB  2
03554:  MOVF   xA6,W
03556:  SUBLW  03
03558:  BNZ   362C
....................                         { 
....................                            if(msgFromPC.Longitud == 1 && msgFromPC.Dato[0] < 2) 
0355A:  DECFSZ xBC,W
0355C:  BRA    362A
0355E:  MOVF   xBD,W
03560:  SUBLW  01
03562:  BNC   362A
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "Actuator Desired Status = %U by PC", msgFromPC.Dato[0]); 
03564:  MOVLW  03
03566:  MOVLB  3
03568:  MOVWF  x86
0356A:  MOVLW  90
0356C:  MOVWF  x85
0356E:  MOVLW  82
03570:  MOVWF  FF6
03572:  MOVLW  0A
03574:  MOVWF  FF7
03576:  MOVLW  1A
03578:  MOVLB  6
0357A:  MOVWF  xCD
0357C:  MOVLB  0
0357E:  CALL   1CBA
03582:  MOVFF  2BD,7D9
03586:  MOVLW  1B
03588:  MOVLB  7
0358A:  MOVWF  xDA
0358C:  MOVLB  0
0358E:  CALL   174A
03592:  MOVLW  9E
03594:  MOVWF  FF6
03596:  MOVLW  0A
03598:  MOVWF  FF7
0359A:  MOVLW  06
0359C:  MOVLB  6
0359E:  MOVWF  xCD
035A0:  MOVLB  0
035A2:  CALL   1CBA
035A6:  MOVLW  90
035A8:  MOVLB  3
035AA:  SUBWF  x85,W
035AC:  MOVWF  xD6
....................                               sendToPC(ShowOutputReason,cmdSize,&cdmMessage);  
035AE:  MOVLW  55
035B0:  MOVLB  6
035B2:  MOVWF  xC5
035B4:  MOVFF  3D6,6C6
035B8:  MOVLW  03
035BA:  MOVWF  xC8
035BC:  MOVLW  90
035BE:  MOVWF  xC7
035C0:  MOVLB  0
035C2:  CALL   17D0
....................                               Actuator_Set_Value(msgFromPC.Dato[0]); 
035C6:  MOVFF  2BD,6C5
035CA:  CALL   1EEA
....................                               if(GoIOXstatus.synchronized == true) 
035CE:  BTFSS  x63.0
035D0:  BRA    3628
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "Act PC O %u!",msgFromPC.Dato[0]); 
035D2:  MOVLW  03
035D4:  MOVLB  3
035D6:  MOVWF  x86
035D8:  MOVLW  90
035DA:  MOVWF  x85
035DC:  MOVLW  A6
035DE:  MOVWF  FF6
035E0:  MOVLW  0A
035E2:  MOVWF  FF7
035E4:  MOVLW  09
035E6:  MOVLB  6
035E8:  MOVWF  xCD
035EA:  MOVLB  0
035EC:  CALL   1CBA
035F0:  MOVFF  2BD,7D9
035F4:  MOVLW  1B
035F6:  MOVLB  7
035F8:  MOVWF  xDA
035FA:  MOVLB  0
035FC:  CALL   174A
03600:  MOVLW  21
03602:  MOVLB  7
03604:  MOVWF  xDB
03606:  MOVLB  0
03608:  CALL   1696
0360C:  MOVLW  90
0360E:  MOVLB  3
03610:  SUBWF  x85,W
03612:  MOVWF  xD6
....................                                  SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
03614:  MOVFF  3D6,6C5
03618:  MOVLW  03
0361A:  MOVLB  6
0361C:  MOVWF  xC7
0361E:  MOVLW  90
03620:  MOVWF  xC6
03622:  MOVLB  0
03624:  CALL   1DA0
03628:  MOVLB  2
....................                               } 
....................                            } 
....................                         } 
0362A:  BRA    3666
....................                         else 
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "The Actuator is Configured as Timed Output"); 
0362C:  MOVLW  03
0362E:  MOVLB  3
03630:  MOVWF  x86
03632:  MOVLW  90
03634:  MOVWF  x85
03636:  MOVLW  B4
03638:  MOVWF  FF6
0363A:  MOVLW  0A
0363C:  MOVWF  FF7
0363E:  MOVLB  0
03640:  CALL   16B8
03644:  MOVLW  90
03646:  MOVLB  3
03648:  SUBWF  x85,W
0364A:  MOVWF  xD6
....................                            sendToPC(ShowActuatorMode,cmdSize,&cdmMessage);  
0364C:  MOVLW  51
0364E:  MOVLB  6
03650:  MOVWF  xC5
03652:  MOVFF  3D6,6C6
03656:  MOVLW  03
03658:  MOVWF  xC8
0365A:  MOVLW  90
0365C:  MOVWF  xC7
0365E:  MOVLB  0
03660:  CALL   17D0
03664:  MOVLB  2
....................                         } 
....................                      } 
03666:  BRA    36A4
03668:  MOVLB  0
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Local Actuator Control Not Supported"); 
0366A:  MOVLW  03
0366C:  MOVLB  3
0366E:  MOVWF  x86
03670:  MOVLW  90
03672:  MOVWF  x85
03674:  MOVLW  E0
03676:  MOVWF  FF6
03678:  MOVLW  0A
0367A:  MOVWF  FF7
0367C:  MOVLB  0
0367E:  CALL   16B8
03682:  MOVLW  90
03684:  MOVLB  3
03686:  SUBWF  x85,W
03688:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
0368A:  MOVLW  41
0368C:  MOVLB  6
0368E:  MOVWF  xC5
03690:  MOVFF  3D6,6C6
03694:  MOVLW  03
03696:  MOVWF  xC8
03698:  MOVLW  90
0369A:  MOVWF  xC7
0369C:  MOVLB  0
0369E:  CALL   17D0
036A2:  MOVLB  2
....................                      } 
....................                      break; 
036A4:  MOVLB  0
036A6:  BRA    3BAA
....................                   } 
....................                   case CancelOutput: 
....................                   { 
....................                      if(Actuator.ActivateTimedOutput == true || Actuator.ActivateOutput == true) 
036A8:  MOVLB  2
036AA:  BTFSC  x98.0
036AC:  BRA    36B2
036AE:  BTFSS  xA5.0
036B0:  BRA    372E
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Actuator Request Cancelled"); 
036B2:  MOVLW  03
036B4:  MOVLB  3
036B6:  MOVWF  x86
036B8:  MOVLW  90
036BA:  MOVWF  x85
036BC:  MOVLW  06
036BE:  MOVWF  FF6
036C0:  MOVLW  0B
036C2:  MOVWF  FF7
036C4:  MOVLB  0
036C6:  CALL   16B8
036CA:  MOVLW  90
036CC:  MOVLB  3
036CE:  SUBWF  x85,W
036D0:  MOVWF  xD6
....................                         sendToPC(CancelResult,cmdSize,&cdmMessage); 
036D2:  MOVLW  57
036D4:  MOVLB  6
036D6:  MOVWF  xC5
036D8:  MOVFF  3D6,6C6
036DC:  MOVLW  03
036DE:  MOVWF  xC8
036E0:  MOVLW  90
036E2:  MOVWF  xC7
036E4:  MOVLB  0
036E6:  CALL   17D0
....................                         Actuator.ActivateTimedOutput = false; 
036EA:  MOVLB  2
036EC:  BCF    x98.0
....................                         Actuator.ActivateOutput = false; 
036EE:  BCF    xA5.0
....................                         if(GoIOXstatus.synchronized == true) 
036F0:  MOVLB  0
036F2:  BTFSS  x63.0
036F4:  BRA    372A
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "Act PC Cancelled!"); 
036F6:  MOVLW  03
036F8:  MOVLB  3
036FA:  MOVWF  x86
036FC:  MOVLW  90
036FE:  MOVWF  x85
03700:  MOVLW  22
03702:  MOVWF  FF6
03704:  MOVLW  0B
03706:  MOVWF  FF7
03708:  MOVLB  0
0370A:  CALL   16B8
0370E:  MOVLW  90
03710:  MOVLB  3
03712:  SUBWF  x85,W
03714:  MOVWF  xD6
....................                            SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
03716:  MOVFF  3D6,6C5
0371A:  MOVLW  03
0371C:  MOVLB  6
0371E:  MOVWF  xC7
03720:  MOVLW  90
03722:  MOVWF  xC6
03724:  MOVLB  0
03726:  CALL   1DA0
....................                         } 
....................                      } 
0372A:  BRA    3766
0372C:  MOVLB  2
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Actuator Request Not Cancelled Due TimeOut"); 
0372E:  MOVLW  03
03730:  MOVLB  3
03732:  MOVWF  x86
03734:  MOVLW  90
03736:  MOVWF  x85
03738:  MOVLW  34
0373A:  MOVWF  FF6
0373C:  MOVLW  0B
0373E:  MOVWF  FF7
03740:  MOVLB  0
03742:  CALL   16B8
03746:  MOVLW  90
03748:  MOVLB  3
0374A:  SUBWF  x85,W
0374C:  MOVWF  xD6
....................                         sendToPC(CancelResult,cmdSize,&cdmMessage); 
0374E:  MOVLW  57
03750:  MOVLB  6
03752:  MOVWF  xC5
03754:  MOVFF  3D6,6C6
03758:  MOVLW  03
0375A:  MOVWF  xC8
0375C:  MOVLW  90
0375E:  MOVWF  xC7
03760:  MOVLB  0
03762:  CALL   17D0
....................                      } 
....................                       
....................                      break; 
03766:  BRA    3BAA
....................                   } 
....................                   case GetOutputStatus: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Actuator Value: %u",Actuator.OutputState); 
03768:  MOVLW  00
0376A:  MOVLB  2
0376C:  BTFSC  xA7.0
0376E:  MOVLW  01
03770:  MOVLB  6
03772:  MOVWF  xC5
03774:  MOVLW  03
03776:  MOVLB  3
03778:  MOVWF  x86
0377A:  MOVLW  90
0377C:  MOVWF  x85
0377E:  MOVLW  60
03780:  MOVWF  FF6
03782:  MOVLW  0B
03784:  MOVWF  FF7
03786:  MOVLW  10
03788:  MOVLB  6
0378A:  MOVWF  xCD
0378C:  MOVLB  0
0378E:  CALL   1CBA
03792:  MOVFF  6C5,7D9
03796:  MOVLW  1B
03798:  MOVLB  7
0379A:  MOVWF  xDA
0379C:  MOVLB  0
0379E:  CALL   174A
037A2:  MOVLW  90
037A4:  MOVLB  3
037A6:  SUBWF  x85,W
037A8:  MOVWF  xD6
....................                      sendToPC(ShowOutputStatus,cmdSize,&cdmMessage);  
037AA:  MOVLW  59
037AC:  MOVLB  6
037AE:  MOVWF  xC5
037B0:  MOVFF  3D6,6C6
037B4:  MOVLW  03
037B6:  MOVWF  xC8
037B8:  MOVLW  90
037BA:  MOVWF  xC7
037BC:  MOVLB  0
037BE:  CALL   17D0
....................                      break; 
037C2:  BRA    3BAA
....................                   } 
....................                   case ResetDBI: 
....................                   {                      
....................                      cmdSize = sprintf(cdmMessage, "DBI is going to be restarted in 2 seconds By PC"); 
037C4:  MOVLW  03
037C6:  MOVLB  3
037C8:  MOVWF  x86
037CA:  MOVLW  90
037CC:  MOVWF  x85
037CE:  MOVLW  74
037D0:  MOVWF  FF6
037D2:  MOVLW  0B
037D4:  MOVWF  FF7
037D6:  MOVLB  0
037D8:  CALL   16B8
037DC:  MOVLW  90
037DE:  MOVLB  3
037E0:  SUBWF  x85,W
037E2:  MOVWF  xD6
....................                      sendToPC(ResetDBIByClient,cmdSize,&cdmMessage);  
037E4:  MOVLW  62
037E6:  MOVLB  6
037E8:  MOVWF  xC5
037EA:  MOVFF  3D6,6C6
037EE:  MOVLW  03
037F0:  MOVWF  xC8
037F2:  MOVLW  90
037F4:  MOVWF  xC7
037F6:  MOVLB  0
037F8:  CALL   17D0
....................                      for(unsigned int16 i = 0; i < 20; i++) 
037FC:  MOVLB  5
037FE:  CLRF   x13
03800:  CLRF   x12
03802:  MOVF   x13,F
03804:  BNZ   3824
03806:  MOVF   x12,W
03808:  SUBLW  13
0380A:  BNC   3824
....................                      { 
....................                         delay_ms(100); 
0380C:  MOVLW  64
0380E:  MOVLB  6
03810:  MOVWF  xC7
03812:  MOVLB  0
03814:  CALL   0FC8
....................                         restart_wdt(); 
03818:  CLRWDT
0381A:  MOVLB  5
0381C:  INCF   x12,F
0381E:  BTFSC  FD8.2
03820:  INCF   x13,F
03822:  BRA    3802
....................                      } 
....................                      reset_cpu(); 
03824:  RESET
....................                      //DBIReset.Reset = true; 
....................                      break; 
03826:  MOVLB  0
03828:  BRA    3BAA
....................                   } 
....................                   case GetIOXStatus: 
....................                   {                      
....................                      if(GoIOXstatus.synchronized == true) 
0382A:  BTFSS  x63.0
0382C:  BRA    3868
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "The IOX is Synchronized"); 
0382E:  MOVLW  03
03830:  MOVLB  3
03832:  MOVWF  x86
03834:  MOVLW  90
03836:  MOVWF  x85
03838:  MOVLW  A4
0383A:  MOVWF  FF6
0383C:  MOVLW  0B
0383E:  MOVWF  FF7
03840:  MOVLB  0
03842:  CALL   16B8
03846:  MOVLW  90
03848:  MOVLB  3
0384A:  SUBWF  x85,W
0384C:  MOVWF  xD6
....................                         sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
0384E:  MOVLW  33
03850:  MOVLB  6
03852:  MOVWF  xC5
03854:  MOVFF  3D6,6C6
03858:  MOVLW  03
0385A:  MOVWF  xC8
0385C:  MOVLW  90
0385E:  MOVWF  xC7
03860:  MOVLB  0
03862:  CALL   17D0
....................                      } 
03866:  BRA    38A0
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
03868:  MOVLW  03
0386A:  MOVLB  3
0386C:  MOVWF  x86
0386E:  MOVLW  90
03870:  MOVWF  x85
03872:  MOVLW  BC
03874:  MOVWF  FF6
03876:  MOVLW  0B
03878:  MOVWF  FF7
0387A:  MOVLB  0
0387C:  CALL   16B8
03880:  MOVLW  90
03882:  MOVLB  3
03884:  SUBWF  x85,W
03886:  MOVWF  xD6
....................                         sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
03888:  MOVLW  33
0388A:  MOVLB  6
0388C:  MOVWF  xC5
0388E:  MOVFF  3D6,6C6
03892:  MOVLW  03
03894:  MOVWF  xC8
03896:  MOVLW  90
03898:  MOVWF  xC7
0389A:  MOVLB  0
0389C:  CALL   17D0
....................                      } 
....................                      break; 
038A0:  BRA    3BAA
....................                   }  
....................                   case RqstFW: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Fimrware Version: %u.%u",firmwareMajorVersion,firmwareMinorVersion); 
038A2:  MOVLW  03
038A4:  MOVLB  3
038A6:  MOVWF  x86
038A8:  MOVLW  90
038AA:  MOVWF  x85
038AC:  MOVLW  D8
038AE:  MOVWF  FF6
038B0:  MOVLW  0B
038B2:  MOVWF  FF7
038B4:  MOVLW  12
038B6:  MOVLB  6
038B8:  MOVWF  xCD
038BA:  MOVLB  0
038BC:  CALL   1CBA
038C0:  MOVFF  22,7D9
038C4:  MOVLW  1B
038C6:  MOVLB  7
038C8:  MOVWF  xDA
038CA:  MOVLB  0
038CC:  CALL   174A
038D0:  MOVLW  2E
038D2:  MOVLB  7
038D4:  MOVWF  xDB
038D6:  MOVLB  0
038D8:  CALL   1696
038DC:  MOVFF  23,7D9
038E0:  MOVLW  1B
038E2:  MOVLB  7
038E4:  MOVWF  xDA
038E6:  MOVLB  0
038E8:  CALL   174A
038EC:  MOVLW  90
038EE:  MOVLB  3
038F0:  SUBWF  x85,W
038F2:  MOVWF  xD6
....................                      sendToPC(AsnwFW,cmdSize,&cdmMessage);  
038F4:  MOVLW  66
038F6:  MOVLB  6
038F8:  MOVWF  xC5
038FA:  MOVFF  3D6,6C6
038FE:  MOVLW  03
03900:  MOVWF  xC8
03902:  MOVLW  90
03904:  MOVWF  xC7
03906:  MOVLB  0
03908:  CALL   17D0
....................                      break; 
0390C:  BRA    3BAA
....................                   } 
....................                   case RqstHW: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Hardware Version: %u.%u",HardwareMajorVersion,HardwareMinorVersion); 
0390E:  MOVLW  03
03910:  MOVLB  3
03912:  MOVWF  x86
03914:  MOVLW  90
03916:  MOVWF  x85
03918:  MOVLW  F0
0391A:  MOVWF  FF6
0391C:  MOVLW  0B
0391E:  MOVWF  FF7
03920:  MOVLW  12
03922:  MOVLB  6
03924:  MOVWF  xCD
03926:  MOVLB  0
03928:  CALL   1CBA
0392C:  MOVFF  24,7D9
03930:  MOVLW  1B
03932:  MOVLB  7
03934:  MOVWF  xDA
03936:  MOVLB  0
03938:  CALL   174A
0393C:  MOVLW  2E
0393E:  MOVLB  7
03940:  MOVWF  xDB
03942:  MOVLB  0
03944:  CALL   1696
03948:  MOVFF  25,7D9
0394C:  MOVLW  1B
0394E:  MOVLB  7
03950:  MOVWF  xDA
03952:  MOVLB  0
03954:  CALL   174A
03958:  MOVLW  90
0395A:  MOVLB  3
0395C:  SUBWF  x85,W
0395E:  MOVWF  xD6
....................                      sendToPC(AsnwHW,cmdSize,&cdmMessage);  
03960:  MOVLW  68
03962:  MOVLB  6
03964:  MOVWF  xC5
03966:  MOVFF  3D6,6C6
0396A:  MOVLW  03
0396C:  MOVWF  xC8
0396E:  MOVLW  90
03970:  MOVWF  xC7
03972:  MOVLB  0
03974:  CALL   17D0
....................                      break; 
03978:  BRA    3BAA
....................                   } 
....................                   case GetIgnitionstatus: 
....................                   { 
....................                      if(GoDeviceInfo.Ignition == true) 
0397A:  MOVLB  4
0397C:  BTFSS  xEC.1
0397E:  BRA    39A4
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Ignition ON"); 
03980:  MOVLW  03
03982:  MOVLB  3
03984:  MOVWF  x86
03986:  MOVLW  90
03988:  MOVWF  x85
0398A:  MOVLW  08
0398C:  MOVWF  FF6
0398E:  MOVLW  0C
03990:  MOVWF  FF7
03992:  MOVLB  0
03994:  CALL   16B8
03998:  MOVLW  90
0399A:  MOVLB  3
0399C:  SUBWF  x85,W
0399E:  MOVWF  xD6
....................                      } 
039A0:  BRA    39C4
039A2:  MOVLB  4
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Ignition OFF"); 
039A4:  MOVLW  03
039A6:  MOVLB  3
039A8:  MOVWF  x86
039AA:  MOVLW  90
039AC:  MOVWF  x85
039AE:  MOVLW  14
039B0:  MOVWF  FF6
039B2:  MOVLW  0C
039B4:  MOVWF  FF7
039B6:  MOVLB  0
039B8:  CALL   16B8
039BC:  MOVLW  90
039BE:  MOVLB  3
039C0:  SUBWF  x85,W
039C2:  MOVWF  xD6
....................                      } 
....................                      sendToPC(ShowIgnitionStatus,cmdSize,&cdmMessage);  
039C4:  MOVLW  49
039C6:  MOVLB  6
039C8:  MOVWF  xC5
039CA:  MOVFF  3D6,6C6
039CE:  MOVLW  03
039D0:  MOVWF  xC8
039D2:  MOVLW  90
039D4:  MOVWF  xC7
039D6:  MOVLB  0
039D8:  CALL   17D0
....................                      break; 
039DC:  BRA    3BAA
....................                   } 
....................                   case InputGetStatus: 
....................                   { 
....................                      if(AllowedFuntions.showInputstatus == true) 
039DE:  BTFSS  21.1
039E0:  BRA    3A3C
....................                      { 
....................                        cmdSize = sprintf(cdmMessage, "Input Value: %u",!InputStatus); 
039E2:  MOVLW  00
039E4:  BTFSS  4D.5
039E6:  MOVLW  01
039E8:  MOVLB  6
039EA:  MOVWF  xC5
039EC:  MOVLW  03
039EE:  MOVLB  3
039F0:  MOVWF  x86
039F2:  MOVLW  90
039F4:  MOVWF  x85
039F6:  MOVLW  22
039F8:  MOVWF  FF6
039FA:  MOVLW  0C
039FC:  MOVWF  FF7
039FE:  MOVLW  0D
03A00:  MOVLB  6
03A02:  MOVWF  xCD
03A04:  MOVLB  0
03A06:  CALL   1CBA
03A0A:  MOVFF  6C5,7D9
03A0E:  MOVLW  1B
03A10:  MOVLB  7
03A12:  MOVWF  xDA
03A14:  MOVLB  0
03A16:  CALL   174A
03A1A:  MOVLW  90
03A1C:  MOVLB  3
03A1E:  SUBWF  x85,W
03A20:  MOVWF  xD6
....................                        sendToPC(InputShowStatus,cmdSize,&cdmMessage); 
03A22:  MOVLW  71
03A24:  MOVLB  6
03A26:  MOVWF  xC5
03A28:  MOVFF  3D6,6C6
03A2C:  MOVLW  03
03A2E:  MOVWF  xC8
03A30:  MOVLW  90
03A32:  MOVWF  xC7
03A34:  MOVLB  0
03A36:  CALL   17D0
....................                      } 
03A3A:  BRA    3A74
....................                      else 
....................                      { 
....................                         cmdSize = sprintf(cdmMessage, "Input State Request Not Supported"); 
03A3C:  MOVLW  03
03A3E:  MOVLB  3
03A40:  MOVWF  x86
03A42:  MOVLW  90
03A44:  MOVWF  x85
03A46:  MOVLW  32
03A48:  MOVWF  FF6
03A4A:  MOVLW  0C
03A4C:  MOVWF  FF7
03A4E:  MOVLB  0
03A50:  CALL   16B8
03A54:  MOVLW  90
03A56:  MOVLB  3
03A58:  SUBWF  x85,W
03A5A:  MOVWF  xD6
....................                         sendToPC(CommandNotAllowed,cmdSize,&cdmMessage); 
03A5C:  MOVLW  41
03A5E:  MOVLB  6
03A60:  MOVWF  xC5
03A62:  MOVFF  3D6,6C6
03A66:  MOVLW  03
03A68:  MOVWF  xC8
03A6A:  MOVLW  90
03A6C:  MOVWF  xC7
03A6E:  MOVLB  0
03A70:  CALL   17D0
....................                      } 
....................                      break; 
03A74:  BRA    3BAA
....................                   } 
....................                   case DBIGetSerie: 
....................                   { 
....................                      unsigned int8 serie[8]; 
....................                      read_program_memory(0x200000, serie, 8); 
03A76:  MOVLW  20
03A78:  MOVWF  FF8
03A7A:  CLRF   FF7
03A7C:  CLRF   FF6
03A7E:  MOVLW  05
03A80:  MOVWF  FEA
03A82:  MOVLW  14
03A84:  MOVWF  FE9
03A86:  MOVLB  6
03A88:  CLRF   xC6
03A8A:  MOVLW  08
03A8C:  MOVWF  xC5
03A8E:  MOVLB  0
03A90:  CALL   1F02
....................                      cmdSize = sprintf(cdmMessage, "Serial ID: %LX%X%X%X%X%X%X%X%X",deviceType,serie[7],serie[6],serie[5],serie[4],serie[3],serie[2],serie[1],serie[0]); 
03A94:  MOVLW  03
03A96:  MOVLB  3
03A98:  MOVWF  x86
03A9A:  MOVLW  90
03A9C:  MOVWF  x85
03A9E:  MOVLW  54
03AA0:  MOVWF  FF6
03AA2:  MOVLW  0C
03AA4:  MOVWF  FF7
03AA6:  MOVLW  0B
03AA8:  MOVLB  6
03AAA:  MOVWF  xCD
03AAC:  MOVLB  0
03AAE:  CALL   1CBA
03AB2:  MOVFF  38F,7D9
03AB6:  MOVLW  37
03AB8:  MOVLB  7
03ABA:  MOVWF  xDA
03ABC:  MOVLB  0
03ABE:  CALL   16D8
03AC2:  MOVFF  38E,7D9
03AC6:  MOVLW  37
03AC8:  MOVLB  7
03ACA:  MOVWF  xDA
03ACC:  MOVLB  0
03ACE:  CALL   16D8
03AD2:  MOVFF  51B,7D9
03AD6:  MOVLW  37
03AD8:  MOVLB  7
03ADA:  MOVWF  xDA
03ADC:  MOVLB  0
03ADE:  CALL   16D8
03AE2:  MOVFF  51A,7D9
03AE6:  MOVLW  37
03AE8:  MOVLB  7
03AEA:  MOVWF  xDA
03AEC:  MOVLB  0
03AEE:  CALL   16D8
03AF2:  MOVFF  519,7D9
03AF6:  MOVLW  37
03AF8:  MOVLB  7
03AFA:  MOVWF  xDA
03AFC:  MOVLB  0
03AFE:  CALL   16D8
03B02:  MOVFF  518,7D9
03B06:  MOVLW  37
03B08:  MOVLB  7
03B0A:  MOVWF  xDA
03B0C:  MOVLB  0
03B0E:  CALL   16D8
03B12:  MOVFF  517,7D9
03B16:  MOVLW  37
03B18:  MOVLB  7
03B1A:  MOVWF  xDA
03B1C:  MOVLB  0
03B1E:  CALL   16D8
03B22:  MOVFF  516,7D9
03B26:  MOVLW  37
03B28:  MOVLB  7
03B2A:  MOVWF  xDA
03B2C:  MOVLB  0
03B2E:  CALL   16D8
03B32:  MOVFF  515,7D9
03B36:  MOVLW  37
03B38:  MOVLB  7
03B3A:  MOVWF  xDA
03B3C:  MOVLB  0
03B3E:  CALL   16D8
03B42:  MOVFF  514,7D9
03B46:  MOVLW  37
03B48:  MOVLB  7
03B4A:  MOVWF  xDA
03B4C:  MOVLB  0
03B4E:  CALL   16D8
03B52:  MOVLW  90
03B54:  MOVLB  3
03B56:  SUBWF  x85,W
03B58:  MOVWF  xD6
....................                      sendToPC(InputShowStatus,cmdSize,&cdmMessage); 
03B5A:  MOVLW  71
03B5C:  MOVLB  6
03B5E:  MOVWF  xC5
03B60:  MOVFF  3D6,6C6
03B64:  MOVLW  03
03B66:  MOVWF  xC8
03B68:  MOVLW  90
03B6A:  MOVWF  xC7
03B6C:  MOVLB  0
03B6E:  CALL   17D0
....................                      break; 
03B72:  BRA    3BAA
....................                   } 
....................                    
....................                   default: 
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Unidentified Command"); 
03B74:  MOVLW  03
03B76:  MOVLB  3
03B78:  MOVWF  x86
03B7A:  MOVLW  90
03B7C:  MOVWF  x85
03B7E:  MOVLW  74
03B80:  MOVWF  FF6
03B82:  MOVLW  0C
03B84:  MOVWF  FF7
03B86:  MOVLB  0
03B88:  CALL   16B8
03B8C:  MOVLW  90
03B8E:  MOVLB  3
03B90:  SUBWF  x85,W
03B92:  MOVWF  xD6
....................                      sendToPC(ComandoUnidentified,cmdSize,&cdmMessage);  
03B94:  MOVLB  6
03B96:  SETF   xC5
03B98:  MOVFF  3D6,6C6
03B9C:  MOVLW  03
03B9E:  MOVWF  xC8
03BA0:  MOVLW  90
03BA2:  MOVWF  xC7
03BA4:  MOVLB  0
03BA6:  CALL   17D0
....................                      break; 
....................                   } 
....................                } 
....................                break; 
03BAA:  BRA    3C20
....................             } 
....................             case chkFail: 
....................             { 
....................                cmdSize = sprintf(cdmMessage, "Checksum Fail"); 
03BAC:  MOVLW  03
03BAE:  MOVLB  3
03BB0:  MOVWF  x86
03BB2:  MOVLW  90
03BB4:  MOVWF  x85
03BB6:  MOVLW  8A
03BB8:  MOVWF  FF6
03BBA:  MOVLW  0C
03BBC:  MOVWF  FF7
03BBE:  MOVLB  0
03BC0:  CALL   16B8
03BC4:  MOVLW  90
03BC6:  MOVLB  3
03BC8:  SUBWF  x85,W
03BCA:  MOVWF  xD6
....................                sendToPC(MsgFailACK,cmdSize,&cdmMessage);  
03BCC:  MOVLW  08
03BCE:  MOVLB  6
03BD0:  MOVWF  xC5
03BD2:  MOVFF  3D6,6C6
03BD6:  MOVLW  03
03BD8:  MOVWF  xC8
03BDA:  MOVLW  90
03BDC:  MOVWF  xC7
03BDE:  MOVLB  0
03BE0:  CALL   17D0
....................                break; 
03BE4:  BRA    3C20
....................             } 
....................             case formatFail: 
....................             { 
....................                cmdSize = sprintf(cdmMessage, "Invalid Frame Format"); 
03BE6:  MOVLW  03
03BE8:  MOVLB  3
03BEA:  MOVWF  x86
03BEC:  MOVLW  90
03BEE:  MOVWF  x85
03BF0:  MOVLW  98
03BF2:  MOVWF  FF6
03BF4:  MOVLW  0C
03BF6:  MOVWF  FF7
03BF8:  MOVLB  0
03BFA:  CALL   16B8
03BFE:  MOVLW  90
03C00:  MOVLB  3
03C02:  SUBWF  x85,W
03C04:  MOVWF  xD6
....................                sendToPC(MsgFailFormat,cmdSize,&cdmMessage);  
03C06:  MOVLW  09
03C08:  MOVLB  6
03C0A:  MOVWF  xC5
03C0C:  MOVFF  3D6,6C6
03C10:  MOVLW  03
03C12:  MOVWF  xC8
03C14:  MOVLW  90
03C16:  MOVWF  xC7
03C18:  MOVLB  0
03C1A:  CALL   17D0
....................                break; 
03C1E:  BRA    3C20
....................             } 
....................             default: 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          pc_result = free; 
03C20:  MOVLB  2
03C22:  SETF   xB8
....................       } 
....................        
....................       if(GoIOXstatus.timeToSync > 1000) // se cumplio un segundo 
03C24:  MOVLB  0
03C26:  MOVF   x62,W
03C28:  SUBLW  02
03C2A:  BC    3CD4
03C2C:  XORLW  FF
03C2E:  BNZ   3C36
03C30:  MOVF   x61,W
03C32:  SUBLW  E8
03C34:  BC    3CD4
....................       { 
....................          if(GoIOXstatus.synchronized == false) 
03C36:  BTFSC  x63.0
03C38:  BRA    3C42
....................          { 
....................             SentHandShakeRequest(); 
03C3A:  GOTO   1F20
....................             output_toggle(Led); 
03C3E:  BCF    F92.0
03C40:  BTG    F89.0
....................          } 
....................          if(GoIOXstatus.lastSynchronized != GoIOXstatus.synchronized) 
03C42:  CLRF   00
03C44:  BTFSC  x63.0
03C46:  BSF    00.1
03C48:  MOVF   x63,W
03C4A:  XORWF  00,W
03C4C:  ANDLW  02
03C4E:  BZ    3CD0
....................          { 
....................             if(GoIOXstatus.synchronized == true) 
03C50:  BTFSS  x63.0
03C52:  BRA    3C92
....................             { 
....................                cmdSize = sprintf(cdmMessage, "The IOX is Synchronized"); 
03C54:  MOVLW  03
03C56:  MOVLB  3
03C58:  MOVWF  x86
03C5A:  MOVLW  90
03C5C:  MOVWF  x85
03C5E:  MOVLW  AE
03C60:  MOVWF  FF6
03C62:  MOVLW  0C
03C64:  MOVWF  FF7
03C66:  MOVLB  0
03C68:  CALL   16B8
03C6C:  MOVLW  90
03C6E:  MOVLB  3
03C70:  SUBWF  x85,W
03C72:  MOVWF  xD6
....................                sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
03C74:  MOVLW  33
03C76:  MOVLB  6
03C78:  MOVWF  xC5
03C7A:  MOVFF  3D6,6C6
03C7E:  MOVLW  03
03C80:  MOVWF  xC8
03C82:  MOVLW  90
03C84:  MOVWF  xC7
03C86:  MOVLB  0
03C88:  CALL   17D0
....................                 
....................                /*cmdSize = sprintf(cdmMessage, "DBI Messages Detected"); 
....................                SentFreeFormatThirdPartyData(cmdSize, &cdmMessage); */ 
....................                output_high(Led); 
03C8C:  BCF    F92.0
03C8E:  BSF    F89.0
....................             } 
03C90:  BRA    3CCA
....................             else 
....................             { 
....................                cmdSize = sprintf(cdmMessage, "The IOX is Not Synchronized"); 
03C92:  MOVLW  03
03C94:  MOVLB  3
03C96:  MOVWF  x86
03C98:  MOVLW  90
03C9A:  MOVWF  x85
03C9C:  MOVLW  C6
03C9E:  MOVWF  FF6
03CA0:  MOVLW  0C
03CA2:  MOVWF  FF7
03CA4:  MOVLB  0
03CA6:  CALL   16B8
03CAA:  MOVLW  90
03CAC:  MOVLB  3
03CAE:  SUBWF  x85,W
03CB0:  MOVWF  xD6
....................                sendToPC(ShowIOXstatus,cmdSize,&cdmMessage); 
03CB2:  MOVLW  33
03CB4:  MOVLB  6
03CB6:  MOVWF  xC5
03CB8:  MOVFF  3D6,6C6
03CBC:  MOVLW  03
03CBE:  MOVWF  xC8
03CC0:  MOVLW  90
03CC2:  MOVWF  xC7
03CC4:  MOVLB  0
03CC6:  CALL   17D0
....................             }    
....................             GoIOXstatus.lastSynchronized = GoIOXstatus.synchronized; 
03CCA:  BCF    x63.1
03CCC:  BTFSC  x63.0
03CCE:  BSF    x63.1
....................          } 
....................          GoIOXstatus.timeToSync = 0; 
03CD0:  CLRF   x62
03CD2:  CLRF   x61
....................       } 
....................        
....................       if(GoIOXstatus.msgReady) 
03CD4:  BTFSS  x63.2
03CD6:  GOTO   6368
....................       { 
....................          switch (Msg_Type) 
03CDA:  MOVF   x92,W
03CDC:  XORLW  01
03CDE:  BZ    3CF8
03CE0:  XORLW  03
03CE2:  BZ    3D14
03CE4:  XORLW  23
03CE6:  BZ    3DA8
03CE8:  XORLW  03
03CEA:  BTFSC  FD8.2
03CEC:  BRA    3EA2
03CEE:  XORLW  01
03CF0:  BTFSC  FD8.2
03CF2:  BRA    3F22
03CF4:  GOTO   6366
....................          {             
....................             case HandshakeRequest: 
....................             { 
....................                SentHandshakeConfirmation(4151, 0, 1);  // 
03CF8:  MOVLW  10
03CFA:  MOVLB  6
03CFC:  MOVWF  xC6
03CFE:  MOVLW  37
03D00:  MOVWF  xC5
03D02:  CLRF   xC7
03D04:  MOVLW  01
03D06:  MOVWF  xC8
03D08:  MOVLB  0
03D0A:  GOTO   1F28
....................                GoIOXstatus.synchronized = True; 
03D0E:  BSF    x63.0
....................                ////fprintf(Serial,"#HandShake Answered\n\r"); 
....................                break; 
03D10:  GOTO   6366
....................             } 
....................             case ThirdPartyDataACK: 
....................             { 
....................                if(sentByPC == true) 
03D14:  BTFSS  4D.3
03D16:  BRA    3D9E
....................                { 
....................                   if(GoIOXstatus.WattingACK == 1) 
03D18:  DECFSZ x60,W
03D1A:  BRA    3D56
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Custom Data Sent"); 
03D1C:  MOVLW  03
03D1E:  MOVLB  3
03D20:  MOVWF  x86
03D22:  MOVLW  90
03D24:  MOVWF  x85
03D26:  MOVLW  E2
03D28:  MOVWF  FF6
03D2A:  MOVLW  0C
03D2C:  MOVWF  FF7
03D2E:  MOVLB  0
03D30:  CALL   16B8
03D34:  MOVLW  90
03D36:  MOVLB  3
03D38:  SUBWF  x85,W
03D3A:  MOVWF  xD6
....................                      sendToPC(CustomDataSent,cmdSize,&cdmMessage);  
03D3C:  MOVLW  39
03D3E:  MOVLB  6
03D40:  MOVWF  xC5
03D42:  MOVFF  3D6,6C6
03D46:  MOVLW  03
03D48:  MOVWF  xC8
03D4A:  MOVLW  90
03D4C:  MOVWF  xC7
03D4E:  MOVLB  0
03D50:  CALL   17D0
....................                   } 
03D54:  BRA    3D94
....................                   else if(GoIOXstatus.WattingACK == 2) 
03D56:  MOVF   x60,W
03D58:  SUBLW  02
03D5A:  BNZ   3D94
....................                   { 
....................                      cmdSize = sprintf(cdmMessage, "Status Data Sent"); 
03D5C:  MOVLW  03
03D5E:  MOVLB  3
03D60:  MOVWF  x86
03D62:  MOVLW  90
03D64:  MOVWF  x85
03D66:  MOVLW  F4
03D68:  MOVWF  FF6
03D6A:  MOVLW  0C
03D6C:  MOVWF  FF7
03D6E:  MOVLB  0
03D70:  CALL   16B8
03D74:  MOVLW  90
03D76:  MOVLB  3
03D78:  SUBWF  x85,W
03D7A:  MOVWF  xD6
....................                      sendToPC(StatusDataSent,cmdSize,&cdmMessage);  
03D7C:  MOVLW  36
03D7E:  MOVLB  6
03D80:  MOVWF  xC5
03D82:  MOVFF  3D6,6C6
03D86:  MOVLW  03
03D88:  MOVWF  xC8
03D8A:  MOVLW  90
03D8C:  MOVWF  xC7
03D8E:  MOVLB  0
03D90:  CALL   17D0
....................                   } 
....................                   sentByPC = false; 
03D94:  BCF    4D.3
....................                   GoIOXstatus.n_timeOutCustom = 0; 
03D96:  CLRF   5F
03D98:  CLRF   5E
....................                   GoIOXstatus.WattingACK = 0;  
03D9A:  CLRF   x60
....................                } 
03D9C:  BRA    3DA4
....................                else 
....................                { 
....................                   GoIOXstatus.n_timeOutCustom = 0; 
03D9E:  CLRF   5F
03DA0:  CLRF   5E
....................                   GoIOXstatus.WattingACK = 0;  
03DA2:  CLRF   x60
....................                } 
....................                break; 
03DA4:  GOTO   6366
....................             } 
....................             case GoDeviceData: 
....................             { 
....................                SentDeviceDataACK();  
03DA8:  GOTO   1FAA
....................                GetParameters(&GoDeviceInfo); 
03DAC:  MOVLW  04
03DAE:  MOVLB  6
03DB0:  MOVWF  xC6
03DB2:  MOVLW  D9
03DB4:  MOVWF  xC5
03DB6:  MOVLB  0
03DB8:  GOTO   1FE6
....................                GoInfo_Leng  = Msg_Leng; 
03DBC:  MOVFF  93,191
....................                for(unsigned int8 i= 0; i< Msg_Leng; i++) 
03DC0:  MOVLB  5
03DC2:  CLRF   x1C
03DC4:  MOVLB  0
03DC6:  MOVF   x93,W
03DC8:  MOVLB  5
03DCA:  SUBWF  x1C,W
03DCC:  BC    3E08
....................                { 
....................                   GoInfo_Data[i] = Msg_Data[i]; 
03DCE:  CLRF   03
03DD0:  MOVF   x1C,W
03DD2:  ADDLW  92
03DD4:  MOVWF  01
03DD6:  MOVLW  01
03DD8:  ADDWFC 03,F
03DDA:  MOVLB  6
03DDC:  MOVFF  03,6C6
03DE0:  CLRF   03
03DE2:  MOVLB  5
03DE4:  MOVF   x1C,W
03DE6:  ADDLW  94
03DE8:  MOVWF  FE9
03DEA:  MOVLW  00
03DEC:  ADDWFC 03,W
03DEE:  MOVWF  FEA
03DF0:  MOVFF  FEF,6C7
03DF4:  MOVLB  6
03DF6:  MOVFF  6C6,FEA
03DFA:  MOVFF  01,FE9
03DFE:  MOVFF  6C7,FEF
03E02:  MOVLB  5
03E04:  INCF   x1C,F
03E06:  BRA    3DC4
....................                } 
....................                //GetParameters(&GoDeviceInfo);    
....................                GoInfoDataReady = true; 
03E08:  BSF    4D.1
....................                if(AllowedFuntions.showGoInfo == true) 
03E0A:  BTFSS  20.7
03E0C:  BRA    3E92
....................                { 
....................                   GoInfoSize = 0; 
03E0E:  MOVLB  4
03E10:  CLRF   xD6
....................                   for(unsigned int8 i= 0; i< Msg_Leng; i++) 
03E12:  MOVLB  5
03E14:  CLRF   x1D
03E16:  MOVLB  0
03E18:  MOVF   x93,W
03E1A:  MOVLB  5
03E1C:  SUBWF  x1D,W
03E1E:  BC    3E78
....................                   { 
....................                      char cdmMessage[2]; 
....................                      sprintf(cdmMessage, "%X",Msg_Data[i]); 
03E20:  CLRF   03
03E22:  MOVF   x1D,W
03E24:  ADDLW  94
03E26:  MOVWF  FE9
03E28:  MOVLW  00
03E2A:  ADDWFC 03,W
03E2C:  MOVWF  FEA
03E2E:  MOVFF  FEF,7D9
03E32:  MOVLW  05
03E34:  MOVLB  3
03E36:  MOVWF  x86
03E38:  MOVLW  1E
03E3A:  MOVWF  x85
03E3C:  MOVLW  37
03E3E:  MOVLB  7
03E40:  MOVWF  xDA
03E42:  MOVLB  0
03E44:  CALL   16D8
....................                      GoInfo[GoInfoSize++] = cdmMessage[0]; 
03E48:  MOVLB  4
03E4A:  MOVF   xD6,W
03E4C:  INCF   xD6,F
03E4E:  CLRF   03
03E50:  ADDLW  D7
03E52:  MOVWF  FE9
03E54:  MOVLW  03
03E56:  ADDWFC 03,W
03E58:  MOVWF  FEA
03E5A:  MOVFF  51E,FEF
....................                      GoInfo[GoInfoSize++] = cdmMessage[1]; 
03E5E:  MOVF   xD6,W
03E60:  INCF   xD6,F
03E62:  CLRF   03
03E64:  ADDLW  D7
03E66:  MOVWF  FE9
03E68:  MOVLW  03
03E6A:  ADDWFC 03,W
03E6C:  MOVWF  FEA
03E6E:  MOVFF  51F,FEF
03E72:  MOVLB  5
03E74:  INCF   x1D,F
03E76:  BRA    3E16
....................                   } 
....................                   sendToPC(ShowVehicleInfo,GoInfoSize,&GoInfo); 
03E78:  MOVLW  31
03E7A:  MOVLB  6
03E7C:  MOVWF  xC5
03E7E:  MOVFF  4D6,6C6
03E82:  MOVLW  03
03E84:  MOVWF  xC8
03E86:  MOVLW  D7
03E88:  MOVWF  xC7
03E8A:  MOVLB  0
03E8C:  CALL   17D0
03E90:  MOVLB  5
....................                } 
....................                GoIOXstatus.WattingGoInfoResponse = false; 
03E92:  MOVLB  0
03E94:  BCF    x74.0
....................                GoIOXstatus.n_timeOutGoInfoResponse = 0; 
03E96:  CLRF   x7C
03E98:  CLRF   x7B
03E9A:  CLRF   x7A
03E9C:  CLRF   x79
....................                break; 
03E9E:  GOTO   6366
....................             } 
....................             case BinaryDataResponse: 
....................             { 
....................                GoIOXstatus.WattingACKmime = false; 
03EA2:  BCF    4F.0
....................                GoIOXstatus.n_timeOutMime = 0; 
03EA4:  CLRF   53
03EA6:  CLRF   52
....................                 
....................                if(Msg_Data[0] == 1) 
03EA8:  DECFSZ x94,W
03EAA:  BRA    3EE6
....................                { 
....................                   cmdSize = sprintf(cdmMessage, "MIME Message Sent"); 
03EAC:  MOVLW  03
03EAE:  MOVLB  3
03EB0:  MOVWF  x86
03EB2:  MOVLW  90
03EB4:  MOVWF  x85
03EB6:  MOVLW  06
03EB8:  MOVWF  FF6
03EBA:  MOVLW  0D
03EBC:  MOVWF  FF7
03EBE:  MOVLB  0
03EC0:  CALL   16B8
03EC4:  MOVLW  90
03EC6:  MOVLB  3
03EC8:  SUBWF  x85,W
03ECA:  MOVWF  xD6
....................                   sendToPC(TextMsgSent,cmdSize,&cdmMessage);  
03ECC:  MOVLW  13
03ECE:  MOVLB  6
03ED0:  MOVWF  xC5
03ED2:  MOVFF  3D6,6C6
03ED6:  MOVLW  03
03ED8:  MOVWF  xC8
03EDA:  MOVLW  90
03EDC:  MOVWF  xC7
03EDE:  MOVLB  0
03EE0:  CALL   17D0
....................                } 
03EE4:  BRA    3F1E
....................                else 
....................                { 
....................                   //el mensaje fallo 
....................                   cmdSize = sprintf(cdmMessage, "MIME Message Failed"); 
03EE6:  MOVLW  03
03EE8:  MOVLB  3
03EEA:  MOVWF  x86
03EEC:  MOVLW  90
03EEE:  MOVWF  x85
03EF0:  MOVLW  18
03EF2:  MOVWF  FF6
03EF4:  MOVLW  0D
03EF6:  MOVWF  FF7
03EF8:  MOVLB  0
03EFA:  CALL   16B8
03EFE:  MOVLW  90
03F00:  MOVLB  3
03F02:  SUBWF  x85,W
03F04:  MOVWF  xD6
....................                   sendToPC(TextMsgFailed,cmdSize,&cdmMessage);  
03F06:  MOVLW  16
03F08:  MOVLB  6
03F0A:  MOVWF  xC5
03F0C:  MOVFF  3D6,6C6
03F10:  MOVLW  03
03F12:  MOVWF  xC8
03F14:  MOVLW  90
03F16:  MOVWF  xC7
03F18:  MOVLB  0
03F1A:  CALL   17D0
....................                } 
....................                break; 
03F1E:  GOTO   6366
....................             } 
....................             case BinaryDataPacketIN: 
....................             { 
....................                if(Msg_Data[0] == 0 && Msg_Data[1] == 0x03 && Msg_Data[2] == 0x41 && Msg_Data[3] == 0x43 && Msg_Data[4] == 0x4B && Msg_Data[5] == 0x04) //hacer mejor esta validacion 
03F22:  MOVF   x94,F
03F24:  BNZ   3F8A
03F26:  MOVF   x95,W
03F28:  SUBLW  03
03F2A:  BNZ   3F8A
03F2C:  MOVF   x96,W
03F2E:  SUBLW  41
03F30:  BNZ   3F8A
03F32:  MOVF   x97,W
03F34:  SUBLW  43
03F36:  BNZ   3F8A
03F38:  MOVF   x98,W
03F3A:  SUBLW  4B
03F3C:  BNZ   3F8A
03F3E:  MOVF   x99,W
03F40:  SUBLW  04
03F42:  BNZ   3F8A
....................                { 
....................                   ////fprintf(Serial,"#Mensaje %Lu entregado\n\r",x); 
....................                   cmdSize = sprintf(cdmMessage, "Message Delivered"); 
03F44:  MOVLW  03
03F46:  MOVLB  3
03F48:  MOVWF  x86
03F4A:  MOVLW  90
03F4C:  MOVWF  x85
03F4E:  MOVLW  2C
03F50:  MOVWF  FF6
03F52:  MOVLW  0D
03F54:  MOVWF  FF7
03F56:  MOVLB  0
03F58:  CALL   16B8
03F5C:  MOVLW  90
03F5E:  MOVLB  3
03F60:  SUBWF  x85,W
03F62:  MOVWF  xD6
....................                   sendToPC(TextMsgDelivered,cmdSize,&cdmMessage);  
03F64:  MOVLW  15
03F66:  MOVLB  6
03F68:  MOVWF  xC5
03F6A:  MOVFF  3D6,6C6
03F6E:  MOVLW  03
03F70:  MOVWF  xC8
03F72:  MOVLW  90
03F74:  MOVWF  xC7
03F76:  MOVLB  0
03F78:  CALL   17D0
....................                   GoIOXstatus.WattingACKmimeFromServer = false; 
03F7C:  BCF    x7D.1
....................                   GoIOXstatus.n_timeOutACKFromServer = 0; 
03F7E:  CLRF   x85
03F80:  CLRF   x84
03F82:  CLRF   x83
03F84:  CLRF   x82
....................                } 
03F86:  GOTO   6364
....................                else 
....................                { 
....................                   if(isFormatedMessage(&Msg_Data)) 
03F8A:  MOVLB  6
03F8C:  CLRF   xC6
03F8E:  MOVLW  94
03F90:  MOVWF  xC5
03F92:  MOVLB  0
03F94:  GOTO   2124
03F98:  MOVF   01,F
03F9A:  BTFSC  FD8.2
03F9C:  GOTO   6364
....................                   { 
....................                      switch(Msg_Data[0]) 
03FA0:  MOVF   x94,W
03FA2:  XORLW  A1
03FA4:  BTFSC  FD8.2
03FA6:  BRA    417E
03FA8:  XORLW  02
03FAA:  BTFSC  FD8.2
03FAC:  BRA    41F8
03FAE:  XORLW  07
03FB0:  BTFSC  FD8.2
03FB2:  BRA    423A
03FB4:  XORLW  01
03FB6:  BTFSC  FD8.2
03FB8:  BRA    4262
03FBA:  XORLW  03
03FBC:  BTFSC  FD8.2
03FBE:  BRA    42D4
03FC0:  XORLW  01
03FC2:  BTFSC  FD8.2
03FC4:  BRA    4320
03FC6:  XORLW  0F
03FC8:  BTFSC  FD8.2
03FCA:  BRA    435E
03FCC:  XORLW  01
03FCE:  BTFSC  FD8.2
03FD0:  BRA    4386
03FD2:  XORLW  03
03FD4:  BTFSC  FD8.2
03FD6:  BRA    4406
03FD8:  XORLW  01
03FDA:  BTFSC  FD8.2
03FDC:  BRA    442A
03FDE:  XORLW  07
03FE0:  BTFSC  FD8.2
03FE2:  BRA    44AA
03FE4:  XORLW  01
03FE6:  BTFSC  FD8.2
03FE8:  BRA    44CE
03FEA:  XORLW  03
03FEC:  BTFSC  FD8.2
03FEE:  BRA    454E
03FF0:  XORLW  01
03FF2:  BTFSC  FD8.2
03FF4:  BRA    4572
03FF6:  XORLW  0F
03FF8:  BTFSC  FD8.2
03FFA:  BRA    45F2
03FFC:  XORLW  10
03FFE:  BTFSC  FD8.2
04000:  BRA    4616
04002:  XORLW  01
04004:  BTFSC  FD8.2
04006:  BRA    4654
04008:  XORLW  03
0400A:  BTFSC  FD8.2
0400C:  BRA    467C
0400E:  XORLW  01
04010:  BTFSC  FD8.2
04012:  BRA    46BE
04014:  XORLW  07
04016:  BTFSC  FD8.2
04018:  BRA    46EA
0401A:  XORLW  01
0401C:  BTFSC  FD8.2
0401E:  GOTO   476A
04022:  XORLW  03
04024:  BTFSC  FD8.2
04026:  GOTO   478E
0402A:  XORLW  01
0402C:  BTFSC  FD8.2
0402E:  GOTO   480E
04032:  XORLW  77
04034:  BTFSC  FD8.2
04036:  GOTO   4832
0403A:  XORLW  01
0403C:  BTFSC  FD8.2
0403E:  GOTO   48B8
04042:  XORLW  03
04044:  BTFSC  FD8.2
04046:  GOTO   48D8
0404A:  XORLW  01
0404C:  BTFSC  FD8.2
0404E:  GOTO   499A
04052:  XORLW  07
04054:  BTFSC  FD8.2
04056:  GOTO   4A16
0405A:  XORLW  01
0405C:  BTFSC  FD8.2
0405E:  GOTO   4A88
04062:  XORLW  02
04064:  BTFSC  FD8.2
04066:  GOTO   4AD4
0406A:  XORLW  01
0406C:  BTFSC  FD8.2
0406E:  GOTO   4BCE
04072:  XORLW  0F
04074:  BTFSC  FD8.2
04076:  GOTO   4BFA
0407A:  XORLW  01
0407C:  BTFSC  FD8.2
0407E:  GOTO   5142
04082:  XORLW  03
04084:  BTFSC  FD8.2
04086:  GOTO   5212
0408A:  XORLW  06
0408C:  BTFSC  FD8.2
0408E:  GOTO   5298
04092:  XORLW  1D
04094:  BTFSC  FD8.2
04096:  GOTO   52BC
0409A:  XORLW  01
0409C:  BTFSC  FD8.2
0409E:  GOTO   532E
040A2:  XORLW  03
040A4:  BTFSC  FD8.2
040A6:  GOTO   537A
040AA:  XORLW  01
040AC:  BTFSC  FD8.2
040AE:  GOTO   5410
040B2:  XORLW  04
040B4:  BTFSC  FD8.2
040B6:  GOTO   543C
040BA:  XORLW  03
040BC:  BTFSC  FD8.2
040BE:  GOTO   5478
040C2:  XORLW  01
040C4:  BTFSC  FD8.2
040C6:  GOTO   549C
040CA:  XORLW  03
040CC:  BTFSC  FD8.2
040CE:  GOTO   54C0
040D2:  XORLW  0F
040D4:  BTFSC  FD8.2
040D6:  GOTO   5528
040DA:  XORLW  39
040DC:  BTFSC  FD8.2
040DE:  GOTO   5592
040E2:  XORLW  01
040E4:  BTFSC  FD8.2
040E6:  GOTO   5604
040EA:  XORLW  03
040EC:  BTFSC  FD8.2
040EE:  GOTO   5650
040F2:  XORLW  01
040F4:  BTFSC  FD8.2
040F6:  GOTO   56D6
040FA:  XORLW  07
040FC:  BTFSC  FD8.2
040FE:  GOTO   56FA
04102:  XORLW  01
04104:  BTFSC  FD8.2
04106:  GOTO   5780
0410A:  XORLW  3D
0410C:  BTFSC  FD8.2
0410E:  GOTO   57A4
04112:  XORLW  4C
04114:  BTFSC  FD8.2
04116:  GOTO   5DE0
0411A:  XORLW  14
0411C:  BTFSC  FD8.2
0411E:  GOTO   6002
04122:  XORLW  01
04124:  BTFSC  FD8.2
04126:  GOTO   6082
0412A:  XORLW  03
0412C:  BTFSC  FD8.2
0412E:  GOTO   60A2
04132:  XORLW  01
04134:  BTFSC  FD8.2
04136:  GOTO   6122
0413A:  XORLW  05
0413C:  BTFSC  FD8.2
0413E:  GOTO   6142
04142:  XORLW  01
04144:  BTFSC  FD8.2
04146:  GOTO   6180
0414A:  XORLW  03
0414C:  BTFSC  FD8.2
0414E:  GOTO   61A8
04152:  XORLW  01
04154:  BTFSC  FD8.2
04156:  GOTO   61E6
0415A:  XORLW  15
0415C:  BTFSC  FD8.2
0415E:  GOTO   620E
04162:  XORLW  01
04164:  BTFSC  FD8.2
04166:  GOTO   628E
0416A:  XORLW  03
0416C:  BTFSC  FD8.2
0416E:  GOTO   62AE
04172:  XORLW  01
04174:  BTFSC  FD8.2
04176:  GOTO   632E
0417A:  GOTO   634E
....................                      { 
....................                         case MimeMsgFromServer: 
....................                         { 
....................                            if(AllowedFuntions.MIMEin == true) 
0417E:  BTFSS  20.2
04180:  BRA    41BC
....................                            { 
....................                               sendToPC(TextMsgFromServer,Msg_Data[1],&Msg_Data[2]); 
04182:  MOVLW  11
04184:  MOVLB  6
04186:  MOVWF  xC5
04188:  MOVFF  95,6C6
0418C:  CLRF   xC8
0418E:  MOVLW  96
04190:  MOVWF  xC7
04192:  MOVLB  0
04194:  CALL   17D0
....................                               if(AllowedFuntions.MimeACKResponse == true) 
04198:  BTFSS  20.4
0419A:  BRA    41BA
....................                               { 
....................                                  unsigned int8 buf[1]; 
....................                                  buf[0] = MimeMsgFromServer; 
0419C:  MOVLW  A1
0419E:  MOVLB  5
041A0:  MOVWF  x20
....................                                  SentFormatMIMEPacket(ACK, 1, &buf[0]); 
041A2:  MOVLW  FB
041A4:  MOVLB  6
041A6:  MOVWF  xC5
041A8:  MOVLW  01
041AA:  MOVWF  xC6
041AC:  MOVLW  05
041AE:  MOVWF  xC8
041B0:  MOVLW  20
041B2:  MOVWF  xC7
041B4:  MOVLB  0
041B6:  CALL   1A92
....................                               } 
....................                            } 
041BA:  BRA    41F4
....................                            else 
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "MIME Messages From Server Not Supported"); 
041BC:  MOVLW  03
041BE:  MOVLB  3
041C0:  MOVWF  x86
041C2:  MOVLW  90
041C4:  MOVWF  x85
041C6:  MOVLW  3E
041C8:  MOVWF  FF6
041CA:  MOVLW  0D
041CC:  MOVWF  FF7
041CE:  MOVLB  0
041D0:  CALL   16B8
041D4:  MOVLW  90
041D6:  MOVLB  3
041D8:  SUBWF  x85,W
041DA:  MOVWF  xD6
....................                               sendToPC(TextMsgFromServerNotSupported,cmdSize,&cdmMessage);  
041DC:  MOVLW  17
041DE:  MOVLB  6
041E0:  MOVWF  xC5
041E2:  MOVFF  3D6,6C6
041E6:  MOVLW  03
041E8:  MOVWF  xC8
041EA:  MOVLW  90
041EC:  MOVWF  xC7
041EE:  MOVLB  0
041F0:  CALL   17D0
....................                            } 
....................                            break; 
041F4:  GOTO   6362
....................                         } 
....................                         case MimeSetTimeOutBinary: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
041F8:  MOVF   x95,W
041FA:  SUBLW  02
041FC:  BNZ   4236
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
041FE:  MOVFF  96,522
04202:  MOVFF  97,521
....................                               GoIOXstatus.p_timeOutMime = valor; 
04206:  MOVFF  522,51
0420A:  MOVFF  521,50
....................                               ////fprintf(Serial,"TOut Binary= %lu %c%c",GoIOXstatus.p_timeOutMime,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = GoIOXstatus.p_timeOutMime >> 0 & 0xFF; 
0420E:  MOVFF  50,523
04212:  MOVLB  5
....................                               buf[1] = GoIOXstatus.p_timeOutMime >> 8 & 0xFF; 
04214:  MOVFF  51,524
04218:  MOVLB  5
....................                               SentFormatMIMEPacket(MimeGetTimeOutBinary, 2, &buf[0]);UpDateVariables(); 
0421A:  MOVLW  A4
0421C:  MOVLB  6
0421E:  MOVWF  xC5
04220:  MOVLW  02
04222:  MOVWF  xC6
04224:  MOVLW  05
04226:  MOVWF  xC8
04228:  MOVLW  23
0422A:  MOVWF  xC7
0422C:  MOVLB  0
0422E:  CALL   1A92
04232:  CALL   21EC
....................                            } 
....................                            break; 
04236:  GOTO   6362
....................                         } 
....................                         case MimeGetTimeOutBinary: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = GoIOXstatus.p_timeOutMime >> 0 & 0xFF; 
0423A:  MOVFF  50,525
0423E:  MOVLB  5
....................                            buf[1] = GoIOXstatus.p_timeOutMime >> 8 & 0xFF; 
04240:  MOVFF  51,526
04244:  MOVLB  5
....................                            SentFormatMIMEPacket(MimeGetTimeOutBinary, 2, &buf[0]); 
04246:  MOVLW  A4
04248:  MOVLB  6
0424A:  MOVWF  xC5
0424C:  MOVLW  02
0424E:  MOVWF  xC6
04250:  MOVLW  05
04252:  MOVWF  xC8
04254:  MOVLW  25
04256:  MOVWF  xC7
04258:  MOVLB  0
0425A:  CALL   1A92
....................                            break; 
0425E:  GOTO   6362
....................                         } 
....................                         case MimeSetTimeOutACKServer: 
....................                         { 
....................                            if(Msg_Data[1] == 4) 
04262:  MOVF   x95,W
04264:  SUBLW  04
04266:  BNZ   42D0
....................                            { 
....................                               unsigned int32 valor = make32(Msg_Data[2],Msg_Data[3],Msg_Data[4],Msg_Data[5]); 
04268:  MOVFF  96,52A
0426C:  MOVFF  97,529
04270:  MOVFF  98,528
04274:  MOVFF  99,527
....................                               GoIOXstatus.p_timeOutACKFromServer = valor; 
04278:  MOVFF  52A,81
0427C:  MOVFF  529,80
04280:  MOVFF  528,7F
04284:  MOVFF  527,7E
....................                               ////fprintf(Serial,"TOut Server ACK= %lu %c%c",GoIOXstatus.p_timeOutACKFromServer,0x1f,0x03); 
....................                               unsigned int8 buf[4]; 
....................                               buf[0] = GoIOXstatus.p_timeOutACKFromServer >> 0 & 0xFF; 
04288:  MOVFF  81,6C9
0428C:  MOVFF  80,6C8
04290:  MOVFF  7F,6C7
04294:  MOVFF  7E,52B
04298:  MOVLB  5
....................                               buf[1] = GoIOXstatus.p_timeOutACKFromServer >> 8 & 0xFF; 
0429A:  MOVFF  7F,52C
0429E:  MOVFF  80,6C7
042A2:  MOVFF  81,6C8
042A6:  MOVLB  5
....................                               buf[2] = GoIOXstatus.p_timeOutACKFromServer >> 16 & 0xFF; 
042A8:  MOVFF  80,52D
042AC:  MOVFF  81,6C7
042B0:  MOVLB  5
....................                               buf[3] = GoIOXstatus.p_timeOutACKFromServer >> 24 & 0xFF; 
042B2:  MOVFF  81,52E
042B6:  MOVLB  5
....................                               SentFormatMIMEPacket(MimeGetTimeOutACKServer, 4, &buf[0]); 
042B8:  MOVLW  A6
042BA:  MOVLB  6
042BC:  MOVWF  xC5
042BE:  MOVLW  04
042C0:  MOVWF  xC6
042C2:  MOVLW  05
042C4:  MOVWF  xC8
042C6:  MOVLW  2B
042C8:  MOVWF  xC7
042CA:  MOVLB  0
042CC:  CALL   1A92
....................                            } 
....................                            break; 
042D0:  GOTO   6362
....................                         } 
....................                         case MimeGetTimeOutACKServer: 
....................                         { 
....................                            unsigned int8 buf[4]; 
....................                            buf[0] = GoIOXstatus.p_timeOutACKFromServer >> 0 & 0xFF; 
042D4:  MOVFF  81,6C9
042D8:  MOVFF  80,6C8
042DC:  MOVFF  7F,6C7
042E0:  MOVFF  7E,52F
042E4:  MOVLB  5
....................                            buf[1] = GoIOXstatus.p_timeOutACKFromServer >> 8 & 0xFF; 
042E6:  MOVFF  7F,530
042EA:  MOVFF  80,6C7
042EE:  MOVFF  81,6C8
042F2:  MOVLB  5
....................                            buf[2] = GoIOXstatus.p_timeOutACKFromServer >> 16 & 0xFF; 
042F4:  MOVFF  80,531
042F8:  MOVFF  81,6C7
042FC:  MOVLB  5
....................                            buf[3] = GoIOXstatus.p_timeOutACKFromServer >> 24 & 0xFF; 
042FE:  MOVFF  81,532
04302:  MOVLB  5
....................                            SentFormatMIMEPacket(MimeGetTimeOutACKServer, 4, &buf[0]); 
04304:  MOVLW  A6
04306:  MOVLB  6
04308:  MOVWF  xC5
0430A:  MOVLW  04
0430C:  MOVWF  xC6
0430E:  MOVLW  05
04310:  MOVWF  xC8
04312:  MOVLW  2F
04314:  MOVWF  xC7
04316:  MOVLB  0
04318:  CALL   1A92
....................                            break; 
0431C:  GOTO   6362
....................                         } 
....................                         case MimeSetMaxMimes: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
04320:  MOVF   x95,W
04322:  SUBLW  02
04324:  BNZ   435A
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
04326:  MOVFF  96,534
0432A:  MOVFF  97,533
....................                               GoIOXstatus.maxMIMEs = valor; 
0432E:  MOVFF  534,55
04332:  MOVFF  533,54
....................                               ////fprintf(Serial,"Max Mimes Allowed= %lu %c%c",GoIOXstatus.maxMIMEs,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = GoIOXstatus.maxMIMEs >> 0 & 0xFF; 
04336:  MOVFF  54,535
0433A:  MOVLB  5
....................                               buf[1] = GoIOXstatus.maxMIMEs >> 8 & 0xFF; 
0433C:  MOVFF  55,536
04340:  MOVLB  5
....................                               SentFormatMIMEPacket(MimeGetMaxMimes, 2, &buf[0]); 
04342:  MOVLW  A8
04344:  MOVLB  6
04346:  MOVWF  xC5
04348:  MOVLW  02
0434A:  MOVWF  xC6
0434C:  MOVLW  05
0434E:  MOVWF  xC8
04350:  MOVLW  35
04352:  MOVWF  xC7
04354:  MOVLB  0
04356:  CALL   1A92
....................                            } 
....................                            break; 
0435A:  GOTO   6362
....................                         } 
....................                         case MimeGetMaxMimes: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = GoIOXstatus.maxMIMEs >> 0 & 0xFF; 
0435E:  MOVFF  54,537
04362:  MOVLB  5
....................                            buf[1] = GoIOXstatus.maxMIMEs >> 8 & 0xFF; 
04364:  MOVFF  55,538
04368:  MOVLB  5
....................                            SentFormatMIMEPacket(MimeGetMaxMimes, 2, &buf[0]); 
0436A:  MOVLW  A8
0436C:  MOVLB  6
0436E:  MOVWF  xC5
04370:  MOVLW  02
04372:  MOVWF  xC6
04374:  MOVLW  05
04376:  MOVWF  xC8
04378:  MOVLW  37
0437A:  MOVWF  xC7
0437C:  MOVLB  0
0437E:  CALL   1A92
....................                            break; 
04382:  GOTO   6362
....................                         } 
....................                         case MimeSetEnableOut: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
04386:  MOVF   x95,W
04388:  SUBLW  04
0438A:  BNZ   43C6
0438C:  MOVF   x96,W
0438E:  SUBLW  25
04390:  BNZ   43C6
04392:  MOVF   x97,W
04394:  SUBLW  33
04396:  BNZ   43C6
04398:  MOVF   x98,W
0439A:  SUBLW  41
0439C:  BNZ   43C6
0439E:  MOVF   x99,W
043A0:  SUBLW  49
043A2:  BNZ   43C6
....................                            { 
....................                               AllowedFuntions.MIMEout    = true; 
043A4:  BSF    20.3
....................                               ////fprintf(Serial,"Mime Out Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
043A6:  MOVLW  01
043A8:  MOVLB  5
043AA:  MOVWF  x39
....................                               SentFormatMIMEPacket(MimeGetEnableOut, 1, &buf[0]); 
043AC:  MOVLW  AA
043AE:  MOVLB  6
043B0:  MOVWF  xC5
043B2:  MOVLW  01
043B4:  MOVWF  xC6
043B6:  MOVLW  05
043B8:  MOVWF  xC8
043BA:  MOVLW  39
043BC:  MOVWF  xC7
043BE:  MOVLB  0
043C0:  CALL   1A92
....................                            } 
043C4:  BRA    4402
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
043C6:  MOVF   x95,W
043C8:  SUBLW  04
043CA:  BNZ   4402
043CC:  MOVF   x96,W
043CE:  SUBLW  25
043D0:  BNZ   4402
043D2:  MOVF   x97,W
043D4:  SUBLW  28
043D6:  BNZ   4402
043D8:  MOVF   x98,W
043DA:  SUBLW  31
043DC:  BNZ   4402
043DE:  MOVF   x99,W
043E0:  SUBLW  34
043E2:  BNZ   4402
....................                            { 
....................                               AllowedFuntions.MIMEout    = false; 
043E4:  BCF    20.3
....................                               ////fprintf(Serial,"Mime Out Not Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
043E6:  MOVLB  5
043E8:  CLRF   x3A
....................                               SentFormatMIMEPacket(MimeGetEnableOut, 1, &buf[0]); 
043EA:  MOVLW  AA
043EC:  MOVLB  6
043EE:  MOVWF  xC5
043F0:  MOVLW  01
043F2:  MOVWF  xC6
043F4:  MOVLW  05
043F6:  MOVWF  xC8
043F8:  MOVLW  3A
043FA:  MOVWF  xC7
043FC:  MOVLB  0
043FE:  CALL   1A92
....................                            } 
....................                            break; 
04402:  GOTO   6362
....................                         } 
....................                         case MimeGetEnableOut: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.MIMEout; 
04406:  MOVLB  5
04408:  CLRF   x3B
0440A:  BTFSC  20.3
0440C:  INCF   x3B,F
....................                            SentFormatMIMEPacket(MimeGetEnableOut, 1, &buf[0]); 
0440E:  MOVLW  AA
04410:  MOVLB  6
04412:  MOVWF  xC5
04414:  MOVLW  01
04416:  MOVWF  xC6
04418:  MOVLW  05
0441A:  MOVWF  xC8
0441C:  MOVLW  3B
0441E:  MOVWF  xC7
04420:  MOVLB  0
04422:  CALL   1A92
....................                            break; 
04426:  GOTO   6362
....................                         } 
....................                         case MimeSetEnableIn: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
0442A:  MOVF   x95,W
0442C:  SUBLW  04
0442E:  BNZ   446A
04430:  MOVF   x96,W
04432:  SUBLW  25
04434:  BNZ   446A
04436:  MOVF   x97,W
04438:  SUBLW  33
0443A:  BNZ   446A
0443C:  MOVF   x98,W
0443E:  SUBLW  41
04440:  BNZ   446A
04442:  MOVF   x99,W
04444:  SUBLW  49
04446:  BNZ   446A
....................                            { 
....................                               AllowedFuntions.MIMEin    = true; 
04448:  BSF    20.2
....................                               ////fprintf(Serial,"Mime In Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
0444A:  MOVLW  01
0444C:  MOVLB  5
0444E:  MOVWF  x3C
....................                               SentFormatMIMEPacket(MimeGetEnableIn, 1, &buf[0]); 
04450:  MOVLW  AC
04452:  MOVLB  6
04454:  MOVWF  xC5
04456:  MOVLW  01
04458:  MOVWF  xC6
0445A:  MOVLW  05
0445C:  MOVWF  xC8
0445E:  MOVLW  3C
04460:  MOVWF  xC7
04462:  MOVLB  0
04464:  CALL   1A92
....................                            } 
04468:  BRA    44A6
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
0446A:  MOVF   x95,W
0446C:  SUBLW  04
0446E:  BNZ   44A6
04470:  MOVF   x96,W
04472:  SUBLW  25
04474:  BNZ   44A6
04476:  MOVF   x97,W
04478:  SUBLW  28
0447A:  BNZ   44A6
0447C:  MOVF   x98,W
0447E:  SUBLW  31
04480:  BNZ   44A6
04482:  MOVF   x99,W
04484:  SUBLW  34
04486:  BNZ   44A6
....................                            { 
....................                               AllowedFuntions.MIMEin    = false; 
04488:  BCF    20.2
....................                               ////fprintf(Serial,"Mime In Not Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
0448A:  MOVLB  5
0448C:  CLRF   x3D
....................                               SentFormatMIMEPacket(MimeGetEnableIn, 1, &buf[0]); 
0448E:  MOVLW  AC
04490:  MOVLB  6
04492:  MOVWF  xC5
04494:  MOVLW  01
04496:  MOVWF  xC6
04498:  MOVLW  05
0449A:  MOVWF  xC8
0449C:  MOVLW  3D
0449E:  MOVWF  xC7
044A0:  MOVLB  0
044A2:  CALL   1A92
....................                            } 
....................                            break; 
044A6:  GOTO   6362
....................                         } 
....................                         case MimeGetEnableIn: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.MIMEin; 
044AA:  MOVLB  5
044AC:  CLRF   x3E
044AE:  BTFSC  20.2
044B0:  INCF   x3E,F
....................                            SentFormatMIMEPacket(MimeGetEnableIn, 1, &buf[0]); 
044B2:  MOVLW  AC
044B4:  MOVLB  6
044B6:  MOVWF  xC5
044B8:  MOVLW  01
044BA:  MOVWF  xC6
044BC:  MOVLW  05
044BE:  MOVWF  xC8
044C0:  MOVLW  3E
044C2:  MOVWF  xC7
044C4:  MOVLB  0
044C6:  CALL   1A92
....................                            break; 
044CA:  GOTO   6362
....................                         } 
....................                         case MimeSetMsgACKFromServer: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
044CE:  MOVF   x95,W
044D0:  SUBLW  04
044D2:  BNZ   450E
044D4:  MOVF   x96,W
044D6:  SUBLW  25
044D8:  BNZ   450E
044DA:  MOVF   x97,W
044DC:  SUBLW  33
044DE:  BNZ   450E
044E0:  MOVF   x98,W
044E2:  SUBLW  41
044E4:  BNZ   450E
044E6:  MOVF   x99,W
044E8:  SUBLW  49
044EA:  BNZ   450E
....................                            { 
....................                               AllowedFuntions.MimeACKResponse   = true; 
044EC:  BSF    20.4
....................                               ////fprintf(Serial,"ACK Response Required%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
044EE:  MOVLW  01
044F0:  MOVLB  5
044F2:  MOVWF  x3F
....................                               SentFormatMIMEPacket(MimeGetMsgACKFromServer, 1, &buf[0]); 
044F4:  MOVLW  AE
044F6:  MOVLB  6
044F8:  MOVWF  xC5
044FA:  MOVLW  01
044FC:  MOVWF  xC6
044FE:  MOVLW  05
04500:  MOVWF  xC8
04502:  MOVLW  3F
04504:  MOVWF  xC7
04506:  MOVLB  0
04508:  CALL   1A92
....................                            } 
0450C:  BRA    454A
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
0450E:  MOVF   x95,W
04510:  SUBLW  04
04512:  BNZ   454A
04514:  MOVF   x96,W
04516:  SUBLW  25
04518:  BNZ   454A
0451A:  MOVF   x97,W
0451C:  SUBLW  28
0451E:  BNZ   454A
04520:  MOVF   x98,W
04522:  SUBLW  31
04524:  BNZ   454A
04526:  MOVF   x99,W
04528:  SUBLW  34
0452A:  BNZ   454A
....................                            { 
....................                               AllowedFuntions.MimeACKResponse    = false; 
0452C:  BCF    20.4
....................                               ////fprintf(Serial,"ACK Response Not Required%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
0452E:  MOVLB  5
04530:  CLRF   x40
....................                               SentFormatMIMEPacket(MimeGetMsgACKFromServer, 1, &buf[0]); 
04532:  MOVLW  AE
04534:  MOVLB  6
04536:  MOVWF  xC5
04538:  MOVLW  01
0453A:  MOVWF  xC6
0453C:  MOVLW  05
0453E:  MOVWF  xC8
04540:  MOVLW  40
04542:  MOVWF  xC7
04544:  MOVLB  0
04546:  CALL   1A92
....................                            } 
....................                            break; 
0454A:  GOTO   6362
....................                         } 
....................                         case MimeGetMsgACKFromServer: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.MimeACKResponse; 
0454E:  MOVLB  5
04550:  CLRF   x41
04552:  BTFSC  20.4
04554:  INCF   x41,F
....................                            SentFormatMIMEPacket(MimeGetMsgACKFromServer, 1, &buf[0]); 
04556:  MOVLW  AE
04558:  MOVLB  6
0455A:  MOVWF  xC5
0455C:  MOVLW  01
0455E:  MOVWF  xC6
04560:  MOVLW  05
04562:  MOVWF  xC8
04564:  MOVLW  41
04566:  MOVWF  xC7
04568:  MOVLB  0
0456A:  CALL   1A92
....................                            break; 
0456E:  GOTO   6362
....................                         } 
....................                         case MimeSetWaitACKFromServer: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
04572:  MOVF   x95,W
04574:  SUBLW  04
04576:  BNZ   45B2
04578:  MOVF   x96,W
0457A:  SUBLW  25
0457C:  BNZ   45B2
0457E:  MOVF   x97,W
04580:  SUBLW  33
04582:  BNZ   45B2
04584:  MOVF   x98,W
04586:  SUBLW  41
04588:  BNZ   45B2
0458A:  MOVF   x99,W
0458C:  SUBLW  49
0458E:  BNZ   45B2
....................                            { 
....................                               AllowedFuntions.blockMIMEByACK   = true; 
04590:  BSF    21.0
....................                               ////fprintf(Serial,"ACK Response Required%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
04592:  MOVLW  01
04594:  MOVLB  5
04596:  MOVWF  x42
....................                               SentFormatMIMEPacket(MimeGetWaitACKFromServer, 1, &buf[0]); 
04598:  MOVLW  A0
0459A:  MOVLB  6
0459C:  MOVWF  xC5
0459E:  MOVLW  01
045A0:  MOVWF  xC6
045A2:  MOVLW  05
045A4:  MOVWF  xC8
045A6:  MOVLW  42
045A8:  MOVWF  xC7
045AA:  MOVLB  0
045AC:  CALL   1A92
....................                            } 
045B0:  BRA    45EE
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
045B2:  MOVF   x95,W
045B4:  SUBLW  04
045B6:  BNZ   45EE
045B8:  MOVF   x96,W
045BA:  SUBLW  25
045BC:  BNZ   45EE
045BE:  MOVF   x97,W
045C0:  SUBLW  28
045C2:  BNZ   45EE
045C4:  MOVF   x98,W
045C6:  SUBLW  31
045C8:  BNZ   45EE
045CA:  MOVF   x99,W
045CC:  SUBLW  34
045CE:  BNZ   45EE
....................                            { 
....................                               AllowedFuntions.blockMIMEByACK    = false; 
045D0:  BCF    21.0
....................                               ////fprintf(Serial,"ACK Response Not Required%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
045D2:  MOVLB  5
045D4:  CLRF   x43
....................                               SentFormatMIMEPacket(MimeGetWaitACKFromServer, 1, &buf[0]); 
045D6:  MOVLW  A0
045D8:  MOVLB  6
045DA:  MOVWF  xC5
045DC:  MOVLW  01
045DE:  MOVWF  xC6
045E0:  MOVLW  05
045E2:  MOVWF  xC8
045E4:  MOVLW  43
045E6:  MOVWF  xC7
045E8:  MOVLB  0
045EA:  CALL   1A92
....................                            } 
....................                            break; 
045EE:  GOTO   6362
....................                         } 
....................                         case MimeGetWaitACKFromServer: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.blockMIMEByACK; 
045F2:  MOVLB  5
045F4:  CLRF   x44
045F6:  BTFSC  21.0
045F8:  INCF   x44,F
....................                            SentFormatMIMEPacket(MimeGetWaitACKFromServer, 1, &buf[0]); 
045FA:  MOVLW  A0
045FC:  MOVLB  6
045FE:  MOVWF  xC5
04600:  MOVLW  01
04602:  MOVWF  xC6
04604:  MOVLW  05
04606:  MOVWF  xC8
04608:  MOVLW  44
0460A:  MOVWF  xC7
0460C:  MOVLB  0
0460E:  CALL   1A92
....................                            break; 
04612:  GOTO   6362
....................                         } 
....................                         case CSSetTimeOut: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
04616:  MOVF   x95,W
04618:  SUBLW  02
0461A:  BNZ   4650
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
0461C:  MOVFF  96,546
04620:  MOVFF  97,545
....................                               GoIOXstatus.p_timeOutCustom = valor; 
04624:  MOVFF  546,5D
04628:  MOVFF  545,5C
....................                               ////fprintf(Serial,"TOut Custom ACK= %lu %c%c",GoIOXstatus.p_timeOutCustom,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = GoIOXstatus.p_timeOutCustom >> 0 & 0xFF; 
0462C:  MOVFF  5C,547
04630:  MOVLB  5
....................                               buf[1] = GoIOXstatus.p_timeOutCustom >> 8 & 0xFF; 
04632:  MOVFF  5D,548
04636:  MOVLB  5
....................                               SentFormatMIMEPacket(CSGetTimeOut, 2, &buf[0]); 
04638:  MOVLW  B1
0463A:  MOVLB  6
0463C:  MOVWF  xC5
0463E:  MOVLW  02
04640:  MOVWF  xC6
04642:  MOVLW  05
04644:  MOVWF  xC8
04646:  MOVLW  47
04648:  MOVWF  xC7
0464A:  MOVLB  0
0464C:  CALL   1A92
....................                            } 
....................                            break; 
04650:  GOTO   6362
....................                         } 
....................                         case CSGetTimeOut: 
....................                         { 
....................                            unsigned int8 buf[4]; 
....................                            buf[0] = GoIOXstatus.p_timeOutCustom >> 0 & 0xFF; 
04654:  MOVFF  5C,549
04658:  MOVLB  5
....................                            buf[1] = GoIOXstatus.p_timeOutCustom >> 8 & 0xFF; 
0465A:  MOVFF  5D,54A
0465E:  MOVLB  5
....................                            SentFormatMIMEPacket(CSGetTimeOut, 4, &buf[0]); 
04660:  MOVLW  B1
04662:  MOVLB  6
04664:  MOVWF  xC5
04666:  MOVLW  04
04668:  MOVWF  xC6
0466A:  MOVLW  05
0466C:  MOVWF  xC8
0466E:  MOVLW  49
04670:  MOVWF  xC7
04672:  MOVLB  0
04674:  CALL   1A92
....................                            break; 
04678:  GOTO   6362
....................                         } 
....................                         case CSSetMaxCustoms: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
0467C:  MOVF   x95,W
0467E:  SUBLW  02
04680:  BNZ   46BA
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
04682:  MOVFF  96,54E
04686:  MOVFF  97,54D
....................                               GoIOXstatus.maxCustoms = valor; 
0468A:  MOVFF  54E,65
0468E:  MOVFF  54D,64
....................                               ////fprintf(Serial,"Max Customs Allowed= %lu %c%c",GoIOXstatus.maxCustoms,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = GoIOXstatus.maxCustoms >> 0 & 0xFF; 
04692:  MOVFF  65,6C6
04696:  MOVFF  64,54F
0469A:  MOVLB  5
....................                               buf[1] = GoIOXstatus.maxCustoms >> 8 & 0xFF; 
0469C:  MOVFF  65,550
046A0:  MOVLB  5
....................                               SentFormatMIMEPacket(CSGatMaxCustoms, 2, &buf[0]); 
046A2:  MOVLW  B3
046A4:  MOVLB  6
046A6:  MOVWF  xC5
046A8:  MOVLW  02
046AA:  MOVWF  xC6
046AC:  MOVLW  05
046AE:  MOVWF  xC8
046B0:  MOVLW  4F
046B2:  MOVWF  xC7
046B4:  MOVLB  0
046B6:  CALL   1A92
....................                            } 
....................                            break; 
046BA:  GOTO   6362
....................                         } 
....................                         case CSGatMaxCustoms: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = GoIOXstatus.maxCustoms >> 0 & 0xFF; 
046BE:  MOVFF  65,6C6
046C2:  MOVFF  64,551
046C6:  MOVLB  5
....................                            buf[1] = GoIOXstatus.maxCustoms >> 8 & 0xFF; 
046C8:  MOVFF  65,552
046CC:  MOVLB  5
....................                            SentFormatMIMEPacket(CSGatMaxCustoms, 2, &buf[0]); 
046CE:  MOVLW  B3
046D0:  MOVLB  6
046D2:  MOVWF  xC5
046D4:  MOVLW  02
046D6:  MOVWF  xC6
046D8:  MOVLW  05
046DA:  MOVWF  xC8
046DC:  MOVLW  51
046DE:  MOVWF  xC7
046E0:  MOVLB  0
046E2:  CALL   1A92
....................                            break; 
046E6:  GOTO   6362
....................                         } 
....................                         case CSSetAllowedCustoms: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
046EA:  MOVF   x95,W
046EC:  SUBLW  04
046EE:  BNZ   472A
046F0:  MOVF   x96,W
046F2:  SUBLW  25
046F4:  BNZ   472A
046F6:  MOVF   x97,W
046F8:  SUBLW  33
046FA:  BNZ   472A
046FC:  MOVF   x98,W
046FE:  SUBLW  41
04700:  BNZ   472A
04702:  MOVF   x99,W
04704:  SUBLW  49
04706:  BNZ   472A
....................                            { 
....................                               AllowedFuntions.customData = true; 
04708:  BSF    20.0
....................                               //fprintf(Serial,"Customs Data Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
0470A:  MOVLW  01
0470C:  MOVLB  5
0470E:  MOVWF  x53
....................                               SentFormatMIMEPacket(CSGetAllowedCustoms, 1, &buf[0]); 
04710:  MOVLW  B5
04712:  MOVLB  6
04714:  MOVWF  xC5
04716:  MOVLW  01
04718:  MOVWF  xC6
0471A:  MOVLW  05
0471C:  MOVWF  xC8
0471E:  MOVLW  53
04720:  MOVWF  xC7
04722:  MOVLB  0
04724:  CALL   1A92
....................                            } 
04728:  BRA    4766
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
0472A:  MOVF   x95,W
0472C:  SUBLW  04
0472E:  BNZ   4766
04730:  MOVF   x96,W
04732:  SUBLW  25
04734:  BNZ   4766
04736:  MOVF   x97,W
04738:  SUBLW  28
0473A:  BNZ   4766
0473C:  MOVF   x98,W
0473E:  SUBLW  31
04740:  BNZ   4766
04742:  MOVF   x99,W
04744:  SUBLW  34
04746:  BNZ   4766
....................                            { 
....................                               AllowedFuntions.customData = false; 
04748:  BCF    20.0
....................                               //fprintf(Serial,"Custom Data Not Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
0474A:  MOVLB  5
0474C:  CLRF   x54
....................                               SentFormatMIMEPacket(CSGetAllowedCustoms, 1, &buf[0]); 
0474E:  MOVLW  B5
04750:  MOVLB  6
04752:  MOVWF  xC5
04754:  MOVLW  01
04756:  MOVWF  xC6
04758:  MOVLW  05
0475A:  MOVWF  xC8
0475C:  MOVLW  54
0475E:  MOVWF  xC7
04760:  MOVLB  0
04762:  CALL   1A92
....................                            } 
....................                            break; 
04766:  GOTO   6362
....................                         } 
....................                         case CSGetAllowedCustoms: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.customData; 
0476A:  MOVLB  5
0476C:  CLRF   x55
0476E:  BTFSC  20.0
04770:  INCF   x55,F
....................                            SentFormatMIMEPacket(CSGetAllowedCustoms, 1, &buf[0]); 
04772:  MOVLW  B5
04774:  MOVLB  6
04776:  MOVWF  xC5
04778:  MOVLW  01
0477A:  MOVWF  xC6
0477C:  MOVLW  05
0477E:  MOVWF  xC8
04780:  MOVLW  55
04782:  MOVWF  xC7
04784:  MOVLB  0
04786:  CALL   1A92
....................                            break; 
0478A:  GOTO   6362
....................                         } 
....................                         case CSSetAllowedStatusData: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
0478E:  MOVF   x95,W
04790:  SUBLW  04
04792:  BNZ   47CE
04794:  MOVF   x96,W
04796:  SUBLW  25
04798:  BNZ   47CE
0479A:  MOVF   x97,W
0479C:  SUBLW  33
0479E:  BNZ   47CE
047A0:  MOVF   x98,W
047A2:  SUBLW  41
047A4:  BNZ   47CE
047A6:  MOVF   x99,W
047A8:  SUBLW  49
047AA:  BNZ   47CE
....................                            { 
....................                               AllowedFuntions.StatusData = true; 
047AC:  BSF    20.1
....................                               //fprintf(Serial,"Status Data Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 1; 
047AE:  MOVLW  01
047B0:  MOVLB  5
047B2:  MOVWF  x56
....................                               SentFormatMIMEPacket(CSGetAllowedStatusData, 1, &buf[0]); 
047B4:  MOVLW  B7
047B6:  MOVLB  6
047B8:  MOVWF  xC5
047BA:  MOVLW  01
047BC:  MOVWF  xC6
047BE:  MOVLW  05
047C0:  MOVWF  xC8
047C2:  MOVLW  56
047C4:  MOVWF  xC7
047C6:  MOVLB  0
047C8:  CALL   1A92
....................                            } 
047CC:  BRA    480A
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
047CE:  MOVF   x95,W
047D0:  SUBLW  04
047D2:  BNZ   480A
047D4:  MOVF   x96,W
047D6:  SUBLW  25
047D8:  BNZ   480A
047DA:  MOVF   x97,W
047DC:  SUBLW  28
047DE:  BNZ   480A
047E0:  MOVF   x98,W
047E2:  SUBLW  31
047E4:  BNZ   480A
047E6:  MOVF   x99,W
047E8:  SUBLW  34
047EA:  BNZ   480A
....................                            { 
....................                               AllowedFuntions.StatusData = false; 
047EC:  BCF    20.1
....................                               //fprintf(Serial,"Status Data Not Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = 0; 
047EE:  MOVLB  5
047F0:  CLRF   x57
....................                               SentFormatMIMEPacket(CSGetAllowedStatusData, 1, &buf[0]); 
047F2:  MOVLW  B7
047F4:  MOVLB  6
047F6:  MOVWF  xC5
047F8:  MOVLW  01
047FA:  MOVWF  xC6
047FC:  MOVLW  05
047FE:  MOVWF  xC8
04800:  MOVLW  57
04802:  MOVWF  xC7
04804:  MOVLB  0
04806:  CALL   1A92
....................                            } 
....................                            break; 
0480A:  GOTO   6362
....................                         } 
....................                         case CSGetAllowedStatusData: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.StatusData; 
0480E:  MOVLB  5
04810:  CLRF   x58
04812:  BTFSC  20.1
04814:  INCF   x58,F
....................                            SentFormatMIMEPacket(CSGetAllowedStatusData, 1, &buf[0]); 
04816:  MOVLW  B7
04818:  MOVLB  6
0481A:  MOVWF  xC5
0481C:  MOVLW  01
0481E:  MOVWF  xC6
04820:  MOVLW  05
04822:  MOVWF  xC8
04824:  MOVLW  58
04826:  MOVWF  xC7
04828:  MOVLB  0
0482A:  CALL   1A92
....................                            break; 
0482E:  GOTO   6362
....................                         } 
....................                         case ActSetMode: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
04832:  MOVF   x95,W
04834:  SUBLW  04
04836:  BNZ   4874
04838:  MOVF   x96,W
0483A:  SUBLW  25
0483C:  BNZ   4874
0483E:  MOVF   x97,W
04840:  SUBLW  33
04842:  BNZ   4874
04844:  MOVF   x98,W
04846:  SUBLW  41
04848:  BNZ   4874
0484A:  MOVF   x99,W
0484C:  SUBLW  49
0484E:  BNZ   4874
....................                            { 
....................                               Actuator.OutputMode = ActuadorONOFF; 
04850:  MOVLW  03
04852:  MOVLB  2
04854:  MOVWF  xA6
....................                               //fprintf(Serial,"Actuator as Output%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = Actuator.OutputMode; 
04856:  MOVFF  2A6,559
....................                               SentFormatMIMEPacket(ActGetMode, 1, &buf[0]); 
0485A:  MOVLW  C1
0485C:  MOVLB  6
0485E:  MOVWF  xC5
04860:  MOVLW  01
04862:  MOVWF  xC6
04864:  MOVLW  05
04866:  MOVWF  xC8
04868:  MOVLW  59
0486A:  MOVWF  xC7
0486C:  MOVLB  0
0486E:  CALL   1A92
....................                            } 
04872:  BRA    48B4
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
04874:  MOVF   x95,W
04876:  SUBLW  04
04878:  BNZ   48B4
0487A:  MOVF   x96,W
0487C:  SUBLW  25
0487E:  BNZ   48B4
04880:  MOVF   x97,W
04882:  SUBLW  28
04884:  BNZ   48B4
04886:  MOVF   x98,W
04888:  SUBLW  31
0488A:  BNZ   48B4
0488C:  MOVF   x99,W
0488E:  SUBLW  34
04890:  BNZ   48B4
....................                            { 
....................                               Actuator.OutputMode = ActuadorTemporizado; 
04892:  MOVLW  05
04894:  MOVLB  2
04896:  MOVWF  xA6
....................                               //fprintf(Serial,"Actuator as Timed Output%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = Actuator.OutputMode; 
04898:  MOVFF  2A6,55A
....................                               SentFormatMIMEPacket(ActGetMode, 1, &buf[0]); 
0489C:  MOVLW  C1
0489E:  MOVLB  6
048A0:  MOVWF  xC5
048A2:  MOVLW  01
048A4:  MOVWF  xC6
048A6:  MOVLW  05
048A8:  MOVWF  xC8
048AA:  MOVLW  5A
048AC:  MOVWF  xC7
048AE:  MOVLB  0
048B0:  CALL   1A92
....................                            } 
....................                            break; 
048B4:  GOTO   6362
....................                         } 
....................                         case ActGetMode: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = Actuator.OutputMode; 
048B8:  MOVFF  2A6,55B
....................                            SentFormatMIMEPacket(ActGetMode, 1, &buf[0]); 
048BC:  MOVLW  C1
048BE:  MOVLB  6
048C0:  MOVWF  xC5
048C2:  MOVLW  01
048C4:  MOVWF  xC6
048C6:  MOVLW  05
048C8:  MOVWF  xC8
048CA:  MOVLW  5B
048CC:  MOVWF  xC7
048CE:  MOVLB  0
048D0:  CALL   1A92
....................                            break; 
048D4:  GOTO   6362
....................                         } 
....................                         case ActSetConfigTimedOutput: 
....................                         { 
....................                            if(Msg_Data[1] == 8) 
048D8:  MOVF   x95,W
048DA:  SUBLW  08
048DC:  BNZ   4996
....................                            { 
....................                               unsigned int32 toReset = make32(Msg_Data[2],Msg_Data[3],Msg_Data[4],Msg_Data[5]); 
....................                               unsigned int32 inReset = make32(Msg_Data[6],Msg_Data[7],Msg_Data[8],Msg_Data[9]); 
048DE:  MOVFF  96,55F
048E2:  MOVFF  97,55E
048E6:  MOVFF  98,55D
048EA:  MOVFF  99,55C
048EE:  MOVFF  9A,563
048F2:  MOVFF  9B,562
048F6:  MOVFF  9C,561
048FA:  MOVFF  9D,560
....................                               Actuator.TimeInReset = inReset; 
048FE:  MOVFF  563,29C
04902:  MOVFF  562,29B
04906:  MOVFF  561,29A
0490A:  MOVFF  560,299
....................                               Actuator.TimeToReset = toReset; 
0490E:  MOVFF  55F,2A0
04912:  MOVFF  55E,29F
04916:  MOVFF  55D,29E
0491A:  MOVFF  55C,29D
....................                               //fprintf(Serial,"Act. toReset= %lu, inReset%lu %c%c",Actuator.TimeToReset,Actuator.TimeInReset,0x1f,0x03); 
....................                               unsigned int8 buf[8]; 
....................                               buf[0] = Actuator.TimeToReset >> 0 & 0xFF; 
0491E:  MOVFF  2A0,6C9
04922:  MOVFF  29F,6C8
04926:  MOVFF  29E,6C7
0492A:  MOVFF  29D,564
0492E:  MOVLB  5
....................                               buf[1] = Actuator.TimeToReset >> 8 & 0xFF; 
04930:  MOVFF  29E,565
04934:  MOVFF  29F,6C7
04938:  MOVFF  2A0,6C8
0493C:  MOVLB  5
....................                               buf[2] = Actuator.TimeToReset >> 16 & 0xFF; 
0493E:  MOVFF  29F,566
04942:  MOVFF  2A0,6C7
04946:  MOVLB  5
....................                               buf[3] = Actuator.TimeToReset >> 24 & 0xFF; 
04948:  MOVFF  2A0,567
0494C:  MOVLB  5
....................                               buf[4] = Actuator.TimeInReset >> 0 & 0xFF; 
0494E:  MOVFF  29C,6C9
04952:  MOVFF  29B,6C8
04956:  MOVFF  29A,6C7
0495A:  MOVFF  299,568
0495E:  MOVLB  5
....................                               buf[5] = Actuator.TimeInReset >> 8 & 0xFF; 
04960:  MOVFF  29A,569
04964:  MOVFF  29B,6C7
04968:  MOVFF  29C,6C8
0496C:  MOVLB  5
....................                               buf[6] = Actuator.TimeInReset >> 16 & 0xFF; 
0496E:  MOVFF  29B,56A
04972:  MOVFF  29C,6C7
04976:  MOVLB  5
....................                               buf[7] = Actuator.TimeInReset >> 24 & 0xFF; 
04978:  MOVFF  29C,56B
0497C:  MOVLB  5
....................                               SentFormatMIMEPacket(ActGetConfigTimedOutput, 8, &buf[0]); 
0497E:  MOVLW  C3
04980:  MOVLB  6
04982:  MOVWF  xC5
04984:  MOVLW  08
04986:  MOVWF  xC6
04988:  MOVLW  05
0498A:  MOVWF  xC8
0498C:  MOVLW  64
0498E:  MOVWF  xC7
04990:  MOVLB  0
04992:  CALL   1A92
....................                            } 
....................                            break; 
04996:  GOTO   6362
....................                         } 
....................                         case ActGetConfigTimedOutput: 
....................                         { 
....................                            unsigned int8 buf[8]; 
....................                            buf[0] = Actuator.TimeToReset >> 0 & 0xFF; 
0499A:  MOVFF  2A0,6C9
0499E:  MOVFF  29F,6C8
049A2:  MOVFF  29E,6C7
049A6:  MOVFF  29D,56C
049AA:  MOVLB  5
....................                            buf[1] = Actuator.TimeToReset >> 8 & 0xFF; 
049AC:  MOVFF  29E,56D
049B0:  MOVFF  29F,6C7
049B4:  MOVFF  2A0,6C8
049B8:  MOVLB  5
....................                            buf[2] = Actuator.TimeToReset >> 16 & 0xFF; 
049BA:  MOVFF  29F,56E
049BE:  MOVFF  2A0,6C7
049C2:  MOVLB  5
....................                            buf[3] = Actuator.TimeToReset >> 24 & 0xFF; 
049C4:  MOVFF  2A0,56F
049C8:  MOVLB  5
....................                            buf[4] = Actuator.TimeInReset >> 0 & 0xFF; 
049CA:  MOVFF  29C,6C9
049CE:  MOVFF  29B,6C8
049D2:  MOVFF  29A,6C7
049D6:  MOVFF  299,570
049DA:  MOVLB  5
....................                            buf[5] = Actuator.TimeInReset >> 8 & 0xFF; 
049DC:  MOVFF  29A,571
049E0:  MOVFF  29B,6C7
049E4:  MOVFF  29C,6C8
049E8:  MOVLB  5
....................                            buf[6] = Actuator.TimeInReset >> 16 & 0xFF; 
049EA:  MOVFF  29B,572
049EE:  MOVFF  29C,6C7
049F2:  MOVLB  5
....................                            buf[7] = Actuator.TimeInReset >> 24 & 0xFF; 
049F4:  MOVFF  29C,573
049F8:  MOVLB  5
....................                            SentFormatMIMEPacket(ActGetConfigTimedOutput, 8, &buf[0]); 
049FA:  MOVLW  C3
049FC:  MOVLB  6
049FE:  MOVWF  xC5
04A00:  MOVLW  08
04A02:  MOVWF  xC6
04A04:  MOVLW  05
04A06:  MOVWF  xC8
04A08:  MOVLW  6C
04A0A:  MOVWF  xC7
04A0C:  MOVLB  0
04A0E:  CALL   1A92
....................                            break; 
04A12:  GOTO   6362
....................                         } 
....................                         case ActSetTimeOutPass: 
....................                         { 
....................                            if(Msg_Data[1] == 4) 
04A16:  MOVF   x95,W
04A18:  SUBLW  04
04A1A:  BNZ   4A84
....................                            { 
....................                               unsigned int32 valor = make32(Msg_Data[2],Msg_Data[3],Msg_Data[4],Msg_Data[5]); 
04A1C:  MOVFF  96,577
04A20:  MOVFF  97,576
04A24:  MOVFF  98,575
04A28:  MOVFF  99,574
....................                               Actuator.P_TimeOutPass = valor; 
04A2C:  MOVFF  577,2AE
04A30:  MOVFF  576,2AD
04A34:  MOVFF  575,2AC
04A38:  MOVFF  574,2AB
....................                               //fprintf(Serial,"TOut Act PAss= %lu %c%c",Actuator.P_TimeOutPass,0x1f,0x03); 
....................                               unsigned int8 buf[4]; 
....................                               buf[0] = Actuator.P_TimeOutPass >> 0 & 0xFF; 
04A3C:  MOVFF  2AE,6C9
04A40:  MOVFF  2AD,6C8
04A44:  MOVFF  2AC,6C7
04A48:  MOVFF  2AB,578
04A4C:  MOVLB  5
....................                               buf[1] = Actuator.P_TimeOutPass >> 8 & 0xFF; 
04A4E:  MOVFF  2AC,579
04A52:  MOVFF  2AD,6C7
04A56:  MOVFF  2AE,6C8
04A5A:  MOVLB  5
....................                               buf[2] = Actuator.P_TimeOutPass >> 16 & 0xFF; 
04A5C:  MOVFF  2AD,57A
04A60:  MOVFF  2AE,6C7
04A64:  MOVLB  5
....................                               buf[3] = Actuator.P_TimeOutPass >> 24 & 0xFF; 
04A66:  MOVFF  2AE,57B
04A6A:  MOVLB  5
....................                               SentFormatMIMEPacket(ActGetTimeOutPass, 4, &buf[0]); 
04A6C:  MOVLW  C5
04A6E:  MOVLB  6
04A70:  MOVWF  xC5
04A72:  MOVLW  04
04A74:  MOVWF  xC6
04A76:  MOVLW  05
04A78:  MOVWF  xC8
04A7A:  MOVLW  78
04A7C:  MOVWF  xC7
04A7E:  MOVLB  0
04A80:  CALL   1A92
....................                            } 
....................                            break; 
04A84:  GOTO   6362
....................                         } 
....................                         case ActGetTimeOutPass: 
....................                         { 
....................                            unsigned int8 buf[4]; 
....................                               buf[0] = Actuator.P_TimeOutPass >> 0 & 0xFF; 
04A88:  MOVFF  2AE,6C9
04A8C:  MOVFF  2AD,6C8
04A90:  MOVFF  2AC,6C7
04A94:  MOVFF  2AB,57C
04A98:  MOVLB  5
....................                               buf[1] = Actuator.P_TimeOutPass >> 8 & 0xFF; 
04A9A:  MOVFF  2AC,57D
04A9E:  MOVFF  2AD,6C7
04AA2:  MOVFF  2AE,6C8
04AA6:  MOVLB  5
....................                               buf[2] = Actuator.P_TimeOutPass >> 16 & 0xFF; 
04AA8:  MOVFF  2AD,57E
04AAC:  MOVFF  2AE,6C7
04AB0:  MOVLB  5
....................                               buf[3] = Actuator.P_TimeOutPass >> 24 & 0xFF; 
04AB2:  MOVFF  2AE,57F
04AB6:  MOVLB  5
....................                               SentFormatMIMEPacket(ActGetTimeOutPass, 4, &buf[0]); 
04AB8:  MOVLW  C5
04ABA:  MOVLB  6
04ABC:  MOVWF  xC5
04ABE:  MOVLW  04
04AC0:  MOVWF  xC6
04AC2:  MOVLW  05
04AC4:  MOVWF  xC8
04AC6:  MOVLW  7C
04AC8:  MOVWF  xC7
04ACA:  MOVLB  0
04ACC:  CALL   1A92
....................                            break; 
04AD0:  GOTO   6362
....................                         } 
....................                         case ActSetOutput: 
....................                         { 
....................                            if(Actuator.OutputMode == ActuadorONOFF) 
04AD4:  MOVLB  2
04AD6:  MOVF   xA6,W
04AD8:  SUBLW  03
04ADA:  BTFSS  FD8.2
04ADC:  BRA    4BAE
....................                            { 
....................                               if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
04ADE:  MOVLB  0
04AE0:  MOVF   x95,W
04AE2:  SUBLW  04
04AE4:  BNZ   4B08
04AE6:  MOVF   x96,W
04AE8:  SUBLW  25
04AEA:  BNZ   4B08
04AEC:  MOVF   x97,W
04AEE:  SUBLW  33
04AF0:  BNZ   4B08
04AF2:  MOVF   x98,W
04AF4:  SUBLW  41
04AF6:  BNZ   4B08
04AF8:  MOVF   x99,W
04AFA:  SUBLW  49
04AFC:  BNZ   4B08
....................                               { 
....................                                  //fprintf(Serial,"Actuator ON requested%c%c",0x1f,0x03); 
....................                                  Actuator.LastPetition = ON; 
04AFE:  MOVLW  03
04B00:  MOVLB  2
04B02:  MOVWF  xA8
....................                               } 
04B04:  BRA    4B2C
04B06:  MOVLB  0
....................                               else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
04B08:  MOVF   x95,W
04B0A:  SUBLW  04
04B0C:  BNZ   4B2E
04B0E:  MOVF   x96,W
04B10:  SUBLW  25
04B12:  BNZ   4B2E
04B14:  MOVF   x97,W
04B16:  SUBLW  28
04B18:  BNZ   4B2E
04B1A:  MOVF   x98,W
04B1C:  SUBLW  31
04B1E:  BNZ   4B2E
04B20:  MOVF   x99,W
04B22:  SUBLW  34
04B24:  BNZ   4B2E
....................                               { 
....................                                  //fprintf(Serial,"Actuator OFF requested%c%c",0x1f,0x03); 
....................                                  Actuator.LastPetition = OFF; 
04B26:  MOVLW  04
04B28:  MOVLB  2
04B2A:  MOVWF  xA8
04B2C:  MOVLB  0
....................                               } 
....................                               srand(get_timer2()); 
04B2E:  MOVFF  FCC,6C5
04B32:  MOVLB  6
04B34:  CLRF   xC9
04B36:  CLRF   xC8
04B38:  CLRF   xC7
04B3A:  MOVFF  FCC,6C6
04B3E:  MOVLB  0
04B40:  CALL   22FE
....................                               unsigned int16 pass = 0; 
04B44:  MOVLB  5
04B46:  CLRF   x81
04B48:  CLRF   x80
....................                               while(pass < 112 || pass > 9999) 
04B4A:  MOVF   x81,F
04B4C:  BNZ   4B54
04B4E:  MOVF   x80,W
04B50:  SUBLW  6F
04B52:  BC    4B64
04B54:  MOVF   x81,W
04B56:  SUBLW  26
04B58:  BC    4B76
04B5A:  XORLW  FF
04B5C:  BNZ   4B64
04B5E:  MOVF   x80,W
04B60:  SUBLW  0F
04B62:  BC    4B76
....................                               { 
....................                                  pass = rand(); 
04B64:  MOVLB  0
04B66:  CALL   23B6
04B6A:  MOVFF  02,581
04B6E:  MOVFF  01,580
04B72:  MOVLB  5
04B74:  BRA    4B4A
....................                               } 
....................                               Actuator.Pass = pass; 
04B76:  MOVFF  581,2AA
04B7A:  MOVFF  580,2A9
....................                               Actuator.WaittingPass = true; 
04B7E:  MOVLB  2
04B80:  BSF    xB3.0
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = Actuator.Pass >> 0 & 0xFF; 
04B82:  MOVFF  2AA,6C6
04B86:  MOVFF  2A9,582
04B8A:  MOVLB  5
....................                               buf[1] = Actuator.Pass >> 8 & 0xFF; 
04B8C:  MOVFF  2AA,583
04B90:  MOVLB  5
....................                               SentFormatMIMEPacket(ActSetPass, 2, &buf[0]); 
04B92:  MOVLW  C9
04B94:  MOVLB  6
04B96:  MOVWF  xC5
04B98:  MOVLW  02
04B9A:  MOVWF  xC6
04B9C:  MOVLW  05
04B9E:  MOVWF  xC8
04BA0:  MOVLW  82
04BA2:  MOVWF  xC7
04BA4:  MOVLB  0
04BA6:  CALL   1A92
....................                               //fprintf(Serial,"Actuator Pin Sent= %lu%c%c",pass,0x1f,0x03); 
....................                               //envio Pass 
....................                            } 
04BAA:  BRA    4BCA
04BAC:  MOVLB  2
....................                            else 
....................                            { 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = Actuator.OutputMode; 
04BAE:  MOVFF  2A6,584
....................                               SentFormatMIMEPacket(ActGetMode, 1, &buf[0]); 
04BB2:  MOVLW  C1
04BB4:  MOVLB  6
04BB6:  MOVWF  xC5
04BB8:  MOVLW  01
04BBA:  MOVWF  xC6
04BBC:  MOVLW  05
04BBE:  MOVWF  xC8
04BC0:  MOVLW  84
04BC2:  MOVWF  xC7
04BC4:  MOVLB  0
04BC6:  CALL   1A92
....................                            } 
....................                            break; 
04BCA:  GOTO   6362
....................                         } 
....................                         case ActGetActualValue: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = Actuator.OutputState; 
04BCE:  MOVLB  5
04BD0:  CLRF   x85
04BD2:  MOVLB  2
04BD4:  BTFSS  xA7.0
04BD6:  BRA    4BDE
04BD8:  MOVLB  5
04BDA:  INCF   x85,F
04BDC:  MOVLB  2
....................                            SentFormatMIMEPacket(ActGetActualValue, 1, &buf[0]); 
04BDE:  MOVLW  C6
04BE0:  MOVLB  6
04BE2:  MOVWF  xC5
04BE4:  MOVLW  01
04BE6:  MOVWF  xC6
04BE8:  MOVLW  05
04BEA:  MOVWF  xC8
04BEC:  MOVLW  85
04BEE:  MOVWF  xC7
04BF0:  MOVLB  0
04BF2:  CALL   1A92
....................                            break; 
04BF6:  GOTO   6362
....................                         } 
....................                         case ActSetPass: 
....................                         { 
....................                            if(Actuator.WaittingPass == true) 
04BFA:  MOVLB  2
04BFC:  BTFSS  xB3.0
04BFE:  BRA    50C0
....................                            { 
....................                               if(Msg_Data[1] == 2) 
04C00:  MOVLB  0
04C02:  MOVF   x95,W
04C04:  SUBLW  02
04C06:  BTFSS  FD8.2
04C08:  BRA    5084
....................                               { 
....................                                  unsigned int16 pin = make16(Msg_Data[2],Msg_Data[3]); 
04C0A:  MOVFF  96,587
04C0E:  MOVFF  97,586
....................                                  if(pin == Actuator.Pass) 
04C12:  MOVLB  2
04C14:  MOVF   xA9,W
04C16:  MOVLB  5
04C18:  SUBWF  x86,W
04C1A:  BTFSS  FD8.2
04C1C:  BRA    501A
04C1E:  MOVLB  2
04C20:  MOVF   xAA,W
04C22:  MOVLB  5
04C24:  SUBWF  x87,W
04C26:  BTFSS  FD8.2
04C28:  BRA    501A
....................                                  { 
....................                                     if(Actuator.LastPetition == ON || Actuator.LastPetition == OFF || Actuator.LastPetition == TimedOutput) 
04C2A:  MOVLB  2
04C2C:  MOVF   xA8,W
04C2E:  SUBLW  03
04C30:  BZ    4C40
04C32:  MOVF   xA8,W
04C34:  SUBLW  04
04C36:  BZ    4C40
04C38:  MOVF   xA8,W
04C3A:  SUBLW  05
04C3C:  BTFSS  FD8.2
04C3E:  BRA    4FD2
....................                                     { 
....................                                        if(Actuator.OutputMode == ActuadorONOFF) 
04C40:  MOVF   xA6,W
04C42:  SUBLW  03
04C44:  BTFSS  FD8.2
04C46:  BRA    4DE6
....................                                        { 
....................                                           if(Actuator.LastPetition == ON) 
04C48:  MOVF   xA8,W
04C4A:  SUBLW  03
04C4C:  BNZ   4CF8
....................                                           { 
....................                                              cmdSize = sprintf(cdmMessage, "Actuator Desired Status = %U by Server", 1); 
04C4E:  MOVLW  03
04C50:  MOVLB  3
04C52:  MOVWF  x86
04C54:  MOVLW  90
04C56:  MOVWF  x85
04C58:  MOVLW  66
04C5A:  MOVWF  FF6
04C5C:  MOVLW  0D
04C5E:  MOVWF  FF7
04C60:  MOVLW  1A
04C62:  MOVLB  6
04C64:  MOVWF  xCD
04C66:  MOVLB  0
04C68:  CALL   1CBA
04C6C:  MOVLW  01
04C6E:  MOVLB  7
04C70:  MOVWF  xD9
04C72:  MOVLW  1B
04C74:  MOVWF  xDA
04C76:  MOVLB  0
04C78:  CALL   174A
04C7C:  MOVLW  82
04C7E:  MOVWF  FF6
04C80:  MOVLW  0D
04C82:  MOVWF  FF7
04C84:  MOVLW  0A
04C86:  MOVLB  6
04C88:  MOVWF  xCD
04C8A:  MOVLB  0
04C8C:  CALL   1CBA
04C90:  MOVLW  90
04C92:  MOVLB  3
04C94:  SUBWF  x85,W
04C96:  MOVWF  xD6
....................                                              sendToPC(ShowOutputReason,cmdSize,&cdmMessage);  
04C98:  MOVLW  55
04C9A:  MOVLB  6
04C9C:  MOVWF  xC5
04C9E:  MOVFF  3D6,6C6
04CA2:  MOVLW  03
04CA4:  MOVWF  xC8
04CA6:  MOVLW  90
04CA8:  MOVWF  xC7
04CAA:  MOVLB  0
04CAC:  CALL   17D0
....................                                              Actuator_Set_Value(1); 
04CB0:  MOVLW  01
04CB2:  MOVLB  6
04CB4:  MOVWF  xC5
04CB6:  MOVLB  0
04CB8:  CALL   1EEA
....................                                              if(GoIOXstatus.synchronized == true) 
04CBC:  BTFSS  x63.0
04CBE:  BRA    4CF4
....................                                              { 
....................                                                 cmdSize = sprintf(cdmMessage, "Act Server O 1!"); 
04CC0:  MOVLW  03
04CC2:  MOVLB  3
04CC4:  MOVWF  x86
04CC6:  MOVLW  90
04CC8:  MOVWF  x85
04CCA:  MOVLW  8E
04CCC:  MOVWF  FF6
04CCE:  MOVLW  0D
04CD0:  MOVWF  FF7
04CD2:  MOVLB  0
04CD4:  CALL   16B8
04CD8:  MOVLW  90
04CDA:  MOVLB  3
04CDC:  SUBWF  x85,W
04CDE:  MOVWF  xD6
....................                                                 SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
04CE0:  MOVFF  3D6,6C5
04CE4:  MOVLW  03
04CE6:  MOVLB  6
04CE8:  MOVWF  xC7
04CEA:  MOVLW  90
04CEC:  MOVWF  xC6
04CEE:  MOVLB  0
04CF0:  CALL   1DA0
....................                                              } 
....................                                           } 
04CF4:  BRA    4DE2
04CF6:  MOVLB  2
....................                                           else if(Actuator.LastPetition == OFF) 
04CF8:  MOVF   xA8,W
04CFA:  SUBLW  04
04CFC:  BNZ   4DA4
....................                                           { 
....................                                              cmdSize = sprintf(cdmMessage, "Actuator Desired Status = %U by Server", 0); 
04CFE:  MOVLW  03
04D00:  MOVLB  3
04D02:  MOVWF  x86
04D04:  MOVLW  90
04D06:  MOVWF  x85
04D08:  MOVLW  9E
04D0A:  MOVWF  FF6
04D0C:  MOVLW  0D
04D0E:  MOVWF  FF7
04D10:  MOVLW  1A
04D12:  MOVLB  6
04D14:  MOVWF  xCD
04D16:  MOVLB  0
04D18:  CALL   1CBA
04D1C:  MOVLB  7
04D1E:  CLRF   xD9
04D20:  MOVLW  1B
04D22:  MOVWF  xDA
04D24:  MOVLB  0
04D26:  CALL   174A
04D2A:  MOVLW  BA
04D2C:  MOVWF  FF6
04D2E:  MOVLW  0D
04D30:  MOVWF  FF7
04D32:  MOVLW  0A
04D34:  MOVLB  6
04D36:  MOVWF  xCD
04D38:  MOVLB  0
04D3A:  CALL   1CBA
04D3E:  MOVLW  90
04D40:  MOVLB  3
04D42:  SUBWF  x85,W
04D44:  MOVWF  xD6
....................                                              sendToPC(ShowOutputReason,cmdSize,&cdmMessage);  
04D46:  MOVLW  55
04D48:  MOVLB  6
04D4A:  MOVWF  xC5
04D4C:  MOVFF  3D6,6C6
04D50:  MOVLW  03
04D52:  MOVWF  xC8
04D54:  MOVLW  90
04D56:  MOVWF  xC7
04D58:  MOVLB  0
04D5A:  CALL   17D0
....................                                              Actuator_Set_Value(0); 
04D5E:  MOVLB  6
04D60:  CLRF   xC5
04D62:  MOVLB  0
04D64:  CALL   1EEA
....................                                              if(GoIOXstatus.synchronized == true) 
04D68:  BTFSS  x63.0
04D6A:  BRA    4DA0
....................                                              { 
....................                                                 cmdSize = sprintf(cdmMessage, "Act Server O 0!"); 
04D6C:  MOVLW  03
04D6E:  MOVLB  3
04D70:  MOVWF  x86
04D72:  MOVLW  90
04D74:  MOVWF  x85
04D76:  MOVLW  C6
04D78:  MOVWF  FF6
04D7A:  MOVLW  0D
04D7C:  MOVWF  FF7
04D7E:  MOVLB  0
04D80:  CALL   16B8
04D84:  MOVLW  90
04D86:  MOVLB  3
04D88:  SUBWF  x85,W
04D8A:  MOVWF  xD6
....................                                                 SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
04D8C:  MOVFF  3D6,6C5
04D90:  MOVLW  03
04D92:  MOVLB  6
04D94:  MOVWF  xC7
04D96:  MOVLW  90
04D98:  MOVWF  xC6
04D9A:  MOVLB  0
04D9C:  CALL   1DA0
....................                                              } 
....................                                           } 
04DA0:  BRA    4DE2
04DA2:  MOVLB  2
....................                                           else if(Actuator.LastPetition == TimedOutput) 
04DA4:  MOVF   xA8,W
04DA6:  SUBLW  05
04DA8:  BNZ   4DE4
....................                                           { 
....................                                              //no se puede llevar esta accion en este modo 
....................                                              cmdSize = sprintf(cdmMessage, "Timed Output Actuator no Realizado por Modo de Actuador"); 
04DAA:  MOVLW  03
04DAC:  MOVLB  3
04DAE:  MOVWF  x86
04DB0:  MOVLW  90
04DB2:  MOVWF  x85
04DB4:  MOVLW  D6
04DB6:  MOVWF  FF6
04DB8:  MOVLW  0D
04DBA:  MOVWF  FF7
04DBC:  MOVLB  0
04DBE:  CALL   16B8
04DC2:  MOVLW  90
04DC4:  MOVLB  3
04DC6:  SUBWF  x85,W
04DC8:  MOVWF  xD6
....................                                              SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
04DCA:  MOVLW  CA
04DCC:  MOVLB  6
04DCE:  MOVWF  xC5
04DD0:  MOVFF  3D6,6C6
04DD4:  MOVLW  03
04DD6:  MOVWF  xC8
04DD8:  MOVLW  90
04DDA:  MOVWF  xC7
04DDC:  MOVLB  0
04DDE:  CALL   1A92
04DE2:  MOVLB  2
....................                                           } 
....................                                        } 
04DE4:  BRA    4FCE
....................                                        else if(Actuator.OutputMode == ActuadorTemporizado) 
04DE6:  MOVF   xA6,W
04DE8:  SUBLW  05
04DEA:  BTFSS  FD8.2
04DEC:  BRA    4FCE
....................                                        { 
....................                                           if(Actuator.LastPetition == TimedOutput) 
04DEE:  MOVF   xA8,W
04DF0:  SUBLW  05
04DF2:  BTFSS  FD8.2
04DF4:  BRA    4F88
....................                                           { 
....................                                              cmdSize = sprintf(cdmMessage, "The Timed Actuator is Going to be Applied in %LU S During %LU S by Server", Actuator.TimeToReset/1000,Actuator.TimeInReset/1000); 
04DF6:  BCF    FD8.1
04DF8:  MOVFF  2A0,6DC
04DFC:  MOVFF  29F,6DB
04E00:  MOVFF  29E,6DA
04E04:  MOVFF  29D,6D9
04E08:  MOVLB  6
04E0A:  CLRF   xE0
04E0C:  CLRF   xDF
04E0E:  MOVLW  03
04E10:  MOVWF  xDE
04E12:  MOVLW  E8
04E14:  MOVWF  xDD
04E16:  MOVLB  0
04E18:  CALL   1C26
04E1C:  MOVFF  03,6C8
04E20:  MOVFF  02,6C7
04E24:  MOVFF  01,6C6
04E28:  MOVFF  00,6C5
04E2C:  BCF    FD8.1
04E2E:  MOVFF  29C,6DC
04E32:  MOVFF  29B,6DB
04E36:  MOVFF  29A,6DA
04E3A:  MOVFF  299,6D9
04E3E:  MOVLB  6
04E40:  CLRF   xE0
04E42:  CLRF   xDF
04E44:  MOVLW  03
04E46:  MOVWF  xDE
04E48:  MOVLW  E8
04E4A:  MOVWF  xDD
04E4C:  MOVLB  0
04E4E:  CALL   1C26
04E52:  MOVFF  03,6CC
04E56:  MOVFF  02,6CB
04E5A:  MOVFF  01,6CA
04E5E:  MOVFF  00,6C9
04E62:  MOVLW  03
04E64:  MOVLB  3
04E66:  MOVWF  x86
04E68:  MOVLW  90
04E6A:  MOVWF  x85
04E6C:  MOVLW  0E
04E6E:  MOVWF  FF6
04E70:  MOVLW  0E
04E72:  MOVWF  FF7
04E74:  MOVLW  2D
04E76:  MOVLB  6
04E78:  MOVWF  xCD
04E7A:  MOVLB  0
04E7C:  CALL   1CBA
04E80:  MOVLW  41
04E82:  MOVWF  FE9
04E84:  MOVFF  6C8,6D0
04E88:  MOVFF  6C7,6CF
04E8C:  MOVFF  6C6,6CE
04E90:  MOVFF  6C5,6CD
04E94:  CALL   1CE2
04E98:  MOVLW  3E
04E9A:  MOVWF  FF6
04E9C:  MOVLW  0E
04E9E:  MOVWF  FF7
04EA0:  MOVLW  0A
04EA2:  MOVLB  6
04EA4:  MOVWF  xCD
04EA6:  MOVLB  0
04EA8:  CALL   1CBA
04EAC:  MOVLW  41
04EAE:  MOVWF  FE9
04EB0:  MOVFF  6CC,6D0
04EB4:  MOVFF  6CB,6CF
04EB8:  MOVFF  6CA,6CE
04EBC:  MOVFF  6C9,6CD
04EC0:  CALL   1CE2
04EC4:  MOVLW  4B
04EC6:  MOVWF  FF6
04EC8:  MOVLW  0E
04ECA:  MOVWF  FF7
04ECC:  MOVLW  0C
04ECE:  MOVLB  6
04ED0:  MOVWF  xCD
04ED2:  MOVLB  0
04ED4:  CALL   1CBA
04ED8:  MOVLW  90
04EDA:  MOVLB  3
04EDC:  SUBWF  x85,W
04EDE:  MOVWF  xD6
....................                                              sendToPC(ShowTimedOutputReason,cmdSize,&cdmMessage);  
04EE0:  MOVLW  54
04EE2:  MOVLB  6
04EE4:  MOVWF  xC5
04EE6:  MOVFF  3D6,6C6
04EEA:  MOVLW  03
04EEC:  MOVWF  xC8
04EEE:  MOVLW  90
04EF0:  MOVWF  xC7
04EF2:  MOVLB  0
04EF4:  CALL   17D0
....................                                              Actuator.ActivateTimedOutput = true; 
04EF8:  MOVLB  2
04EFA:  BSF    x98.0
....................                                              if(GoIOXstatus.synchronized == true) 
04EFC:  MOVLB  0
04EFE:  BTFSS  x63.0
04F00:  BRA    4F84
....................                                              { 
....................                                                 cmdSize = sprintf(cdmMessage, "Act Server TO %Lu %Lu!",Actuator.TimeToReset,Actuator.TimeInReset); 
04F02:  MOVLW  03
04F04:  MOVLB  3
04F06:  MOVWF  x86
04F08:  MOVLW  90
04F0A:  MOVWF  x85
04F0C:  MOVLW  58
04F0E:  MOVWF  FF6
04F10:  MOVLW  0E
04F12:  MOVWF  FF7
04F14:  MOVLW  0E
04F16:  MOVLB  6
04F18:  MOVWF  xCD
04F1A:  MOVLB  0
04F1C:  CALL   1CBA
04F20:  MOVLW  41
04F22:  MOVWF  FE9
04F24:  MOVFF  2A0,6D0
04F28:  MOVFF  29F,6CF
04F2C:  MOVFF  29E,6CE
04F30:  MOVFF  29D,6CD
04F34:  CALL   1CE2
04F38:  MOVLW  20
04F3A:  MOVLB  7
04F3C:  MOVWF  xDB
04F3E:  MOVLB  0
04F40:  CALL   1696
04F44:  MOVLW  41
04F46:  MOVWF  FE9
04F48:  MOVFF  29C,6D0
04F4C:  MOVFF  29B,6CF
04F50:  MOVFF  29A,6CE
04F54:  MOVFF  299,6CD
04F58:  CALL   1CE2
04F5C:  MOVLW  21
04F5E:  MOVLB  7
04F60:  MOVWF  xDB
04F62:  MOVLB  0
04F64:  CALL   1696
04F68:  MOVLW  90
04F6A:  MOVLB  3
04F6C:  SUBWF  x85,W
04F6E:  MOVWF  xD6
....................                                                 SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
04F70:  MOVFF  3D6,6C5
04F74:  MOVLW  03
04F76:  MOVLB  6
04F78:  MOVWF  xC7
04F7A:  MOVLW  90
04F7C:  MOVWF  xC6
04F7E:  MOVLB  0
04F80:  CALL   1DA0
....................                                              } 
....................                                           } 
04F84:  BRA    4FCC
04F86:  MOVLB  2
....................                                           else if(Actuator.LastPetition == ON ||Actuator.LastPetition == OFF) 
04F88:  MOVF   xA8,W
04F8A:  SUBLW  03
04F8C:  BZ    4F94
04F8E:  MOVF   xA8,W
04F90:  SUBLW  04
04F92:  BNZ   4FCE
....................                                           { 
....................                                              //no se puede llevar esta accion en este modo 
....................                                              cmdSize = sprintf(cdmMessage, "Output Actuator no Realizada por Modo de Actuador"); 
04F94:  MOVLW  03
04F96:  MOVLB  3
04F98:  MOVWF  x86
04F9A:  MOVLW  90
04F9C:  MOVWF  x85
04F9E:  MOVLW  70
04FA0:  MOVWF  FF6
04FA2:  MOVLW  0E
04FA4:  MOVWF  FF7
04FA6:  MOVLB  0
04FA8:  CALL   16B8
04FAC:  MOVLW  90
04FAE:  MOVLB  3
04FB0:  SUBWF  x85,W
04FB2:  MOVWF  xD6
....................                                              SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
04FB4:  MOVLW  CA
04FB6:  MOVLB  6
04FB8:  MOVWF  xC5
04FBA:  MOVFF  3D6,6C6
04FBE:  MOVLW  03
04FC0:  MOVWF  xC8
04FC2:  MOVLW  90
04FC4:  MOVWF  xC7
04FC6:  MOVLB  0
04FC8:  CALL   1A92
04FCC:  MOVLB  2
....................                                           } 
....................                                        } 
....................                                        Actuator.LastPetition = 0; 
04FCE:  CLRF   xA8
....................                                     } 
04FD0:  BRA    500C
....................                                     else 
....................                                     { 
....................                                        //no hay peticion guardada 
....................                                        cmdSize = sprintf(cdmMessage, "Sin Peticion de Actuador"); 
04FD2:  MOVLW  03
04FD4:  MOVLB  3
04FD6:  MOVWF  x86
04FD8:  MOVLW  90
04FDA:  MOVWF  x85
04FDC:  MOVLW  A2
04FDE:  MOVWF  FF6
04FE0:  MOVLW  0E
04FE2:  MOVWF  FF7
04FE4:  MOVLB  0
04FE6:  CALL   16B8
04FEA:  MOVLW  90
04FEC:  MOVLB  3
04FEE:  SUBWF  x85,W
04FF0:  MOVWF  xD6
....................                                        SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
04FF2:  MOVLW  CA
04FF4:  MOVLB  6
04FF6:  MOVWF  xC5
04FF8:  MOVFF  3D6,6C6
04FFC:  MOVLW  03
04FFE:  MOVWF  xC8
05000:  MOVLW  90
05002:  MOVWF  xC7
05004:  MOVLB  0
05006:  CALL   1A92
0500A:  MOVLB  2
....................                                     } 
....................                                     Actuator.WaittingPass = false; 
0500C:  BCF    xB3.0
....................                                     Actuator.Pass = 10000; 
0500E:  MOVLW  27
05010:  MOVWF  xAA
05012:  MOVLW  10
05014:  MOVWF  xA9
....................                                  } 
05016:  BRA    5080
05018:  MOVLB  5
....................                                  else 
....................                                  { 
....................                                     cmdSize = sprintf(cdmMessage, "PIN %lu Incorrecto",pin); 
0501A:  MOVLW  03
0501C:  MOVLB  3
0501E:  MOVWF  x86
05020:  MOVLW  90
05022:  MOVWF  x85
05024:  MOVLW  BC
05026:  MOVWF  FF6
05028:  MOVLW  0E
0502A:  MOVWF  FF7
0502C:  MOVLW  04
0502E:  MOVLB  6
05030:  MOVWF  xCD
05032:  MOVLB  0
05034:  CALL   1CBA
05038:  MOVLW  10
0503A:  MOVWF  FE9
0503C:  MOVFF  587,6C6
05040:  MOVFF  586,6C5
05044:  GOTO   2426
05048:  MOVLW  C3
0504A:  MOVWF  FF6
0504C:  MOVLW  0E
0504E:  MOVWF  FF7
05050:  MOVLW  0B
05052:  MOVLB  6
05054:  MOVWF  xCD
05056:  MOVLB  0
05058:  CALL   1CBA
0505C:  MOVLW  90
0505E:  MOVLB  3
05060:  SUBWF  x85,W
05062:  MOVWF  xD6
....................                                     SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
05064:  MOVLW  CA
05066:  MOVLB  6
05068:  MOVWF  xC5
0506A:  MOVFF  3D6,6C6
0506E:  MOVLW  03
05070:  MOVWF  xC8
05072:  MOVLW  90
05074:  MOVWF  xC7
05076:  MOVLB  0
05078:  CALL   1A92
....................                                     Actuator.LastPetition = 0; 
0507C:  MOVLB  2
0507E:  CLRF   xA8
....................                                  } 
....................                               }  
05080:  BRA    50BE
05082:  MOVLB  0
....................                               else 
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "PIN Sin Formato"); 
05084:  MOVLW  03
05086:  MOVLB  3
05088:  MOVWF  x86
0508A:  MOVLW  90
0508C:  MOVWF  x85
0508E:  MOVLW  D0
05090:  MOVWF  FF6
05092:  MOVLW  0E
05094:  MOVWF  FF7
05096:  MOVLB  0
05098:  CALL   16B8
0509C:  MOVLW  90
0509E:  MOVLB  3
050A0:  SUBWF  x85,W
050A2:  MOVWF  xD6
....................                                  SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
050A4:  MOVLW  CA
050A6:  MOVLB  6
050A8:  MOVWF  xC5
050AA:  MOVFF  3D6,6C6
050AE:  MOVLW  03
050B0:  MOVWF  xC8
050B2:  MOVLW  90
050B4:  MOVWF  xC7
050B6:  MOVLB  0
050B8:  CALL   1A92
050BC:  MOVLB  2
....................                               } 
....................                            } 
050BE:  BRA    513C
....................                            else 
....................                            { 
....................                               if(Actuator.LastPetition != 0) 
050C0:  MOVF   xA8,F
050C2:  BZ    5102
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "Tiempo de Espera Para PIN Superado"); 
050C4:  MOVLW  03
050C6:  MOVLB  3
050C8:  MOVWF  x86
050CA:  MOVLW  90
050CC:  MOVWF  x85
050CE:  MOVLW  E0
050D0:  MOVWF  FF6
050D2:  MOVLW  0E
050D4:  MOVWF  FF7
050D6:  MOVLB  0
050D8:  CALL   16B8
050DC:  MOVLW  90
050DE:  MOVLB  3
050E0:  SUBWF  x85,W
050E2:  MOVWF  xD6
....................                                  SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
050E4:  MOVLW  CA
050E6:  MOVLB  6
050E8:  MOVWF  xC5
050EA:  MOVFF  3D6,6C6
050EE:  MOVLW  03
050F0:  MOVWF  xC8
050F2:  MOVLW  90
050F4:  MOVWF  xC7
050F6:  MOVLB  0
050F8:  CALL   1A92
....................                                  Actuator.LastPetition = 0 ; 
050FC:  MOVLB  2
050FE:  CLRF   xA8
....................                               } 
05100:  BRA    513C
....................                               else 
....................                               { 
....................                                  cmdSize = sprintf(cdmMessage, "PIN No Esperado"); 
05102:  MOVLW  03
05104:  MOVLB  3
05106:  MOVWF  x86
05108:  MOVLW  90
0510A:  MOVWF  x85
0510C:  MOVLW  04
0510E:  MOVWF  FF6
05110:  MOVLW  0F
05112:  MOVWF  FF7
05114:  MOVLB  0
05116:  CALL   16B8
0511A:  MOVLW  90
0511C:  MOVLB  3
0511E:  SUBWF  x85,W
05120:  MOVWF  xD6
....................                                  SentFormatMIMEPacket(ActError, cmdSize, &cdmMessage); 
05122:  MOVLW  CA
05124:  MOVLB  6
05126:  MOVWF  xC5
05128:  MOVFF  3D6,6C6
0512C:  MOVLW  03
0512E:  MOVWF  xC8
05130:  MOVLW  90
05132:  MOVWF  xC7
05134:  MOVLB  0
05136:  CALL   1A92
0513A:  MOVLB  2
....................                               } 
....................                            } 
....................                            break; 
0513C:  MOVLB  0
0513E:  GOTO   6362
....................                         } 
....................                         case ActSettimedOutput: 
....................                         { 
....................                            if(Actuator.OutputMode == ActuadorTemporizado) 
05142:  MOVLB  2
05144:  MOVF   xA6,W
05146:  SUBLW  05
05148:  BNZ   51F2
....................                            { 
....................                               if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
0514A:  MOVLB  0
0514C:  MOVF   x95,W
0514E:  SUBLW  04
05150:  BNZ   5172
05152:  MOVF   x96,W
05154:  SUBLW  25
05156:  BNZ   5172
05158:  MOVF   x97,W
0515A:  SUBLW  33
0515C:  BNZ   5172
0515E:  MOVF   x98,W
05160:  SUBLW  41
05162:  BNZ   5172
05164:  MOVF   x99,W
05166:  SUBLW  49
05168:  BNZ   5172
....................                               { 
....................                                  //fprintf(Serial,"Actuator timed requested%c%c",0x1f,0x03); 
....................                                  Actuator.LastPetition = TimedOutput; 
0516A:  MOVLW  05
0516C:  MOVLB  2
0516E:  MOVWF  xA8
05170:  MOVLB  0
....................                               } 
....................                               srand(get_timer2()); 
05172:  MOVFF  FCC,6C5
05176:  MOVLB  6
05178:  CLRF   xC9
0517A:  CLRF   xC8
0517C:  CLRF   xC7
0517E:  MOVFF  FCC,6C6
05182:  MOVLB  0
05184:  CALL   22FE
....................                               unsigned int16 pass = 0; 
05188:  MOVLB  5
0518A:  CLRF   x89
0518C:  CLRF   x88
....................                               while(pass < 112 || pass > 9999) 
0518E:  MOVF   x89,F
05190:  BNZ   5198
05192:  MOVF   x88,W
05194:  SUBLW  6F
05196:  BC    51A8
05198:  MOVF   x89,W
0519A:  SUBLW  26
0519C:  BC    51BA
0519E:  XORLW  FF
051A0:  BNZ   51A8
051A2:  MOVF   x88,W
051A4:  SUBLW  0F
051A6:  BC    51BA
....................                               { 
....................                                  pass = rand(); 
051A8:  MOVLB  0
051AA:  CALL   23B6
051AE:  MOVFF  02,589
051B2:  MOVFF  01,588
051B6:  MOVLB  5
051B8:  BRA    518E
....................                               } 
....................                               Actuator.Pass = pass; 
051BA:  MOVFF  589,2AA
051BE:  MOVFF  588,2A9
....................                               Actuator.WaittingPass = true; 
051C2:  MOVLB  2
051C4:  BSF    xB3.0
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = Actuator.Pass >> 0 & 0xFF; 
051C6:  MOVFF  2AA,6C6
051CA:  MOVFF  2A9,58A
051CE:  MOVLB  5
....................                               buf[1] = Actuator.Pass >> 8 & 0xFF; 
051D0:  MOVFF  2AA,58B
051D4:  MOVLB  5
....................                               SentFormatMIMEPacket(ActSetPass, 2, &buf[0]); 
051D6:  MOVLW  C9
051D8:  MOVLB  6
051DA:  MOVWF  xC5
051DC:  MOVLW  02
051DE:  MOVWF  xC6
051E0:  MOVLW  05
051E2:  MOVWF  xC8
051E4:  MOVLW  8A
051E6:  MOVWF  xC7
051E8:  MOVLB  0
051EA:  CALL   1A92
....................                               //fprintf(Serial,"Actuator Pin Sent= %lu%c%c",pass,0x1f,0x03); 
....................                               //envio Pass 
....................                            } 
051EE:  BRA    520E
051F0:  MOVLB  2
....................                            else 
....................                            { 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = Actuator.OutputMode; 
051F2:  MOVFF  2A6,58C
....................                               SentFormatMIMEPacket(ActGetMode, 1, &buf[0]); 
051F6:  MOVLW  C1
051F8:  MOVLB  6
051FA:  MOVWF  xC5
051FC:  MOVLW  01
051FE:  MOVWF  xC6
05200:  MOVLW  05
05202:  MOVWF  xC8
05204:  MOVLW  8C
05206:  MOVWF  xC7
05208:  MOVLB  0
0520A:  CALL   1A92
....................                            } 
....................                            break; 
0520E:  GOTO   6362
....................                         } 
....................                         case ActSetEnableClientRqst: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
05212:  MOVF   x95,W
05214:  SUBLW  04
05216:  BNZ   5254
05218:  MOVF   x96,W
0521A:  SUBLW  25
0521C:  BNZ   5254
0521E:  MOVF   x97,W
05220:  SUBLW  33
05222:  BNZ   5254
05224:  MOVF   x98,W
05226:  SUBLW  41
05228:  BNZ   5254
0522A:  MOVF   x99,W
0522C:  SUBLW  49
0522E:  BNZ   5254
....................                            { 
....................                               AllowedFuntions.rqstActuator = true; 
05230:  BSF    20.6
....................                               //fprintf(Serial,"Actuator Rqsr by Client Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.rqstActuator; 
05232:  MOVLB  5
05234:  CLRF   x8D
05236:  BTFSC  20.6
05238:  INCF   x8D,F
....................                               SentFormatMIMEPacket(ActGetEnableClientRqst, 1, &buf[0]); 
0523A:  MOVLW  CD
0523C:  MOVLB  6
0523E:  MOVWF  xC5
05240:  MOVLW  01
05242:  MOVWF  xC6
05244:  MOVLW  05
05246:  MOVWF  xC8
05248:  MOVLW  8D
0524A:  MOVWF  xC7
0524C:  MOVLB  0
0524E:  CALL   1A92
....................                            } 
05252:  BRA    5294
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
05254:  MOVF   x95,W
05256:  SUBLW  04
05258:  BNZ   5294
0525A:  MOVF   x96,W
0525C:  SUBLW  25
0525E:  BNZ   5294
05260:  MOVF   x97,W
05262:  SUBLW  28
05264:  BNZ   5294
05266:  MOVF   x98,W
05268:  SUBLW  31
0526A:  BNZ   5294
0526C:  MOVF   x99,W
0526E:  SUBLW  34
05270:  BNZ   5294
....................                            { 
....................                               AllowedFuntions.rqstActuator = false; 
05272:  BCF    20.6
....................                               //fprintf(Serial,"Actuator Rqsr by Client Not Allowed%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.rqstActuator; 
05274:  MOVLB  5
05276:  CLRF   x8E
05278:  BTFSC  20.6
0527A:  INCF   x8E,F
....................                               SentFormatMIMEPacket(ActGetEnableClientRqst, 1, &buf[0]); 
0527C:  MOVLW  CD
0527E:  MOVLB  6
05280:  MOVWF  xC5
05282:  MOVLW  01
05284:  MOVWF  xC6
05286:  MOVLW  05
05288:  MOVWF  xC8
0528A:  MOVLW  8E
0528C:  MOVWF  xC7
0528E:  MOVLB  0
05290:  CALL   1A92
....................                            } 
....................                            break; 
05294:  GOTO   6362
....................                         } 
....................                         case ActGetEnableClientRqst: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.rqstActuator; 
05298:  MOVLB  5
0529A:  CLRF   x8F
0529C:  BTFSC  20.6
0529E:  INCF   x8F,F
....................                            SentFormatMIMEPacket(ActGetEnableClientRqst, 1, &buf[0]); 
052A0:  MOVLW  CD
052A2:  MOVLB  6
052A4:  MOVWF  xC5
052A6:  MOVLW  01
052A8:  MOVWF  xC6
052AA:  MOVLW  05
052AC:  MOVWF  xC8
052AE:  MOVLW  8F
052B0:  MOVWF  xC7
052B2:  MOVLB  0
052B4:  CALL   1A92
....................                            break; 
052B8:  GOTO   6362
....................                         }  
....................                         case DBISetTimeHeartBeat: 
....................                         { 
....................                            if(Msg_Data[1] == 4) 
052BC:  MOVF   x95,W
052BE:  SUBLW  04
052C0:  BNZ   532A
....................                            { 
....................                               unsigned int32 valor = make32(Msg_Data[2],Msg_Data[3],Msg_Data[4],Msg_Data[5]); 
052C2:  MOVFF  96,593
052C6:  MOVFF  97,592
052CA:  MOVFF  98,591
052CE:  MOVFF  99,590
....................                               GoIOXstatus.p_TimetoHearBeat = valor; 
052D2:  MOVFF  593,89
052D6:  MOVFF  592,88
052DA:  MOVFF  591,87
052DE:  MOVFF  590,86
....................                               //fprintf(Serial,"Time to Send HearBeat %lu %c%c",GoIOXstatus.p_TimetoHearBeat,0x1f,0x03); 
....................                               unsigned int8 buf[4]; 
....................                               buf[0] = GoIOXstatus.p_TimetoHearBeat >> 0 & 0xFF; 
052E2:  MOVFF  89,6C9
052E6:  MOVFF  88,6C8
052EA:  MOVFF  87,6C7
052EE:  MOVFF  86,594
052F2:  MOVLB  5
....................                               buf[1] = GoIOXstatus.p_TimetoHearBeat >> 8 & 0xFF; 
052F4:  MOVFF  87,595
052F8:  MOVFF  88,6C7
052FC:  MOVFF  89,6C8
05300:  MOVLB  5
....................                               buf[2] = GoIOXstatus.p_TimetoHearBeat >> 16 & 0xFF; 
05302:  MOVFF  88,596
05306:  MOVFF  89,6C7
0530A:  MOVLB  5
....................                               buf[3] = GoIOXstatus.p_TimetoHearBeat >> 24 & 0xFF; 
0530C:  MOVFF  89,597
05310:  MOVLB  5
....................                               SentFormatMIMEPacket(DBIGetTimeHeartBeat, 4, &buf[0]); 
05312:  MOVLW  D1
05314:  MOVLB  6
05316:  MOVWF  xC5
05318:  MOVLW  04
0531A:  MOVWF  xC6
0531C:  MOVLW  05
0531E:  MOVWF  xC8
05320:  MOVLW  94
05322:  MOVWF  xC7
05324:  MOVLB  0
05326:  CALL   1A92
....................                            } 
....................                            break; 
0532A:  GOTO   6362
....................                         } 
....................                         case DBIGetTimeHeartBeat: 
....................                         { 
....................                            unsigned int8 buf[4]; 
....................                            buf[0] = GoIOXstatus.p_TimetoHearBeat >> 0 & 0xFF; 
0532E:  MOVFF  89,6C9
05332:  MOVFF  88,6C8
05336:  MOVFF  87,6C7
0533A:  MOVFF  86,598
0533E:  MOVLB  5
....................                            buf[1] = GoIOXstatus.p_TimetoHearBeat >> 8 & 0xFF; 
05340:  MOVFF  87,599
05344:  MOVFF  88,6C7
05348:  MOVFF  89,6C8
0534C:  MOVLB  5
....................                            buf[2] = GoIOXstatus.p_TimetoHearBeat >> 16 & 0xFF; 
0534E:  MOVFF  88,59A
05352:  MOVFF  89,6C7
05356:  MOVLB  5
....................                            buf[3] = GoIOXstatus.p_TimetoHearBeat >> 24 & 0xFF; 
05358:  MOVFF  89,59B
0535C:  MOVLB  5
....................                            SentFormatMIMEPacket(DBIGetTimeHeartBeat, 4, &buf[0]); 
0535E:  MOVLW  D1
05360:  MOVLB  6
05362:  MOVWF  xC5
05364:  MOVLW  04
05366:  MOVWF  xC6
05368:  MOVLW  05
0536A:  MOVWF  xC8
0536C:  MOVLW  98
0536E:  MOVWF  xC7
05370:  MOVLB  0
05372:  CALL   1A92
....................                            break; 
05376:  GOTO   6362
....................                         } 
....................                         case DBISetEnableHeartBeat: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
0537A:  MOVF   x95,W
0537C:  SUBLW  04
0537E:  BNZ   53C4
05380:  MOVF   x96,W
05382:  SUBLW  25
05384:  BNZ   53C4
05386:  MOVF   x97,W
05388:  SUBLW  33
0538A:  BNZ   53C4
0538C:  MOVF   x98,W
0538E:  SUBLW  41
05390:  BNZ   53C4
05392:  MOVF   x99,W
05394:  SUBLW  49
05396:  BNZ   53C4
....................                            { 
....................                               GoIOXstatus.HeartbeatEnable = true; 
05398:  BSF    x8E.0
....................                               //fprintf(Serial,"HeartBeat Enabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = GoIOXstatus.HeartbeatEnable; 
0539A:  MOVLB  5
0539C:  CLRF   x9C
0539E:  MOVLB  0
053A0:  BTFSS  x8E.0
053A2:  BRA    53AA
053A4:  MOVLB  5
053A6:  INCF   x9C,F
053A8:  MOVLB  0
....................                               SentFormatMIMEPacket(DBIGetEnableHeartBeat, 1, &buf[0]); 
053AA:  MOVLW  D3
053AC:  MOVLB  6
053AE:  MOVWF  xC5
053B0:  MOVLW  01
053B2:  MOVWF  xC6
053B4:  MOVLW  05
053B6:  MOVWF  xC8
053B8:  MOVLW  9C
053BA:  MOVWF  xC7
053BC:  MOVLB  0
053BE:  CALL   1A92
....................                            } 
053C2:  BRA    540C
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
053C4:  MOVF   x95,W
053C6:  SUBLW  04
053C8:  BNZ   540C
053CA:  MOVF   x96,W
053CC:  SUBLW  25
053CE:  BNZ   540C
053D0:  MOVF   x97,W
053D2:  SUBLW  28
053D4:  BNZ   540C
053D6:  MOVF   x98,W
053D8:  SUBLW  31
053DA:  BNZ   540C
053DC:  MOVF   x99,W
053DE:  SUBLW  34
053E0:  BNZ   540C
....................                            { 
....................                               GoIOXstatus.HeartbeatEnable = false; 
053E2:  BCF    x8E.0
....................                               //fprintf(Serial,"HeartBeat Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = GoIOXstatus.HeartbeatEnable; 
053E4:  MOVLB  5
053E6:  CLRF   x9D
053E8:  MOVLB  0
053EA:  BTFSS  x8E.0
053EC:  BRA    53F4
053EE:  MOVLB  5
053F0:  INCF   x9D,F
053F2:  MOVLB  0
....................                               SentFormatMIMEPacket(DBIGetEnableHeartBeat, 1, &buf[0]); 
053F4:  MOVLW  D3
053F6:  MOVLB  6
053F8:  MOVWF  xC5
053FA:  MOVLW  01
053FC:  MOVWF  xC6
053FE:  MOVLW  05
05400:  MOVWF  xC8
05402:  MOVLW  9D
05404:  MOVWF  xC7
05406:  MOVLB  0
05408:  CALL   1A92
....................                            } 
....................                            break; 
0540C:  GOTO   6362
....................                         } 
....................                         case DBIGetEnableHeartBeat: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = GoIOXstatus.HeartbeatEnable; 
05410:  MOVLB  5
05412:  CLRF   x9E
05414:  MOVLB  0
05416:  BTFSS  x8E.0
05418:  BRA    5420
0541A:  MOVLB  5
0541C:  INCF   x9E,F
0541E:  MOVLB  0
....................                            SentFormatMIMEPacket(DBIGetEnableHeartBeat, 1, &buf[0]); 
05420:  MOVLW  D3
05422:  MOVLB  6
05424:  MOVWF  xC5
05426:  MOVLW  01
05428:  MOVWF  xC6
0542A:  MOVLW  05
0542C:  MOVWF  xC8
0542E:  MOVLW  9E
05430:  MOVWF  xC7
05432:  MOVLB  0
05434:  CALL   1A92
....................                            break; 
05438:  GOTO   6362
....................                         } 
....................                         case DBIForceToSentHearbeat: 
....................                         { 
....................                            if(GoIOXstatus.synchronized == true) 
0543C:  BTFSS  x63.0
0543E:  BRA    5474
....................                            { 
....................                               cmdSize = sprintf(cdmMessage, "DBI HeartBeat!"); 
05440:  MOVLW  03
05442:  MOVLB  3
05444:  MOVWF  x86
05446:  MOVLW  90
05448:  MOVWF  x85
0544A:  MOVLW  14
0544C:  MOVWF  FF6
0544E:  MOVLW  0F
05450:  MOVWF  FF7
05452:  MOVLB  0
05454:  CALL   16B8
05458:  MOVLW  90
0545A:  MOVLB  3
0545C:  SUBWF  x85,W
0545E:  MOVWF  xD6
....................                               SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
05460:  MOVFF  3D6,6C5
05464:  MOVLW  03
05466:  MOVLB  6
05468:  MOVWF  xC7
0546A:  MOVLW  90
0546C:  MOVWF  xC6
0546E:  MOVLB  0
05470:  CALL   1DA0
....................                            } 
....................                            break; 
05474:  GOTO   6362
....................                         } 
....................                         case DBIGetFwVersion: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = firmwareMajorVersion; 
05478:  MOVFF  22,59F
....................                            buf[1] = firmwareMinorVersion; 
0547C:  MOVFF  23,5A0
....................                            SentFormatMIMEPacket(DBIGetFwVersion, 2, &buf[0]); 
05480:  MOVLW  D4
05482:  MOVLB  6
05484:  MOVWF  xC5
05486:  MOVLW  02
05488:  MOVWF  xC6
0548A:  MOVLW  05
0548C:  MOVWF  xC8
0548E:  MOVLW  9F
05490:  MOVWF  xC7
05492:  MOVLB  0
05494:  CALL   1A92
....................                            break; 
05498:  GOTO   6362
....................                         } 
....................                         case DBIGetHwVersion: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = HardwareMajorVersion; 
0549C:  MOVFF  24,5A1
....................                            buf[1] = HardwareMinorVersion; 
054A0:  MOVFF  25,5A2
....................                            SentFormatMIMEPacket(DBIGetHwVersion, 2, &buf[0]); 
054A4:  MOVLW  D5
054A6:  MOVLB  6
054A8:  MOVWF  xC5
054AA:  MOVLW  02
054AC:  MOVWF  xC6
054AE:  MOVLW  05
054B0:  MOVWF  xC8
054B2:  MOVLW  A1
054B4:  MOVWF  xC7
054B6:  MOVLB  0
054B8:  CALL   1A92
....................                            break; 
054BC:  GOTO   6362
....................                         } 
....................                         case DBIResetHardware: 
....................                         { 
....................                            cmdSize = sprintf(cdmMessage, "DBI is going to be restarted in 2 seconds By Server"); 
054C0:  MOVLW  03
054C2:  MOVLB  3
054C4:  MOVWF  x86
054C6:  MOVLW  90
054C8:  MOVWF  x85
054CA:  MOVLW  24
054CC:  MOVWF  FF6
054CE:  MOVLW  0F
054D0:  MOVWF  FF7
054D2:  MOVLB  0
054D4:  CALL   16B8
054D8:  MOVLW  90
054DA:  MOVLB  3
054DC:  SUBWF  x85,W
054DE:  MOVWF  xD6
....................                            sendToPC(ResetDBIByServer,cmdSize,&cdmMessage);  
054E0:  MOVLW  61
054E2:  MOVLB  6
054E4:  MOVWF  xC5
054E6:  MOVFF  3D6,6C6
054EA:  MOVLW  03
054EC:  MOVWF  xC8
054EE:  MOVLW  90
054F0:  MOVWF  xC7
054F2:  MOVLB  0
054F4:  CALL   17D0
....................                            for(unsigned int16 i = 0; i < 20; i++) 
054F8:  MOVLB  5
054FA:  CLRF   xA4
054FC:  CLRF   xA3
054FE:  MOVF   xA4,F
05500:  BNZ   5520
05502:  MOVF   xA3,W
05504:  SUBLW  13
05506:  BNC   5520
....................                            { 
....................                               delay_ms(100); 
05508:  MOVLW  64
0550A:  MOVLB  6
0550C:  MOVWF  xC7
0550E:  MOVLB  0
05510:  CALL   0FC8
....................                               restart_wdt(); 
05514:  CLRWDT
05516:  MOVLB  5
05518:  INCF   xA3,F
0551A:  BTFSC  FD8.2
0551C:  INCF   xA4,F
0551E:  BRA    54FE
....................                            } 
....................                            //guardar en eeprom 
....................                            reset_cpu(); 
05520:  RESET
....................                            break; 
05522:  MOVLB  0
05524:  GOTO   6362
....................                         } 
....................                         case DBIGetDeviceSerie: 
....................                         { 
....................                            unsigned int8 serie[8]; 
....................                            read_program_memory(0x200000, serie, 8); 
05528:  MOVLW  20
0552A:  MOVWF  FF8
0552C:  CLRF   FF7
0552E:  CLRF   FF6
05530:  MOVLW  05
05532:  MOVWF  FEA
05534:  MOVLW  A5
05536:  MOVWF  FE9
05538:  MOVLB  6
0553A:  CLRF   xC6
0553C:  MOVLW  08
0553E:  MOVWF  xC5
05540:  MOVLB  0
05542:  CALL   1F02
....................                            unsigned int8 buf[10]; 
....................                            buf[0] = (deviceType >> 8) & 0x00FF; 
05546:  MOVFF  38F,5AD
0554A:  MOVLB  5
....................                            buf[1] = (deviceType >> 0) & 0x00FF; 
0554C:  MOVFF  38F,6C6
05550:  MOVFF  38E,5AE
05554:  MOVLB  5
....................                            buf[2] = serie[7]; 
05556:  MOVFF  5AC,5AF
....................                            buf[3] = serie[6]; 
0555A:  MOVFF  5AB,5B0
....................                            buf[4] = serie[5]; 
0555E:  MOVFF  5AA,5B1
....................                            buf[5] = serie[4]; 
05562:  MOVFF  5A9,5B2
....................                            buf[6] = serie[3]; 
05566:  MOVFF  5A8,5B3
....................                            buf[7] = serie[2]; 
0556A:  MOVFF  5A7,5B4
....................                            buf[8] = serie[1]; 
0556E:  MOVFF  5A6,5B5
....................                            buf[9] = serie[0]; 
05572:  MOVFF  5A5,5B6
....................                            SentFormatMIMEPacket(DBIGetDeviceSerie, 10, &buf[0]); 
05576:  MOVLW  D9
05578:  MOVLB  6
0557A:  MOVWF  xC5
0557C:  MOVLW  0A
0557E:  MOVWF  xC6
05580:  MOVLW  05
05582:  MOVWF  xC8
05584:  MOVLW  AD
05586:  MOVWF  xC7
05588:  MOVLB  0
0558A:  CALL   1A92
....................                            break; 
0558E:  GOTO   6362
....................                         } 
....................                         case GoInfoSetRequestTime: 
....................                         { 
....................                            if(Msg_Data[1] == 4) 
05592:  MOVF   x95,W
05594:  SUBLW  04
05596:  BNZ   5600
....................                            { 
....................                               unsigned int32 valor = make32(Msg_Data[2],Msg_Data[3],Msg_Data[4],Msg_Data[5]); 
05598:  MOVFF  96,5BA
0559C:  MOVFF  97,5B9
055A0:  MOVFF  98,5B8
055A4:  MOVFF  99,5B7
....................                               GoIOXstatus.p_TimetoRqstHOS = valor; 
055A8:  MOVFF  5BA,6F
055AC:  MOVFF  5B9,6E
055B0:  MOVFF  5B8,6D
055B4:  MOVFF  5B7,6C
....................                               //fprintf(Serial,"Time to Request Go Info %lu %c%c",GoIOXstatus.p_TimetoRqstHOS,0x1f,0x03); 
....................                               unsigned int8 buf[4]; 
....................                               buf[0] = GoIOXstatus.p_TimetoRqstHOS >> 0 & 0xFF; 
055B8:  MOVFF  6F,6C9
055BC:  MOVFF  6E,6C8
055C0:  MOVFF  6D,6C7
055C4:  MOVFF  6C,5BB
055C8:  MOVLB  5
....................                               buf[1] = GoIOXstatus.p_TimetoRqstHOS >> 8 & 0xFF; 
055CA:  MOVFF  6D,5BC
055CE:  MOVFF  6E,6C7
055D2:  MOVFF  6F,6C8
055D6:  MOVLB  5
....................                               buf[2] = GoIOXstatus.p_TimetoRqstHOS >> 16 & 0xFF; 
055D8:  MOVFF  6E,5BD
055DC:  MOVFF  6F,6C7
055E0:  MOVLB  5
....................                               buf[3] = GoIOXstatus.p_TimetoRqstHOS >> 24 & 0xFF; 
055E2:  MOVFF  6F,5BE
055E6:  MOVLB  5
....................                               SentFormatMIMEPacket(GoInfoGetRequestTime, 4, &buf[0]); 
055E8:  MOVLW  E1
055EA:  MOVLB  6
055EC:  MOVWF  xC5
055EE:  MOVLW  04
055F0:  MOVWF  xC6
055F2:  MOVLW  05
055F4:  MOVWF  xC8
055F6:  MOVLW  BB
055F8:  MOVWF  xC7
055FA:  MOVLB  0
055FC:  CALL   1A92
....................                            } 
....................                            break; 
05600:  GOTO   6362
....................                         } 
....................                         case GoInfoGetRequestTime: 
....................                         { 
....................                            unsigned int8 buf[4]; 
....................                            buf[0] = GoIOXstatus.p_TimetoRqstHOS >> 0 & 0xFF; 
05604:  MOVFF  6F,6C9
05608:  MOVFF  6E,6C8
0560C:  MOVFF  6D,6C7
05610:  MOVFF  6C,5BF
05614:  MOVLB  5
....................                            buf[1] = GoIOXstatus.p_TimetoRqstHOS >> 8 & 0xFF; 
05616:  MOVFF  6D,5C0
0561A:  MOVFF  6E,6C7
0561E:  MOVFF  6F,6C8
05622:  MOVLB  5
....................                            buf[2] = GoIOXstatus.p_TimetoRqstHOS >> 16 & 0xFF; 
05624:  MOVFF  6E,5C1
05628:  MOVFF  6F,6C7
0562C:  MOVLB  5
....................                            buf[3] = GoIOXstatus.p_TimetoRqstHOS >> 24 & 0xFF; 
0562E:  MOVFF  6F,5C2
05632:  MOVLB  5
....................                            SentFormatMIMEPacket(GoInfoGetRequestTime, 4, &buf[0]); 
05634:  MOVLW  E1
05636:  MOVLB  6
05638:  MOVWF  xC5
0563A:  MOVLW  04
0563C:  MOVWF  xC6
0563E:  MOVLW  05
05640:  MOVWF  xC8
05642:  MOVLW  BF
05644:  MOVWF  xC7
05646:  MOVLB  0
05648:  CALL   1A92
....................                            break; 
0564C:  GOTO   6362
....................                         } 
....................                         case GoInfoSetEnableShow: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
05650:  MOVF   x95,W
05652:  SUBLW  04
05654:  BNZ   5692
05656:  MOVF   x96,W
05658:  SUBLW  25
0565A:  BNZ   5692
0565C:  MOVF   x97,W
0565E:  SUBLW  33
05660:  BNZ   5692
05662:  MOVF   x98,W
05664:  SUBLW  41
05666:  BNZ   5692
05668:  MOVF   x99,W
0566A:  SUBLW  49
0566C:  BNZ   5692
....................                            { 
....................                               AllowedFuntions.showGoInfo = true; 
0566E:  BSF    20.7
....................                               //fprintf(Serial,"Auto Show Go Info Enabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.showGoInfo; 
05670:  MOVLB  5
05672:  CLRF   xC3
05674:  BTFSC  20.7
05676:  INCF   xC3,F
....................                               SentFormatMIMEPacket(GoInfoGetEnableShow, 1, &buf[0]); 
05678:  MOVLW  E3
0567A:  MOVLB  6
0567C:  MOVWF  xC5
0567E:  MOVLW  01
05680:  MOVWF  xC6
05682:  MOVLW  05
05684:  MOVWF  xC8
05686:  MOVLW  C3
05688:  MOVWF  xC7
0568A:  MOVLB  0
0568C:  CALL   1A92
....................                            } 
05690:  BRA    56D2
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
05692:  MOVF   x95,W
05694:  SUBLW  04
05696:  BNZ   56D2
05698:  MOVF   x96,W
0569A:  SUBLW  25
0569C:  BNZ   56D2
0569E:  MOVF   x97,W
056A0:  SUBLW  28
056A2:  BNZ   56D2
056A4:  MOVF   x98,W
056A6:  SUBLW  31
056A8:  BNZ   56D2
056AA:  MOVF   x99,W
056AC:  SUBLW  34
056AE:  BNZ   56D2
....................                            { 
....................                               AllowedFuntions.showGoInfo = false; 
056B0:  BCF    20.7
....................                               //fprintf(Serial,"Auto Show Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.showGoInfo; 
056B2:  MOVLB  5
056B4:  CLRF   xC4
056B6:  BTFSC  20.7
056B8:  INCF   xC4,F
....................                               SentFormatMIMEPacket(GoInfoGetEnableShow, 1, &buf[0]); 
056BA:  MOVLW  E3
056BC:  MOVLB  6
056BE:  MOVWF  xC5
056C0:  MOVLW  01
056C2:  MOVWF  xC6
056C4:  MOVLW  05
056C6:  MOVWF  xC8
056C8:  MOVLW  C4
056CA:  MOVWF  xC7
056CC:  MOVLB  0
056CE:  CALL   1A92
....................                            } 
....................                            break; 
056D2:  GOTO   6362
....................                         } 
....................                         case GoInfoGetEnableShow: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.showGoInfo; 
056D6:  MOVLB  5
056D8:  CLRF   xC5
056DA:  BTFSC  20.7
056DC:  INCF   xC5,F
....................                            SentFormatMIMEPacket(GoInfoGetEnableShow, 1, &buf[0]); 
056DE:  MOVLW  E3
056E0:  MOVLB  6
056E2:  MOVWF  xC5
056E4:  MOVLW  01
056E6:  MOVWF  xC6
056E8:  MOVLW  05
056EA:  MOVWF  xC8
056EC:  MOVLW  C5
056EE:  MOVWF  xC7
056F0:  MOVLB  0
056F2:  CALL   1A92
....................                            break; 
056F6:  GOTO   6362
....................                         } 
....................                         case GoInfoSetEnableRqst: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
056FA:  MOVF   x95,W
056FC:  SUBLW  04
056FE:  BNZ   573C
05700:  MOVF   x96,W
05702:  SUBLW  25
05704:  BNZ   573C
05706:  MOVF   x97,W
05708:  SUBLW  33
0570A:  BNZ   573C
0570C:  MOVF   x98,W
0570E:  SUBLW  41
05710:  BNZ   573C
05712:  MOVF   x99,W
05714:  SUBLW  49
05716:  BNZ   573C
....................                            { 
....................                               AllowedFuntions.rqstGoInfo = true; 
05718:  BSF    20.5
....................                               //fprintf(Serial,"Request Go Info Enabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.rqstGoInfo; 
0571A:  MOVLB  5
0571C:  CLRF   xC6
0571E:  BTFSC  20.5
05720:  INCF   xC6,F
....................                               SentFormatMIMEPacket(GoInfoGetEnableRqst, 1, &buf[0]); 
05722:  MOVLW  E5
05724:  MOVLB  6
05726:  MOVWF  xC5
05728:  MOVLW  01
0572A:  MOVWF  xC6
0572C:  MOVLW  05
0572E:  MOVWF  xC8
05730:  MOVLW  C6
05732:  MOVWF  xC7
05734:  MOVLB  0
05736:  CALL   1A92
....................                            } 
0573A:  BRA    577C
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
0573C:  MOVF   x95,W
0573E:  SUBLW  04
05740:  BNZ   577C
05742:  MOVF   x96,W
05744:  SUBLW  25
05746:  BNZ   577C
05748:  MOVF   x97,W
0574A:  SUBLW  28
0574C:  BNZ   577C
0574E:  MOVF   x98,W
05750:  SUBLW  31
05752:  BNZ   577C
05754:  MOVF   x99,W
05756:  SUBLW  34
05758:  BNZ   577C
....................                            { 
....................                               AllowedFuntions.rqstGoInfo = false; 
0575A:  BCF    20.5
....................                               //fprintf(Serial,"Request Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.rqstGoInfo; 
0575C:  MOVLB  5
0575E:  CLRF   xC7
05760:  BTFSC  20.5
05762:  INCF   xC7,F
....................                               SentFormatMIMEPacket(GoInfoGetEnableRqst, 1, &buf[0]); 
05764:  MOVLW  E5
05766:  MOVLB  6
05768:  MOVWF  xC5
0576A:  MOVLW  01
0576C:  MOVWF  xC6
0576E:  MOVLW  05
05770:  MOVWF  xC8
05772:  MOVLW  C7
05774:  MOVWF  xC7
05776:  MOVLB  0
05778:  CALL   1A92
....................                            } 
....................                            break; 
0577C:  GOTO   6362
....................                         } 
....................                         case GoInfoGetEnableRqst: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.rqstGoInfo; 
05780:  MOVLB  5
05782:  CLRF   xC8
05784:  BTFSC  20.5
05786:  INCF   xC8,F
....................                            SentFormatMIMEPacket(GoInfoGetEnableRqst, 1, &buf[0]); 
05788:  MOVLW  E5
0578A:  MOVLB  6
0578C:  MOVWF  xC5
0578E:  MOVLW  01
05790:  MOVWF  xC6
05792:  MOVLW  05
05794:  MOVWF  xC8
05796:  MOVLW  C8
05798:  MOVWF  xC7
0579A:  MOVLB  0
0579C:  CALL   1A92
....................                            break; 
057A0:  GOTO   6362
....................                         }  
....................                         case DBIGetAllInfo: 
....................                         { 
....................                            unsigned int8 index = 0; 
....................                            unsigned int8 buf[60]; 
....................                            Variables result; 
057A4:  MOVLB  5
057A6:  CLRF   xC9
....................                            result = UpDateVariables(); 
057A8:  MOVLB  0
057AA:  CALL   21EC
057AE:  MOVFF  02,03
057B2:  MOVFF  01,FE1
057B6:  MOVFF  02,FE2
057BA:  MOVLW  06
057BC:  MOVWF  FEA
057BE:  MOVWF  FE9
057C0:  MOVLW  27
057C2:  MOVWF  01
057C4:  MOVFF  FE6,FEE
057C8:  DECFSZ 01,F
057CA:  BRA    57C4
....................                             
....................                            buf[index++] = (result.MIMEackByGo >> 8) & 0xFF; 
057CC:  MOVLB  5
057CE:  MOVF   xC9,W
057D0:  INCF   xC9,F
057D2:  CLRF   03
057D4:  ADDLW  CA
057D6:  MOVWF  FE9
057D8:  MOVLW  05
057DA:  ADDWFC 03,W
057DC:  MOVWF  FEA
057DE:  MOVLB  6
057E0:  MOVFF  607,00
057E4:  MOVFF  00,FEF
....................                            buf[index++] = (result.MIMEackByGo >> 0) & 0xFF; 
057E8:  MOVLB  5
057EA:  MOVF   xC9,W
057EC:  INCF   xC9,F
057EE:  CLRF   03
057F0:  ADDLW  CA
057F2:  MOVWF  FE9
057F4:  MOVLW  05
057F6:  ADDWFC 03,W
057F8:  MOVWF  FEA
057FA:  MOVLB  6
057FC:  MOVFF  606,00
05800:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = (result.MIMEackByServer >> 24) & 0xFF; 
05804:  MOVLB  5
05806:  MOVF   xC9,W
05808:  INCF   xC9,F
0580A:  CLRF   03
0580C:  ADDLW  CA
0580E:  MOVWF  FE9
05810:  MOVLW  05
05812:  ADDWFC 03,W
05814:  MOVWF  FEA
05816:  MOVLB  6
05818:  MOVFF  60B,00
0581C:  MOVFF  00,FEF
....................                            buf[index++] = (result.MIMEackByServer >> 16) & 0xFF; 
05820:  MOVLB  5
05822:  MOVF   xC9,W
05824:  INCF   xC9,F
05826:  CLRF   03
05828:  ADDLW  CA
0582A:  MOVWF  FE9
0582C:  MOVLW  05
0582E:  ADDWFC 03,W
05830:  MOVWF  FEA
05832:  MOVLB  6
05834:  MOVFF  60A,00
05838:  MOVFF  00,FEF
....................                            buf[index++] = (result.MIMEackByServer >> 8) & 0xFF; 
0583C:  MOVLB  5
0583E:  MOVF   xC9,W
05840:  INCF   xC9,F
05842:  CLRF   03
05844:  ADDLW  CA
05846:  MOVWF  FE9
05848:  MOVLW  05
0584A:  ADDWFC 03,W
0584C:  MOVWF  FEA
0584E:  MOVLB  6
05850:  MOVFF  609,00
05854:  MOVFF  00,FEF
....................                            buf[index++] = (result.MIMEackByServer >> 0) & 0xFF; 
05858:  MOVLB  5
0585A:  MOVF   xC9,W
0585C:  INCF   xC9,F
0585E:  CLRF   03
05860:  ADDLW  CA
05862:  MOVWF  FE9
05864:  MOVLW  05
05866:  ADDWFC 03,W
05868:  MOVWF  FEA
0586A:  MOVLB  6
0586C:  MOVFF  608,00
05870:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = (result.MIMEmax >> 8) & 0xFF; 
05874:  MOVLB  5
05876:  MOVF   xC9,W
05878:  INCF   xC9,F
0587A:  CLRF   03
0587C:  ADDLW  CA
0587E:  MOVWF  FE9
05880:  MOVLW  05
05882:  ADDWFC 03,W
05884:  MOVWF  FEA
05886:  MOVLB  6
05888:  MOVFF  60D,00
0588C:  MOVFF  00,FEF
....................                            buf[index++] = (result.MIMEmax >> 0) & 0xFF; 
05890:  MOVLB  5
05892:  MOVF   xC9,W
05894:  INCF   xC9,F
05896:  CLRF   03
05898:  ADDLW  CA
0589A:  MOVWF  FE9
0589C:  MOVLW  05
0589E:  ADDWFC 03,W
058A0:  MOVWF  FEA
058A2:  MOVLB  6
058A4:  MOVFF  60C,00
058A8:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = result.MIMEoutEnabled; 
058AC:  MOVLB  5
058AE:  MOVF   xC9,W
058B0:  INCF   xC9,F
058B2:  CLRF   03
058B4:  ADDLW  CA
058B6:  MOVWF  FE9
058B8:  MOVLW  05
058BA:  ADDWFC 03,W
058BC:  MOVWF  FEA
058BE:  MOVLW  00
058C0:  MOVLB  6
058C2:  BTFSC  x0E.0
058C4:  MOVLW  01
058C6:  MOVWF  FEF
....................                            buf[index++] = result.MIMEinEnabled; 
058C8:  MOVLB  5
058CA:  MOVF   xC9,W
058CC:  INCF   xC9,F
058CE:  CLRF   03
058D0:  ADDLW  CA
058D2:  MOVWF  FE9
058D4:  MOVLW  05
058D6:  ADDWFC 03,W
058D8:  MOVWF  FEA
058DA:  MOVLW  00
058DC:  MOVLB  6
058DE:  BTFSC  x0E.1
058E0:  MOVLW  01
058E2:  MOVWF  FEF
....................                            buf[index++] = result.MIMEWaitACKtoSend; 
058E4:  MOVLB  5
058E6:  MOVF   xC9,W
058E8:  INCF   xC9,F
058EA:  CLRF   03
058EC:  ADDLW  CA
058EE:  MOVWF  FE9
058F0:  MOVLW  05
058F2:  ADDWFC 03,W
058F4:  MOVWF  FEA
058F6:  MOVLW  00
058F8:  MOVLB  6
058FA:  BTFSC  x0E.2
058FC:  MOVLW  01
058FE:  MOVWF  FEF
....................                            buf[index++] = result.MIMEautoResponseACK; 
05900:  MOVLB  5
05902:  MOVF   xC9,W
05904:  INCF   xC9,F
05906:  CLRF   03
05908:  ADDLW  CA
0590A:  MOVWF  FE9
0590C:  MOVLW  05
0590E:  ADDWFC 03,W
05910:  MOVWF  FEA
05912:  MOVLW  00
05914:  MOVLB  6
05916:  BTFSC  x0E.3
05918:  MOVLW  01
0591A:  MOVWF  FEF
....................                             
....................                            buf[index++] = (result.CSackByGo >> 8) & 0xFF; 
0591C:  MOVLB  5
0591E:  MOVF   xC9,W
05920:  INCF   xC9,F
05922:  CLRF   03
05924:  ADDLW  CA
05926:  MOVWF  FE9
05928:  MOVLW  05
0592A:  ADDWFC 03,W
0592C:  MOVWF  FEA
0592E:  MOVLB  6
05930:  MOVFF  610,00
05934:  MOVFF  00,FEF
....................                            buf[index++] = (result.CSackByGo >> 0) & 0xFF; 
05938:  MOVLB  5
0593A:  MOVF   xC9,W
0593C:  INCF   xC9,F
0593E:  CLRF   03
05940:  ADDLW  CA
05942:  MOVWF  FE9
05944:  MOVLW  05
05946:  ADDWFC 03,W
05948:  MOVWF  FEA
0594A:  MOVLB  6
0594C:  MOVFF  60F,00
05950:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = (result.CSmax >> 8) & 0xFF; 
05954:  MOVLB  5
05956:  MOVF   xC9,W
05958:  INCF   xC9,F
0595A:  CLRF   03
0595C:  ADDLW  CA
0595E:  MOVWF  FE9
05960:  MOVLW  05
05962:  ADDWFC 03,W
05964:  MOVWF  FEA
05966:  MOVLB  6
05968:  MOVFF  612,00
0596C:  MOVFF  00,FEF
....................                            buf[index++] = (result.CSmax >> 0) & 0xFF; 
05970:  MOVLB  5
05972:  MOVF   xC9,W
05974:  INCF   xC9,F
05976:  CLRF   03
05978:  ADDLW  CA
0597A:  MOVWF  FE9
0597C:  MOVLW  05
0597E:  ADDWFC 03,W
05980:  MOVWF  FEA
05982:  MOVLB  6
05984:  MOVFF  611,00
05988:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = result.CScustomEnabled; 
0598C:  MOVLB  5
0598E:  MOVF   xC9,W
05990:  INCF   xC9,F
05992:  CLRF   03
05994:  ADDLW  CA
05996:  MOVWF  FE9
05998:  MOVLW  05
0599A:  ADDWFC 03,W
0599C:  MOVWF  FEA
0599E:  MOVLW  00
059A0:  MOVLB  6
059A2:  BTFSC  x0E.4
059A4:  MOVLW  01
059A6:  MOVWF  FEF
....................                            buf[index++] = result.CSstatusEnabled; 
059A8:  MOVLB  5
059AA:  MOVF   xC9,W
059AC:  INCF   xC9,F
059AE:  CLRF   03
059B0:  ADDLW  CA
059B2:  MOVWF  FE9
059B4:  MOVLW  05
059B6:  ADDWFC 03,W
059B8:  MOVWF  FEA
059BA:  MOVLW  00
059BC:  MOVLB  6
059BE:  BTFSC  x0E.5
059C0:  MOVLW  01
059C2:  MOVWF  FEF
....................                             
....................                            buf[index++] = (result.HOStimeToResquest >> 24) & 0xFF; 
059C4:  MOVLB  5
059C6:  MOVF   xC9,W
059C8:  INCF   xC9,F
059CA:  CLRF   03
059CC:  ADDLW  CA
059CE:  MOVWF  FE9
059D0:  MOVLW  05
059D2:  ADDWFC 03,W
059D4:  MOVWF  FEA
059D6:  MOVLB  6
059D8:  MOVFF  616,00
059DC:  MOVFF  00,FEF
....................                            buf[index++] = (result.HOStimeToResquest >> 16) & 0xFF; 
059E0:  MOVLB  5
059E2:  MOVF   xC9,W
059E4:  INCF   xC9,F
059E6:  CLRF   03
059E8:  ADDLW  CA
059EA:  MOVWF  FE9
059EC:  MOVLW  05
059EE:  ADDWFC 03,W
059F0:  MOVWF  FEA
059F2:  MOVLB  6
059F4:  MOVFF  615,00
059F8:  MOVFF  00,FEF
....................                            buf[index++] = (result.HOStimeToResquest >> 8) & 0xFF; 
059FC:  MOVLB  5
059FE:  MOVF   xC9,W
05A00:  INCF   xC9,F
05A02:  CLRF   03
05A04:  ADDLW  CA
05A06:  MOVWF  FE9
05A08:  MOVLW  05
05A0A:  ADDWFC 03,W
05A0C:  MOVWF  FEA
05A0E:  MOVLB  6
05A10:  MOVFF  614,00
05A14:  MOVFF  00,FEF
....................                            buf[index++] = (result.HOStimeToResquest >> 0) & 0xFF; 
05A18:  MOVLB  5
05A1A:  MOVF   xC9,W
05A1C:  INCF   xC9,F
05A1E:  CLRF   03
05A20:  ADDLW  CA
05A22:  MOVWF  FE9
05A24:  MOVLW  05
05A26:  ADDWFC 03,W
05A28:  MOVWF  FEA
05A2A:  MOVLB  6
05A2C:  MOVFF  613,00
05A30:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = result.HOSautoShowEnabled; 
05A34:  MOVLB  5
05A36:  MOVF   xC9,W
05A38:  INCF   xC9,F
05A3A:  CLRF   03
05A3C:  ADDLW  CA
05A3E:  MOVWF  FE9
05A40:  MOVLW  05
05A42:  ADDWFC 03,W
05A44:  MOVWF  FEA
05A46:  MOVLW  00
05A48:  MOVLB  6
05A4A:  BTFSC  x0E.6
05A4C:  MOVLW  01
05A4E:  MOVWF  FEF
....................                            buf[index++] = result.HOSrqstEnabled; 
05A50:  MOVLB  5
05A52:  MOVF   xC9,W
05A54:  INCF   xC9,F
05A56:  CLRF   03
05A58:  ADDLW  CA
05A5A:  MOVWF  FE9
05A5C:  MOVLW  05
05A5E:  ADDWFC 03,W
05A60:  MOVWF  FEA
05A62:  MOVLW  00
05A64:  MOVLB  6
05A66:  BTFSC  x0E.7
05A68:  MOVLW  01
05A6A:  MOVWF  FEF
....................                             
....................                            buf[index++] = result.ACTmode; 
05A6C:  MOVLB  5
05A6E:  MOVF   xC9,W
05A70:  INCF   xC9,F
05A72:  CLRF   03
05A74:  ADDLW  CA
05A76:  MOVWF  FE9
05A78:  MOVLW  05
05A7A:  ADDWFC 03,W
05A7C:  MOVWF  FEA
05A7E:  MOVFF  617,FEF
....................                            buf[index++] = result.ACTstatus; 
05A82:  MOVF   xC9,W
05A84:  INCF   xC9,F
05A86:  CLRF   03
05A88:  ADDLW  CA
05A8A:  MOVWF  FE9
05A8C:  MOVLW  05
05A8E:  ADDWFC 03,W
05A90:  MOVWF  FEA
05A92:  MOVLW  00
05A94:  MOVLB  6
05A96:  BTFSC  x24.0
05A98:  MOVLW  01
05A9A:  MOVWF  FEF
....................                             
....................                            buf[index++] = (result.ACTtoReset >> 24) & 0xFF; 
05A9C:  MOVLB  5
05A9E:  MOVF   xC9,W
05AA0:  INCF   xC9,F
05AA2:  CLRF   03
05AA4:  ADDLW  CA
05AA6:  MOVWF  FE9
05AA8:  MOVLW  05
05AAA:  ADDWFC 03,W
05AAC:  MOVWF  FEA
05AAE:  MOVLB  6
05AB0:  MOVFF  61B,00
05AB4:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtoReset >> 16) & 0xFF; 
05AB8:  MOVLB  5
05ABA:  MOVF   xC9,W
05ABC:  INCF   xC9,F
05ABE:  CLRF   03
05AC0:  ADDLW  CA
05AC2:  MOVWF  FE9
05AC4:  MOVLW  05
05AC6:  ADDWFC 03,W
05AC8:  MOVWF  FEA
05ACA:  MOVLB  6
05ACC:  MOVFF  61A,00
05AD0:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtoReset >> 8) & 0xFF; 
05AD4:  MOVLB  5
05AD6:  MOVF   xC9,W
05AD8:  INCF   xC9,F
05ADA:  CLRF   03
05ADC:  ADDLW  CA
05ADE:  MOVWF  FE9
05AE0:  MOVLW  05
05AE2:  ADDWFC 03,W
05AE4:  MOVWF  FEA
05AE6:  MOVLB  6
05AE8:  MOVFF  619,00
05AEC:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtoReset >> 0) & 0xFF; 
05AF0:  MOVLB  5
05AF2:  MOVF   xC9,W
05AF4:  INCF   xC9,F
05AF6:  CLRF   03
05AF8:  ADDLW  CA
05AFA:  MOVWF  FE9
05AFC:  MOVLW  05
05AFE:  ADDWFC 03,W
05B00:  MOVWF  FEA
05B02:  MOVLB  6
05B04:  MOVFF  618,00
05B08:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = (result.ACTinReset >> 24) & 0xFF; 
05B0C:  MOVLB  5
05B0E:  MOVF   xC9,W
05B10:  INCF   xC9,F
05B12:  CLRF   03
05B14:  ADDLW  CA
05B16:  MOVWF  FE9
05B18:  MOVLW  05
05B1A:  ADDWFC 03,W
05B1C:  MOVWF  FEA
05B1E:  MOVLB  6
05B20:  MOVFF  61F,00
05B24:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTinReset >> 16) & 0xFF; 
05B28:  MOVLB  5
05B2A:  MOVF   xC9,W
05B2C:  INCF   xC9,F
05B2E:  CLRF   03
05B30:  ADDLW  CA
05B32:  MOVWF  FE9
05B34:  MOVLW  05
05B36:  ADDWFC 03,W
05B38:  MOVWF  FEA
05B3A:  MOVLB  6
05B3C:  MOVFF  61E,00
05B40:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTinReset >> 8) & 0xFF; 
05B44:  MOVLB  5
05B46:  MOVF   xC9,W
05B48:  INCF   xC9,F
05B4A:  CLRF   03
05B4C:  ADDLW  CA
05B4E:  MOVWF  FE9
05B50:  MOVLW  05
05B52:  ADDWFC 03,W
05B54:  MOVWF  FEA
05B56:  MOVLB  6
05B58:  MOVFF  61D,00
05B5C:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTinReset >> 0) & 0xFF; 
05B60:  MOVLB  5
05B62:  MOVF   xC9,W
05B64:  INCF   xC9,F
05B66:  CLRF   03
05B68:  ADDLW  CA
05B6A:  MOVWF  FE9
05B6C:  MOVLW  05
05B6E:  ADDWFC 03,W
05B70:  MOVWF  FEA
05B72:  MOVLB  6
05B74:  MOVFF  61C,00
05B78:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = (result.ACTtimeOutPIN >> 24) & 0xFF; 
05B7C:  MOVLB  5
05B7E:  MOVF   xC9,W
05B80:  INCF   xC9,F
05B82:  CLRF   03
05B84:  ADDLW  CA
05B86:  MOVWF  FE9
05B88:  MOVLW  05
05B8A:  ADDWFC 03,W
05B8C:  MOVWF  FEA
05B8E:  MOVLB  6
05B90:  MOVFF  623,00
05B94:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtimeOutPIN >> 16) & 0xFF; 
05B98:  MOVLB  5
05B9A:  MOVF   xC9,W
05B9C:  INCF   xC9,F
05B9E:  CLRF   03
05BA0:  ADDLW  CA
05BA2:  MOVWF  FE9
05BA4:  MOVLW  05
05BA6:  ADDWFC 03,W
05BA8:  MOVWF  FEA
05BAA:  MOVLB  6
05BAC:  MOVFF  622,00
05BB0:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtimeOutPIN >> 8) & 0xFF; 
05BB4:  MOVLB  5
05BB6:  MOVF   xC9,W
05BB8:  INCF   xC9,F
05BBA:  CLRF   03
05BBC:  ADDLW  CA
05BBE:  MOVWF  FE9
05BC0:  MOVLW  05
05BC2:  ADDWFC 03,W
05BC4:  MOVWF  FEA
05BC6:  MOVLB  6
05BC8:  MOVFF  621,00
05BCC:  MOVFF  00,FEF
....................                            buf[index++] = (result.ACTtimeOutPIN >> 0) & 0xFF; 
05BD0:  MOVLB  5
05BD2:  MOVF   xC9,W
05BD4:  INCF   xC9,F
05BD6:  CLRF   03
05BD8:  ADDLW  CA
05BDA:  MOVWF  FE9
05BDC:  MOVLW  05
05BDE:  ADDWFC 03,W
05BE0:  MOVWF  FEA
05BE2:  MOVLB  6
05BE4:  MOVFF  620,00
05BE8:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = result.ACTenableClientRequest; 
05BEC:  MOVLB  5
05BEE:  MOVF   xC9,W
05BF0:  INCF   xC9,F
05BF2:  CLRF   03
05BF4:  ADDLW  CA
05BF6:  MOVWF  FE9
05BF8:  MOVLW  05
05BFA:  ADDWFC 03,W
05BFC:  MOVWF  FEA
05BFE:  MOVLW  00
05C00:  MOVLB  6
05C02:  BTFSC  x24.1
05C04:  MOVLW  01
05C06:  MOVWF  FEF
....................                             
....................                            buf[index++] = (result.DBItimeToHeartBeat >> 24) & 0xFF; 
05C08:  MOVLB  5
05C0A:  MOVF   xC9,W
05C0C:  INCF   xC9,F
05C0E:  CLRF   03
05C10:  ADDLW  CA
05C12:  MOVWF  FE9
05C14:  MOVLW  05
05C16:  ADDWFC 03,W
05C18:  MOVWF  FEA
05C1A:  MOVLB  6
05C1C:  MOVFF  628,00
05C20:  MOVFF  00,FEF
....................                            buf[index++] = (result.DBItimeToHeartBeat >> 16) & 0xFF; 
05C24:  MOVLB  5
05C26:  MOVF   xC9,W
05C28:  INCF   xC9,F
05C2A:  CLRF   03
05C2C:  ADDLW  CA
05C2E:  MOVWF  FE9
05C30:  MOVLW  05
05C32:  ADDWFC 03,W
05C34:  MOVWF  FEA
05C36:  MOVLB  6
05C38:  MOVFF  627,00
05C3C:  MOVFF  00,FEF
....................                            buf[index++] = (result.DBItimeToHeartBeat >> 8) & 0xFF; 
05C40:  MOVLB  5
05C42:  MOVF   xC9,W
05C44:  INCF   xC9,F
05C46:  CLRF   03
05C48:  ADDLW  CA
05C4A:  MOVWF  FE9
05C4C:  MOVLW  05
05C4E:  ADDWFC 03,W
05C50:  MOVWF  FEA
05C52:  MOVLB  6
05C54:  MOVFF  626,00
05C58:  MOVFF  00,FEF
....................                            buf[index++] = (result.DBItimeToHeartBeat >> 0) & 0xFF; 
05C5C:  MOVLB  5
05C5E:  MOVF   xC9,W
05C60:  INCF   xC9,F
05C62:  CLRF   03
05C64:  ADDLW  CA
05C66:  MOVWF  FE9
05C68:  MOVLW  05
05C6A:  ADDWFC 03,W
05C6C:  MOVWF  FEA
05C6E:  MOVLB  6
05C70:  MOVFF  625,00
05C74:  MOVFF  00,FEF
....................                             
....................                            buf[index++] = result.DBIheartBeatEnabled; 
05C78:  MOVLB  5
05C7A:  MOVF   xC9,W
05C7C:  INCF   xC9,F
05C7E:  CLRF   03
05C80:  ADDLW  CA
05C82:  MOVWF  FE9
05C84:  MOVLW  05
05C86:  ADDWFC 03,W
05C88:  MOVWF  FEA
05C8A:  MOVLW  00
05C8C:  MOVLB  6
05C8E:  BTFSC  x24.2
05C90:  MOVLW  01
05C92:  MOVWF  FEF
....................                             
....................                            buf[index++] = result.InputEnableShow; 
05C94:  MOVLB  5
05C96:  MOVF   xC9,W
05C98:  INCF   xC9,F
05C9A:  CLRF   03
05C9C:  ADDLW  CA
05C9E:  MOVWF  FE9
05CA0:  MOVLW  05
05CA2:  ADDWFC 03,W
05CA4:  MOVWF  FEA
05CA6:  MOVLW  00
05CA8:  MOVLB  6
05CAA:  BTFSC  x24.3
05CAC:  MOVLW  01
05CAE:  MOVWF  FEF
....................                            buf[index++] = result.InputEnablestatus; 
05CB0:  MOVLB  5
05CB2:  MOVF   xC9,W
05CB4:  INCF   xC9,F
05CB6:  CLRF   03
05CB8:  ADDLW  CA
05CBA:  MOVWF  FE9
05CBC:  MOVLW  05
05CBE:  ADDWFC 03,W
05CC0:  MOVWF  FEA
05CC2:  MOVLW  00
05CC4:  MOVLB  6
05CC6:  BTFSC  x24.4
05CC8:  MOVLW  01
05CCA:  MOVWF  FEF
....................                            buf[index++] = (result.InputTimeToSense >> 8) & 0xFF; 
05CCC:  MOVLB  5
05CCE:  MOVF   xC9,W
05CD0:  INCF   xC9,F
05CD2:  CLRF   03
05CD4:  ADDLW  CA
05CD6:  MOVWF  FE9
05CD8:  MOVLW  05
05CDA:  ADDWFC 03,W
05CDC:  MOVWF  FEA
05CDE:  MOVLB  6
05CE0:  MOVFF  62C,00
05CE4:  MOVFF  00,FEF
....................                            buf[index++] = (result.InputTimeToSense >> 0) & 0xFF; 
05CE8:  MOVLB  5
05CEA:  MOVF   xC9,W
05CEC:  INCF   xC9,F
05CEE:  CLRF   03
05CF0:  ADDLW  CA
05CF2:  MOVWF  FE9
05CF4:  MOVLW  05
05CF6:  ADDWFC 03,W
05CF8:  MOVWF  FEA
05CFA:  MOVLB  6
05CFC:  MOVFF  62B,00
05D00:  MOVFF  00,FEF
....................                            buf[index++] = (result.InputStatusDataId >> 8) & 0xFF; 
05D04:  MOVLB  5
05D06:  MOVF   xC9,W
05D08:  INCF   xC9,F
05D0A:  CLRF   03
05D0C:  ADDLW  CA
05D0E:  MOVWF  FE9
05D10:  MOVLW  05
05D12:  ADDWFC 03,W
05D14:  MOVWF  FEA
05D16:  MOVLB  6
05D18:  MOVFF  62A,00
05D1C:  MOVFF  00,FEF
....................                            buf[index++] = (result.InputStatusDataId >> 0) & 0xFF; 
05D20:  MOVLB  5
05D22:  MOVF   xC9,W
05D24:  INCF   xC9,F
05D26:  CLRF   03
05D28:  ADDLW  CA
05D2A:  MOVWF  FE9
05D2C:  MOVLW  05
05D2E:  ADDWFC 03,W
05D30:  MOVWF  FEA
05D32:  MOVLB  6
05D34:  MOVFF  629,00
05D38:  MOVFF  00,FEF
....................                            buf[index++] = result.InputEnableSaveEeprom; 
05D3C:  MOVLB  5
05D3E:  MOVF   xC9,W
05D40:  INCF   xC9,F
05D42:  CLRF   03
05D44:  ADDLW  CA
05D46:  MOVWF  FE9
05D48:  MOVLW  05
05D4A:  ADDWFC 03,W
05D4C:  MOVWF  FEA
05D4E:  MOVLW  00
05D50:  MOVLB  6
05D52:  BTFSC  x24.5
05D54:  MOVLW  01
05D56:  MOVWF  FEF
....................                            buf[index++] = result.InputValueToSave; 
05D58:  MOVLB  5
05D5A:  MOVF   xC9,W
05D5C:  INCF   xC9,F
05D5E:  CLRF   03
05D60:  ADDLW  CA
05D62:  MOVWF  FE9
05D64:  MOVLW  05
05D66:  ADDWFC 03,W
05D68:  MOVWF  FEA
05D6A:  MOVLW  00
05D6C:  MOVLB  6
05D6E:  BTFSC  x24.6
05D70:  MOVLW  01
05D72:  MOVWF  FEF
....................                             
....................                            buf[index++] = firmwareMajorVersion; 
05D74:  MOVLB  5
05D76:  MOVF   xC9,W
05D78:  INCF   xC9,F
05D7A:  CLRF   03
05D7C:  ADDLW  CA
05D7E:  MOVWF  FE9
05D80:  MOVLW  05
05D82:  ADDWFC 03,W
05D84:  MOVWF  FEA
05D86:  MOVFF  22,FEF
....................                            buf[index++] = firmwareMinorVersion; 
05D8A:  MOVF   xC9,W
05D8C:  INCF   xC9,F
05D8E:  CLRF   03
05D90:  ADDLW  CA
05D92:  MOVWF  FE9
05D94:  MOVLW  05
05D96:  ADDWFC 03,W
05D98:  MOVWF  FEA
05D9A:  MOVFF  23,FEF
....................                            buf[index++] = HardwareMajorVersion; 
05D9E:  MOVF   xC9,W
05DA0:  INCF   xC9,F
05DA2:  CLRF   03
05DA4:  ADDLW  CA
05DA6:  MOVWF  FE9
05DA8:  MOVLW  05
05DAA:  ADDWFC 03,W
05DAC:  MOVWF  FEA
05DAE:  MOVFF  24,FEF
....................                            buf[index++] = HardwareMinorVersion; 
05DB2:  MOVF   xC9,W
05DB4:  INCF   xC9,F
05DB6:  CLRF   03
05DB8:  ADDLW  CA
05DBA:  MOVWF  FE9
05DBC:  MOVLW  05
05DBE:  ADDWFC 03,W
05DC0:  MOVWF  FEA
05DC2:  MOVFF  25,FEF
....................                             
....................                            SentFormatMIMEPacket(DBIGetAllInfo, index, &buf[0]); 
05DC6:  MOVLW  D8
05DC8:  MOVLB  6
05DCA:  MOVWF  xC5
05DCC:  MOVFF  5C9,6C6
05DD0:  MOVLW  05
05DD2:  MOVWF  xC8
05DD4:  MOVLW  CA
05DD6:  MOVWF  xC7
05DD8:  MOVLB  0
05DDA:  CALL   1A92
....................                            break; 
05DDE:  BRA    6362
....................                         } 
....................                         case EepromSaveAll: 
....................                         { 
....................                            Variables structNow; 
....................                            structNow = UpDateVariables(); 
05DE0:  CALL   21EC
05DE4:  MOVFF  02,03
05DE8:  MOVFF  01,FE1
05DEC:  MOVFF  02,FE2
05DF0:  MOVLW  06
05DF2:  MOVWF  FEA
05DF4:  MOVLW  2D
05DF6:  MOVWF  FE9
05DF8:  MOVLW  27
05DFA:  MOVWF  01
05DFC:  MOVFF  FE6,FEE
05E00:  DECFSZ 01,F
05E02:  BRA    5DFC
....................                            if(CompareStructs(ValoresIniciales, structNow)) 
05E04:  MOVFF  26,6C5
05E08:  MOVFF  27,6C6
05E0C:  MOVFF  28,6C7
05E10:  MOVFF  29,6C8
05E14:  MOVFF  2A,6C9
05E18:  MOVFF  2B,6CA
05E1C:  MOVFF  2C,6CB
05E20:  MOVFF  2D,6CC
05E24:  MOVFF  2E,6CD
05E28:  MOVFF  2F,6CE
05E2C:  MOVFF  30,6CF
05E30:  MOVFF  31,6D0
05E34:  MOVFF  32,6D1
05E38:  MOVFF  33,6D2
05E3C:  MOVFF  34,6D3
05E40:  MOVFF  35,6D4
05E44:  MOVFF  36,6D5
05E48:  MOVFF  37,6D6
05E4C:  MOVFF  38,6D7
05E50:  MOVFF  39,6D8
05E54:  MOVFF  3A,6D9
05E58:  MOVFF  3B,6DA
05E5C:  MOVFF  3C,6DB
05E60:  MOVFF  3D,6DC
05E64:  MOVFF  3E,6DD
05E68:  MOVFF  3F,6DE
05E6C:  MOVFF  40,6DF
05E70:  MOVFF  41,6E0
05E74:  MOVFF  42,6E1
05E78:  MOVFF  43,6E2
05E7C:  MOVFF  44,6E3
05E80:  MOVFF  45,6E4
05E84:  MOVFF  46,6E5
05E88:  MOVFF  47,6E6
05E8C:  MOVFF  48,6E7
05E90:  MOVFF  49,6E8
05E94:  MOVFF  4A,6E9
05E98:  MOVFF  4B,6EA
05E9C:  MOVFF  4C,6EB
05EA0:  MOVFF  62D,6EC
05EA4:  MOVFF  62E,6ED
05EA8:  MOVFF  62F,6EE
05EAC:  MOVFF  630,6EF
05EB0:  MOVFF  631,6F0
05EB4:  MOVFF  632,6F1
05EB8:  MOVFF  633,6F2
05EBC:  MOVFF  634,6F3
05EC0:  MOVFF  635,6F4
05EC4:  MOVFF  636,6F5
05EC8:  MOVFF  637,6F6
05ECC:  MOVFF  638,6F7
05ED0:  MOVFF  639,6F8
05ED4:  MOVFF  63A,6F9
05ED8:  MOVFF  63B,6FA
05EDC:  MOVFF  63C,6FB
05EE0:  MOVFF  63D,6FC
05EE4:  MOVFF  63E,6FD
05EE8:  MOVFF  63F,6FE
05EEC:  MOVFF  640,6FF
05EF0:  MOVFF  641,700
05EF4:  MOVFF  642,701
05EF8:  MOVFF  643,702
05EFC:  MOVFF  644,703
05F00:  MOVFF  645,704
05F04:  MOVFF  646,705
05F08:  MOVFF  647,706
05F0C:  MOVFF  648,707
05F10:  MOVFF  649,708
05F14:  MOVFF  64A,709
05F18:  MOVFF  64B,70A
05F1C:  MOVFF  64C,70B
05F20:  MOVFF  64D,70C
05F24:  MOVFF  64E,70D
05F28:  MOVFF  64F,70E
05F2C:  MOVFF  650,70F
05F30:  MOVFF  651,710
05F34:  MOVFF  652,711
05F38:  MOVFF  653,712
05F3C:  CALL   24F0
05F40:  MOVF   01,F
05F42:  BZ    6000
....................                            { 
....................                               EepromSave(structNow); 
05F44:  MOVFF  62D,6C5
05F48:  MOVFF  62E,6C6
05F4C:  MOVFF  62F,6C7
05F50:  MOVFF  630,6C8
05F54:  MOVFF  631,6C9
05F58:  MOVFF  632,6CA
05F5C:  MOVFF  633,6CB
05F60:  MOVFF  634,6CC
05F64:  MOVFF  635,6CD
05F68:  MOVFF  636,6CE
05F6C:  MOVFF  637,6CF
05F70:  MOVFF  638,6D0
05F74:  MOVFF  639,6D1
05F78:  MOVFF  63A,6D2
05F7C:  MOVFF  63B,6D3
05F80:  MOVFF  63C,6D4
05F84:  MOVFF  63D,6D5
05F88:  MOVFF  63E,6D6
05F8C:  MOVFF  63F,6D7
05F90:  MOVFF  640,6D8
05F94:  MOVFF  641,6D9
05F98:  MOVFF  642,6DA
05F9C:  MOVFF  643,6DB
05FA0:  MOVFF  644,6DC
05FA4:  MOVFF  645,6DD
05FA8:  MOVFF  646,6DE
05FAC:  MOVFF  647,6DF
05FB0:  MOVFF  648,6E0
05FB4:  MOVFF  649,6E1
05FB8:  MOVFF  64A,6E2
05FBC:  MOVFF  64B,6E3
05FC0:  MOVFF  64C,6E4
05FC4:  MOVFF  64D,6E5
05FC8:  MOVFF  64E,6E6
05FCC:  MOVFF  64F,6E7
05FD0:  MOVFF  650,6E8
05FD4:  MOVFF  651,6E9
05FD8:  MOVFF  652,6EA
05FDC:  MOVFF  653,6EB
05FE0:  CALL   2552
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = BloqueEeprom; 
05FE4:  MOVFF  4E,654
....................                               SentFormatMIMEPacket(EepromAllSaved, 1, &buf[0]); 
05FE8:  MOVLW  95
05FEA:  MOVLB  6
05FEC:  MOVWF  xC5
05FEE:  MOVLW  01
05FF0:  MOVWF  xC6
05FF2:  MOVLW  06
05FF4:  MOVWF  xC8
05FF6:  MOVLW  54
05FF8:  MOVWF  xC7
05FFA:  MOVLB  0
05FFC:  CALL   1A92
....................                            } 
....................                            break; 
06000:  BRA    6362
....................                         } 
....................                         case InputSetEnableShow: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
06002:  MOVF   x95,W
06004:  SUBLW  04
06006:  BNZ   6042
06008:  MOVF   x96,W
0600A:  SUBLW  25
0600C:  BNZ   6042
0600E:  MOVF   x97,W
06010:  SUBLW  33
06012:  BNZ   6042
06014:  MOVF   x98,W
06016:  SUBLW  41
06018:  BNZ   6042
0601A:  MOVF   x99,W
0601C:  SUBLW  49
0601E:  BNZ   6042
....................                            { 
....................                               AllowedFuntions.showInputstatus = true; 
06020:  BSF    21.1
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.showInputstatus; 
06022:  MOVLB  6
06024:  CLRF   x55
06026:  BTFSC  21.1
06028:  INCF   x55,F
....................                               SentFormatMIMEPacket(InputGetEnableShow, 1, &buf[0]); 
0602A:  MOVLW  81
0602C:  MOVWF  xC5
0602E:  MOVLW  01
06030:  MOVWF  xC6
06032:  MOVLW  06
06034:  MOVWF  xC8
06036:  MOVLW  55
06038:  MOVWF  xC7
0603A:  MOVLB  0
0603C:  CALL   1A92
....................                            } 
06040:  BRA    6080
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
06042:  MOVF   x95,W
06044:  SUBLW  04
06046:  BNZ   6080
06048:  MOVF   x96,W
0604A:  SUBLW  25
0604C:  BNZ   6080
0604E:  MOVF   x97,W
06050:  SUBLW  28
06052:  BNZ   6080
06054:  MOVF   x98,W
06056:  SUBLW  31
06058:  BNZ   6080
0605A:  MOVF   x99,W
0605C:  SUBLW  34
0605E:  BNZ   6080
....................                            { 
....................                               AllowedFuntions.showInputstatus = false; 
06060:  BCF    21.1
....................                               //fprintf(Serial,"Auto Show Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.showInputstatus; 
06062:  MOVLB  6
06064:  CLRF   x56
06066:  BTFSC  21.1
06068:  INCF   x56,F
....................                               SentFormatMIMEPacket(InputGetEnableShow, 1, &buf[0]); 
0606A:  MOVLW  81
0606C:  MOVWF  xC5
0606E:  MOVLW  01
06070:  MOVWF  xC6
06072:  MOVLW  06
06074:  MOVWF  xC8
06076:  MOVLW  56
06078:  MOVWF  xC7
0607A:  MOVLB  0
0607C:  CALL   1A92
....................                            } 
....................                            break; 
06080:  BRA    6362
....................                         } 
....................                         case InputGetEnableShow: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.showInputstatus; 
06082:  MOVLB  6
06084:  CLRF   x57
06086:  BTFSC  21.1
06088:  INCF   x57,F
....................                            SentFormatMIMEPacket(InputGetEnableShow, 1, &buf[0]); 
0608A:  MOVLW  81
0608C:  MOVWF  xC5
0608E:  MOVLW  01
06090:  MOVWF  xC6
06092:  MOVLW  06
06094:  MOVWF  xC8
06096:  MOVLW  57
06098:  MOVWF  xC7
0609A:  MOVLB  0
0609C:  CALL   1A92
....................                            break; 
060A0:  BRA    6362
....................                         }  
....................                         case InputSetEnableStatus: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
060A2:  MOVF   x95,W
060A4:  SUBLW  04
060A6:  BNZ   60E2
060A8:  MOVF   x96,W
060AA:  SUBLW  25
060AC:  BNZ   60E2
060AE:  MOVF   x97,W
060B0:  SUBLW  33
060B2:  BNZ   60E2
060B4:  MOVF   x98,W
060B6:  SUBLW  41
060B8:  BNZ   60E2
060BA:  MOVF   x99,W
060BC:  SUBLW  49
060BE:  BNZ   60E2
....................                            { 
....................                               AllowedFuntions.sendInputstatus = true; 
060C0:  BSF    21.2
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.sendInputstatus; 
060C2:  MOVLB  6
060C4:  CLRF   x58
060C6:  BTFSC  21.2
060C8:  INCF   x58,F
....................                               SentFormatMIMEPacket(InputGetEnableStatus, 1, &buf[0]); 
060CA:  MOVLW  83
060CC:  MOVWF  xC5
060CE:  MOVLW  01
060D0:  MOVWF  xC6
060D2:  MOVLW  06
060D4:  MOVWF  xC8
060D6:  MOVLW  58
060D8:  MOVWF  xC7
060DA:  MOVLB  0
060DC:  CALL   1A92
....................                            } 
060E0:  BRA    6120
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
060E2:  MOVF   x95,W
060E4:  SUBLW  04
060E6:  BNZ   6120
060E8:  MOVF   x96,W
060EA:  SUBLW  25
060EC:  BNZ   6120
060EE:  MOVF   x97,W
060F0:  SUBLW  28
060F2:  BNZ   6120
060F4:  MOVF   x98,W
060F6:  SUBLW  31
060F8:  BNZ   6120
060FA:  MOVF   x99,W
060FC:  SUBLW  34
060FE:  BNZ   6120
....................                            { 
....................                               AllowedFuntions.sendInputstatus = false; 
06100:  BCF    21.2
....................                               //fprintf(Serial,"Auto Show Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.sendInputstatus; 
06102:  MOVLB  6
06104:  CLRF   x59
06106:  BTFSC  21.2
06108:  INCF   x59,F
....................                               SentFormatMIMEPacket(InputGetEnableStatus, 1, &buf[0]); 
0610A:  MOVLW  83
0610C:  MOVWF  xC5
0610E:  MOVLW  01
06110:  MOVWF  xC6
06112:  MOVLW  06
06114:  MOVWF  xC8
06116:  MOVLW  59
06118:  MOVWF  xC7
0611A:  MOVLB  0
0611C:  CALL   1A92
....................                            } 
....................                            break; 
06120:  BRA    6362
....................                         } 
....................                         case InputGetEnableStatus: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.sendInputstatus; 
06122:  MOVLB  6
06124:  CLRF   x5A
06126:  BTFSC  21.2
06128:  INCF   x5A,F
....................                            SentFormatMIMEPacket(InputGetEnableStatus, 1, &buf[0]); 
0612A:  MOVLW  83
0612C:  MOVWF  xC5
0612E:  MOVLW  01
06130:  MOVWF  xC6
06132:  MOVLW  06
06134:  MOVWF  xC8
06136:  MOVLW  5A
06138:  MOVWF  xC7
0613A:  MOVLB  0
0613C:  CALL   1A92
....................                            break; 
06140:  BRA    6362
....................                         }  
....................                         case InputSetTimeToSense: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
06142:  MOVF   x95,W
06144:  SUBLW  02
06146:  BNZ   617E
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
06148:  MOVFF  96,65C
0614C:  MOVFF  97,65B
....................                               EntradaDigital.TimeToSense = valor; 
06150:  MOVFF  65C,389
06154:  MOVFF  65B,388
....................                               ////fprintf(Serial,"Max Customs Allowed= %lu %c%c",GoIOXstatus.maxCustoms,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = EntradaDigital.TimeToSense >> 0 & 0xFF; 
06158:  MOVFF  389,6C6
0615C:  MOVFF  388,65D
06160:  MOVLB  6
....................                               buf[1] = EntradaDigital.TimeToSense >> 8 & 0xFF; 
06162:  MOVFF  389,65E
06166:  CLRF   xC6
....................                               SentFormatMIMEPacket(InputGetTimeToSense, 2, &buf[0]); 
06168:  MOVLW  87
0616A:  MOVWF  xC5
0616C:  MOVLW  02
0616E:  MOVWF  xC6
06170:  MOVLW  06
06172:  MOVWF  xC8
06174:  MOVLW  5D
06176:  MOVWF  xC7
06178:  MOVLB  0
0617A:  CALL   1A92
....................                            } 
....................                            break; 
0617E:  BRA    6362
....................                         } 
....................                         case InputGetTimeToSense: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = EntradaDigital.TimeToSense >> 0 & 0xFF; 
06180:  MOVFF  389,6C6
06184:  MOVFF  388,65F
06188:  MOVLB  6
....................                            buf[1] = EntradaDigital.TimeToSense >> 8 & 0xFF; 
0618A:  MOVFF  389,660
0618E:  CLRF   xC6
....................                            SentFormatMIMEPacket(InputGetTimeToSense, 2, &buf[0]); 
06190:  MOVLW  87
06192:  MOVWF  xC5
06194:  MOVLW  02
06196:  MOVWF  xC6
06198:  MOVLW  06
0619A:  MOVWF  xC8
0619C:  MOVLW  5F
0619E:  MOVWF  xC7
061A0:  MOVLB  0
061A2:  CALL   1A92
....................                            break; 
061A6:  BRA    6362
....................                         } 
....................                         case InputSetStatusDataId: 
....................                         { 
....................                            if(Msg_Data[1] == 2) 
061A8:  MOVF   x95,W
061AA:  SUBLW  02
061AC:  BNZ   61E4
....................                            { 
....................                               unsigned int16 valor = make16(Msg_Data[2],Msg_Data[3]); 
061AE:  MOVFF  96,662
061B2:  MOVFF  97,661
....................                               EntradaDigital.StatusDataID = valor; 
061B6:  MOVFF  662,38D
061BA:  MOVFF  661,38C
....................                               ////fprintf(Serial,"Max Customs Allowed= %lu %c%c",GoIOXstatus.maxCustoms,0x1f,0x03); 
....................                               unsigned int8 buf[2]; 
....................                               buf[0] = EntradaDigital.StatusDataID >> 0 & 0xFF; 
061BE:  MOVFF  38D,6C6
061C2:  MOVFF  38C,663
061C6:  MOVLB  6
....................                               buf[1] = EntradaDigital.StatusDataID >> 8 & 0xFF; 
061C8:  MOVFF  38D,664
061CC:  CLRF   xC6
....................                               SentFormatMIMEPacket(InputGetStatusDataId, 2, &buf[0]); 
061CE:  MOVLW  85
061D0:  MOVWF  xC5
061D2:  MOVLW  02
061D4:  MOVWF  xC6
061D6:  MOVLW  06
061D8:  MOVWF  xC8
061DA:  MOVLW  63
061DC:  MOVWF  xC7
061DE:  MOVLB  0
061E0:  CALL   1A92
....................                            } 
....................                            break; 
061E4:  BRA    6362
....................                         } 
....................                         case InputGetStatusDataId: 
....................                         { 
....................                            unsigned int8 buf[2]; 
....................                            buf[0] = EntradaDigital.StatusDataID >> 0 & 0xFF; 
061E6:  MOVFF  38D,6C6
061EA:  MOVFF  38C,665
061EE:  MOVLB  6
....................                            buf[1] = EntradaDigital.StatusDataID >> 8 & 0xFF; 
061F0:  MOVFF  38D,666
061F4:  CLRF   xC6
....................                            SentFormatMIMEPacket(InputGetStatusDataId, 2, &buf[0]); 
061F6:  MOVLW  85
061F8:  MOVWF  xC5
061FA:  MOVLW  02
061FC:  MOVWF  xC6
061FE:  MOVLW  06
06200:  MOVWF  xC8
06202:  MOVLW  65
06204:  MOVWF  xC7
06206:  MOVLB  0
06208:  CALL   1A92
....................                            break; 
0620C:  BRA    6362
....................                         } 
....................                         case InputSetEnableSaveEeprom: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
0620E:  MOVF   x95,W
06210:  SUBLW  04
06212:  BNZ   624E
06214:  MOVF   x96,W
06216:  SUBLW  25
06218:  BNZ   624E
0621A:  MOVF   x97,W
0621C:  SUBLW  33
0621E:  BNZ   624E
06220:  MOVF   x98,W
06222:  SUBLW  41
06224:  BNZ   624E
06226:  MOVF   x99,W
06228:  SUBLW  49
0622A:  BNZ   624E
....................                            { 
....................                               AllowedFuntions.saveEepromDueInput = true; 
0622C:  BSF    21.3
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.saveEepromDueInput; 
0622E:  MOVLB  6
06230:  CLRF   x67
06232:  BTFSC  21.3
06234:  INCF   x67,F
....................                               SentFormatMIMEPacket(InputGetEnableSaveEeprom, 1, &buf[0]); 
06236:  MOVLW  91
06238:  MOVWF  xC5
0623A:  MOVLW  01
0623C:  MOVWF  xC6
0623E:  MOVLW  06
06240:  MOVWF  xC8
06242:  MOVLW  67
06244:  MOVWF  xC7
06246:  MOVLB  0
06248:  CALL   1A92
....................                            } 
0624C:  BRA    628C
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
0624E:  MOVF   x95,W
06250:  SUBLW  04
06252:  BNZ   628C
06254:  MOVF   x96,W
06256:  SUBLW  25
06258:  BNZ   628C
0625A:  MOVF   x97,W
0625C:  SUBLW  28
0625E:  BNZ   628C
06260:  MOVF   x98,W
06262:  SUBLW  31
06264:  BNZ   628C
06266:  MOVF   x99,W
06268:  SUBLW  34
0626A:  BNZ   628C
....................                            { 
....................                               AllowedFuntions.saveEepromDueInput = false; 
0626C:  BCF    21.3
....................                               //fprintf(Serial,"Auto Show Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = AllowedFuntions.saveEepromDueInput; 
0626E:  MOVLB  6
06270:  CLRF   x68
06272:  BTFSC  21.3
06274:  INCF   x68,F
....................                               SentFormatMIMEPacket(InputGetEnableSaveEeprom, 1, &buf[0]); 
06276:  MOVLW  91
06278:  MOVWF  xC5
0627A:  MOVLW  01
0627C:  MOVWF  xC6
0627E:  MOVLW  06
06280:  MOVWF  xC8
06282:  MOVLW  68
06284:  MOVWF  xC7
06286:  MOVLB  0
06288:  CALL   1A92
....................                            } 
....................                            break; 
0628C:  BRA    6362
....................                         } 
....................                         case InputGetEnableSaveEeprom: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = AllowedFuntions.saveEepromDueInput; 
0628E:  MOVLB  6
06290:  CLRF   x69
06292:  BTFSC  21.3
06294:  INCF   x69,F
....................                            SentFormatMIMEPacket(InputGetEnableSaveEeprom, 1, &buf[0]); 
06296:  MOVLW  91
06298:  MOVWF  xC5
0629A:  MOVLW  01
0629C:  MOVWF  xC6
0629E:  MOVLW  06
062A0:  MOVWF  xC8
062A2:  MOVLW  69
062A4:  MOVWF  xC7
062A6:  MOVLB  0
062A8:  CALL   1A92
....................                            break; 
062AC:  BRA    6362
....................                         } 
....................                         case InputSetValueToSave: 
....................                         { 
....................                            if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x33  && Msg_Data[4] == 0x41  && Msg_Data[5] == 0x49) 
062AE:  MOVF   x95,W
062B0:  SUBLW  04
062B2:  BNZ   62EE
062B4:  MOVF   x96,W
062B6:  SUBLW  25
062B8:  BNZ   62EE
062BA:  MOVF   x97,W
062BC:  SUBLW  33
062BE:  BNZ   62EE
062C0:  MOVF   x98,W
062C2:  SUBLW  41
062C4:  BNZ   62EE
062C6:  MOVF   x99,W
062C8:  SUBLW  49
062CA:  BNZ   62EE
....................                            { 
....................                               EepromInputValueToSave = true; 
062CC:  BSF    4D.0
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = EepromInputValueToSave; 
062CE:  MOVLB  6
062D0:  CLRF   x6A
062D2:  BTFSC  4D.0
062D4:  INCF   x6A,F
....................                               SentFormatMIMEPacket(InputGetValueToSave, 1, &buf[0]); 
062D6:  MOVLW  93
062D8:  MOVWF  xC5
062DA:  MOVLW  01
062DC:  MOVWF  xC6
062DE:  MOVLW  06
062E0:  MOVWF  xC8
062E2:  MOVLW  6A
062E4:  MOVWF  xC7
062E6:  MOVLB  0
062E8:  CALL   1A92
....................                            } 
062EC:  BRA    632C
....................                            else if(Msg_Data[1] == 4 && Msg_Data[2] == 0x25  && Msg_Data[3] == 0x28  && Msg_Data[4] == 0x31  && Msg_Data[5] == 0x34) 
062EE:  MOVF   x95,W
062F0:  SUBLW  04
062F2:  BNZ   632C
062F4:  MOVF   x96,W
062F6:  SUBLW  25
062F8:  BNZ   632C
062FA:  MOVF   x97,W
062FC:  SUBLW  28
062FE:  BNZ   632C
06300:  MOVF   x98,W
06302:  SUBLW  31
06304:  BNZ   632C
06306:  MOVF   x99,W
06308:  SUBLW  34
0630A:  BNZ   632C
....................                            { 
....................                               EepromInputValueToSave = false; 
0630C:  BCF    4D.0
....................                               //fprintf(Serial,"Auto Show Go Info Disabled%c%c",0x1f,0x03); 
....................                               unsigned int8 buf[1]; 
....................                               buf[0] = EepromInputValueToSave; 
0630E:  MOVLB  6
06310:  CLRF   x6B
06312:  BTFSC  4D.0
06314:  INCF   x6B,F
....................                               SentFormatMIMEPacket(InputGetValueToSave, 1, &buf[0]); 
06316:  MOVLW  93
06318:  MOVWF  xC5
0631A:  MOVLW  01
0631C:  MOVWF  xC6
0631E:  MOVLW  06
06320:  MOVWF  xC8
06322:  MOVLW  6B
06324:  MOVWF  xC7
06326:  MOVLB  0
06328:  CALL   1A92
....................                            } 
....................                            break; 
0632C:  BRA    6362
....................                         } 
....................                         case InputGetValueToSave: 
....................                         { 
....................                            unsigned int8 buf[1]; 
....................                            buf[0] = EepromInputValueToSave; 
0632E:  MOVLB  6
06330:  CLRF   x6C
06332:  BTFSC  4D.0
06334:  INCF   x6C,F
....................                            SentFormatMIMEPacket(InputGetValueToSave, 1, &buf[0]); 
06336:  MOVLW  93
06338:  MOVWF  xC5
0633A:  MOVLW  01
0633C:  MOVWF  xC6
0633E:  MOVLW  06
06340:  MOVWF  xC8
06342:  MOVLW  6C
06344:  MOVWF  xC7
06346:  MOVLB  0
06348:  CALL   1A92
....................                            break; 
0634C:  BRA    6362
....................                         } 
....................                         default: 
....................                         { 
....................                            //sendToPC(0xFF,Msg_Data[1],&Msg_Data[2]); 
....................                            for(unsigned int8 i = 0; i < Msg_Leng; i++) 
0634E:  MOVLB  6
06350:  CLRF   x6D
06352:  MOVLB  0
06354:  MOVF   x93,W
06356:  MOVLB  6
06358:  SUBWF  x6D,W
0635A:  BC    6360
....................                            { 
0635C:  INCF   x6D,F
0635E:  BRA    6352
....................                               //fprintf(Serial,"%X ",Msg_Data[i]); 
....................                            } 
....................                            //fprintf(Serial,"%c%c",0x1f,0x03); 
....................                            break; 
06360:  MOVLB  0
....................                         } 
....................                      }  
....................                   } 
06362:  BRA    6364
....................                   else 
....................                   { 
....................                      /*//fprintf(Serial,"Lllego mensaje invalido\n\r"); 
....................                      //fprintf(Serial,"$"); 
....................                      for(unsigned int8 i = 0; i < Msg_Leng; i++) 
....................                      { 
....................                         //fprintf(Serial,"%X",Msg_Data[i]); 
....................                      } 
....................                      //fprintf(Serial,"\n\r");*/ 
....................                   } 
....................                } 
....................                break; 
06364:  BRA    6366
....................             } 
....................             default: 
....................             { 
....................                 /*//fprintf(Serial,"\n\rData Unknown: "); 
....................                 
....................                for(unsigned int8 i = 0; i < Msg_Leng; i++) 
....................                { 
....................                   //fprintf(Serial,"%X",Msg_Data[i]); 
....................                } 
....................                //fprintf(Serial,"\n\r");*/ 
....................                break; 
....................             } 
....................          } 
....................          GoIOXstatus.msgReady = False; 
06366:  BCF    x63.2
....................       }      
....................        
....................       if(GoIOXstatus.n_TimetoRqstHOS >= GoIOXstatus.p_TimetoRqstHOS) 
06368:  MOVF   x6F,W
0636A:  SUBWF  x73,W
0636C:  BNC   6396
0636E:  BNZ   6386
06370:  MOVF   x6E,W
06372:  SUBWF  x72,W
06374:  BNC   6396
06376:  BNZ   6386
06378:  MOVF   x6D,W
0637A:  SUBWF  x71,W
0637C:  BNC   6396
0637E:  BNZ   6386
06380:  MOVF   x6C,W
06382:  SUBWF  x70,W
06384:  BNC   6396
....................       { 
....................          if(GoIOXstatus.synchronized == true) 
06386:  BTFSS  x63.0
06388:  BRA    638E
....................          { 
....................             SentRequestDeviceDataMessage(); 
0638A:  CALL   1EAE
....................          } 
....................          GoIOXstatus.n_TimetoRqstHOS = 0; 
0638E:  CLRF   x73
06390:  CLRF   x72
06392:  CLRF   x71
06394:  CLRF   x70
....................       } 
....................        
....................       if(GoIOXstatus.lastIgnition != GoDeviceInfo.Ignition) 
06396:  CLRF   00
06398:  MOVLB  4
0639A:  BTFSC  xEC.1
0639C:  BSF    00.0
0639E:  MOVLB  0
063A0:  MOVF   x7D,W
063A2:  XORWF  00,W
063A4:  ANDLW  01
063A6:  BTFSC  FD8.2
063A8:  BRA    6640
....................       { 
....................          if(GoDeviceInfo.Ignition == true) 
063AA:  MOVLB  4
063AC:  BTFSS  xEC.1
063AE:  BRA    63D4
....................          { 
....................             cmdSize = sprintf(cdmMessage, "Ignition ON"); 
063B0:  MOVLW  03
063B2:  MOVLB  3
063B4:  MOVWF  x86
063B6:  MOVLW  90
063B8:  MOVWF  x85
063BA:  MOVLW  58
063BC:  MOVWF  FF6
063BE:  MOVLW  0F
063C0:  MOVWF  FF7
063C2:  MOVLB  0
063C4:  CALL   16B8
063C8:  MOVLW  90
063CA:  MOVLB  3
063CC:  SUBWF  x85,W
063CE:  MOVWF  xD6
....................          } 
063D0:  BRA    6618
063D2:  MOVLB  4
....................          else 
....................          { 
....................             cmdSize = sprintf(cdmMessage, "Ignition OFF"); 
063D4:  MOVLW  03
063D6:  MOVLB  3
063D8:  MOVWF  x86
063DA:  MOVLW  90
063DC:  MOVWF  x85
063DE:  MOVLW  64
063E0:  MOVWF  FF6
063E2:  MOVLW  0F
063E4:  MOVWF  FF7
063E6:  MOVLB  0
063E8:  CALL   16B8
063EC:  MOVLW  90
063EE:  MOVLB  3
063F0:  SUBWF  x85,W
063F2:  MOVWF  xD6
....................             Variables structNow; 
....................             structNow = UpDateVariables(); 
063F4:  MOVLB  0
063F6:  CALL   21EC
063FA:  MOVFF  02,03
063FE:  MOVFF  01,FE1
06402:  MOVFF  02,FE2
06406:  MOVLW  06
06408:  MOVWF  FEA
0640A:  MOVLW  6E
0640C:  MOVWF  FE9
0640E:  MOVLW  27
06410:  MOVWF  01
06412:  MOVFF  FE6,FEE
06416:  DECFSZ 01,F
06418:  BRA    6412
....................             if(CompareStructs(ValoresIniciales, structNow)) 
0641A:  MOVFF  26,6C5
0641E:  MOVFF  27,6C6
06422:  MOVFF  28,6C7
06426:  MOVFF  29,6C8
0642A:  MOVFF  2A,6C9
0642E:  MOVFF  2B,6CA
06432:  MOVFF  2C,6CB
06436:  MOVFF  2D,6CC
0643A:  MOVFF  2E,6CD
0643E:  MOVFF  2F,6CE
06442:  MOVFF  30,6CF
06446:  MOVFF  31,6D0
0644A:  MOVFF  32,6D1
0644E:  MOVFF  33,6D2
06452:  MOVFF  34,6D3
06456:  MOVFF  35,6D4
0645A:  MOVFF  36,6D5
0645E:  MOVFF  37,6D6
06462:  MOVFF  38,6D7
06466:  MOVFF  39,6D8
0646A:  MOVFF  3A,6D9
0646E:  MOVFF  3B,6DA
06472:  MOVFF  3C,6DB
06476:  MOVFF  3D,6DC
0647A:  MOVFF  3E,6DD
0647E:  MOVFF  3F,6DE
06482:  MOVFF  40,6DF
06486:  MOVFF  41,6E0
0648A:  MOVFF  42,6E1
0648E:  MOVFF  43,6E2
06492:  MOVFF  44,6E3
06496:  MOVFF  45,6E4
0649A:  MOVFF  46,6E5
0649E:  MOVFF  47,6E6
064A2:  MOVFF  48,6E7
064A6:  MOVFF  49,6E8
064AA:  MOVFF  4A,6E9
064AE:  MOVFF  4B,6EA
064B2:  MOVFF  4C,6EB
064B6:  MOVFF  66E,6EC
064BA:  MOVFF  66F,6ED
064BE:  MOVFF  670,6EE
064C2:  MOVFF  671,6EF
064C6:  MOVFF  672,6F0
064CA:  MOVFF  673,6F1
064CE:  MOVFF  674,6F2
064D2:  MOVFF  675,6F3
064D6:  MOVFF  676,6F4
064DA:  MOVFF  677,6F5
064DE:  MOVFF  678,6F6
064E2:  MOVFF  679,6F7
064E6:  MOVFF  67A,6F8
064EA:  MOVFF  67B,6F9
064EE:  MOVFF  67C,6FA
064F2:  MOVFF  67D,6FB
064F6:  MOVFF  67E,6FC
064FA:  MOVFF  67F,6FD
064FE:  MOVFF  680,6FE
06502:  MOVFF  681,6FF
06506:  MOVFF  682,700
0650A:  MOVFF  683,701
0650E:  MOVFF  684,702
06512:  MOVFF  685,703
06516:  MOVFF  686,704
0651A:  MOVFF  687,705
0651E:  MOVFF  688,706
06522:  MOVFF  689,707
06526:  MOVFF  68A,708
0652A:  MOVFF  68B,709
0652E:  MOVFF  68C,70A
06532:  MOVFF  68D,70B
06536:  MOVFF  68E,70C
0653A:  MOVFF  68F,70D
0653E:  MOVFF  690,70E
06542:  MOVFF  691,70F
06546:  MOVFF  692,710
0654A:  MOVFF  693,711
0654E:  MOVFF  694,712
06552:  CALL   24F0
06556:  MOVF   01,F
06558:  BZ    6616
....................             { 
....................                EepromSave(structNow); 
0655A:  MOVFF  66E,6C5
0655E:  MOVFF  66F,6C6
06562:  MOVFF  670,6C7
06566:  MOVFF  671,6C8
0656A:  MOVFF  672,6C9
0656E:  MOVFF  673,6CA
06572:  MOVFF  674,6CB
06576:  MOVFF  675,6CC
0657A:  MOVFF  676,6CD
0657E:  MOVFF  677,6CE
06582:  MOVFF  678,6CF
06586:  MOVFF  679,6D0
0658A:  MOVFF  67A,6D1
0658E:  MOVFF  67B,6D2
06592:  MOVFF  67C,6D3
06596:  MOVFF  67D,6D4
0659A:  MOVFF  67E,6D5
0659E:  MOVFF  67F,6D6
065A2:  MOVFF  680,6D7
065A6:  MOVFF  681,6D8
065AA:  MOVFF  682,6D9
065AE:  MOVFF  683,6DA
065B2:  MOVFF  684,6DB
065B6:  MOVFF  685,6DC
065BA:  MOVFF  686,6DD
065BE:  MOVFF  687,6DE
065C2:  MOVFF  688,6DF
065C6:  MOVFF  689,6E0
065CA:  MOVFF  68A,6E1
065CE:  MOVFF  68B,6E2
065D2:  MOVFF  68C,6E3
065D6:  MOVFF  68D,6E4
065DA:  MOVFF  68E,6E5
065DE:  MOVFF  68F,6E6
065E2:  MOVFF  690,6E7
065E6:  MOVFF  691,6E8
065EA:  MOVFF  692,6E9
065EE:  MOVFF  693,6EA
065F2:  MOVFF  694,6EB
065F6:  CALL   2552
....................                unsigned int8 buf[1]; 
....................                buf[0] = BloqueEeprom; 
065FA:  MOVFF  4E,695
....................                SentFormatMIMEPacket(EepromAllSaved, 1, &buf[0]); 
065FE:  MOVLW  95
06600:  MOVLB  6
06602:  MOVWF  xC5
06604:  MOVLW  01
06606:  MOVWF  xC6
06608:  MOVLW  06
0660A:  MOVWF  xC8
0660C:  MOVLW  95
0660E:  MOVWF  xC7
06610:  MOVLB  0
06612:  CALL   1A92
06616:  MOVLB  3
....................             } 
....................          } 
....................          sendToPC(ShowIgnitionStatus,cmdSize,&cdmMessage);  
06618:  MOVLW  49
0661A:  MOVLB  6
0661C:  MOVWF  xC5
0661E:  MOVFF  3D6,6C6
06622:  MOVLW  03
06624:  MOVWF  xC8
06626:  MOVLW  90
06628:  MOVWF  xC7
0662A:  MOVLB  0
0662C:  CALL   17D0
....................          GoIOXstatus.lastIgnition = GoDeviceInfo.Ignition; 
06630:  BCF    x7D.0
06632:  MOVLB  4
06634:  BTFSS  xEC.1
06636:  BRA    663E
06638:  MOVLB  0
0663A:  BSF    x7D.0
0663C:  MOVLB  4
0663E:  MOVLB  0
....................       } 
....................        
....................       if(timeToShow < 10) 
06640:  MOVLB  4
06642:  MOVF   xD8,F
06644:  BTFSS  FD8.2
06646:  BRA    675E
06648:  MOVF   xD7,W
0664A:  SUBLW  09
0664C:  BTFSS  FD8.0
0664E:  BRA    675E
....................       { 
....................          timeToShow = 5000; 
06650:  MOVLW  13
06652:  MOVWF  xD8
06654:  MOVLW  88
06656:  MOVWF  xD7
....................          showDevice = false; 
06658:  BCF    4D.6
....................          if(GoIOXstatus.synchronized == true) 
0665A:  MOVLB  0
0665C:  BTFSS  x63.0
0665E:  BRA    675C
....................          { 
....................             cmdSize = sprintf(cdmMessage, "DBI Msg. FW: v%u.%u HW: v%u.%u",firmwareMajorVersion,firmwareMinorVersion,HardwareMajorVersion,HardwareMinorVersion); 
06660:  MOVLW  03
06662:  MOVLB  3
06664:  MOVWF  x86
06666:  MOVLW  90
06668:  MOVWF  x85
0666A:  MOVLW  72
0666C:  MOVWF  FF6
0666E:  MOVLW  0F
06670:  MOVWF  FF7
06672:  MOVLW  0E
06674:  MOVLB  6
06676:  MOVWF  xCD
06678:  MOVLB  0
0667A:  CALL   1CBA
0667E:  MOVFF  22,7D9
06682:  MOVLW  1B
06684:  MOVLB  7
06686:  MOVWF  xDA
06688:  MOVLB  0
0668A:  CALL   174A
0668E:  MOVLW  2E
06690:  MOVLB  7
06692:  MOVWF  xDB
06694:  MOVLB  0
06696:  CALL   1696
0669A:  MOVFF  23,7D9
0669E:  MOVLW  1B
066A0:  MOVLB  7
066A2:  MOVWF  xDA
066A4:  MOVLB  0
066A6:  CALL   174A
066AA:  MOVLW  85
066AC:  MOVWF  FF6
066AE:  MOVLW  0F
066B0:  MOVWF  FF7
066B2:  MOVLW  06
066B4:  MOVLB  6
066B6:  MOVWF  xCD
066B8:  MOVLB  0
066BA:  CALL   1CBA
066BE:  MOVFF  24,7D9
066C2:  MOVLW  1B
066C4:  MOVLB  7
066C6:  MOVWF  xDA
066C8:  MOVLB  0
066CA:  CALL   174A
066CE:  MOVLW  2E
066D0:  MOVLB  7
066D2:  MOVWF  xDB
066D4:  MOVLB  0
066D6:  CALL   1696
066DA:  MOVFF  25,7D9
066DE:  MOVLW  1B
066E0:  MOVLB  7
066E2:  MOVWF  xDA
066E4:  MOVLB  0
066E6:  CALL   174A
066EA:  MOVLW  90
066EC:  MOVLB  3
066EE:  SUBWF  x85,W
066F0:  MOVWF  xD6
....................             SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
066F2:  MOVFF  3D6,6C5
066F6:  MOVLW  03
066F8:  MOVLB  6
066FA:  MOVWF  xC7
066FC:  MOVLW  90
066FE:  MOVWF  xC6
06700:  MOVLB  0
06702:  CALL   1DA0
....................              
....................             delay_ms(50); 
06706:  MOVLW  32
06708:  MOVLB  6
0670A:  MOVWF  xC7
0670C:  MOVLB  0
0670E:  CALL   0FC8
....................             cmdSize = sprintf(cdmMessage, "DBI EEPROM Block: %u",BloqueEeprom); 
06712:  MOVLW  03
06714:  MOVLB  3
06716:  MOVWF  x86
06718:  MOVLW  90
0671A:  MOVWF  x85
0671C:  MOVLW  92
0671E:  MOVWF  FF6
06720:  MOVLW  0F
06722:  MOVWF  FF7
06724:  MOVLW  12
06726:  MOVLB  6
06728:  MOVWF  xCD
0672A:  MOVLB  0
0672C:  CALL   1CBA
06730:  MOVFF  4E,7D9
06734:  MOVLW  1B
06736:  MOVLB  7
06738:  MOVWF  xDA
0673A:  MOVLB  0
0673C:  CALL   174A
06740:  MOVLW  90
06742:  MOVLB  3
06744:  SUBWF  x85,W
06746:  MOVWF  xD6
....................             SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
06748:  MOVFF  3D6,6C5
0674C:  MOVLW  03
0674E:  MOVLB  6
06750:  MOVWF  xC7
06752:  MOVLW  90
06754:  MOVWF  xC6
06756:  MOVLB  0
06758:  CALL   1DA0
0675C:  MOVLB  4
....................          } 
....................       } 
....................        
....................       if(GoIOXstatus.n_TimetoHeratBeat >= GoIOXstatus.p_TimetoHearBeat) 
0675E:  MOVLB  0
06760:  MOVF   x89,W
06762:  SUBWF  x8D,W
06764:  BNC   67BE
06766:  BNZ   677E
06768:  MOVF   x88,W
0676A:  SUBWF  x8C,W
0676C:  BNC   67BE
0676E:  BNZ   677E
06770:  MOVF   x87,W
06772:  SUBWF  x8B,W
06774:  BNC   67BE
06776:  BNZ   677E
06778:  MOVF   x86,W
0677A:  SUBWF  x8A,W
0677C:  BNC   67BE
....................       { 
....................          GoIOXstatus.n_TimetoHeratBeat = 0; 
0677E:  CLRF   x8D
06780:  CLRF   x8C
06782:  CLRF   x8B
06784:  CLRF   x8A
....................          if(GoIOXstatus.synchronized == true) 
06786:  BTFSS  x63.0
06788:  BRA    67BE
....................          { 
....................             cmdSize = sprintf(cdmMessage, "DBI HeartBeat!"); 
0678A:  MOVLW  03
0678C:  MOVLB  3
0678E:  MOVWF  x86
06790:  MOVLW  90
06792:  MOVWF  x85
06794:  MOVLW  A8
06796:  MOVWF  FF6
06798:  MOVLW  0F
0679A:  MOVWF  FF7
0679C:  MOVLB  0
0679E:  CALL   16B8
067A2:  MOVLW  90
067A4:  MOVLB  3
067A6:  SUBWF  x85,W
067A8:  MOVWF  xD6
....................             SentFreeFormatThirdPartyData(cmdSize, &cdmMessage);  
067AA:  MOVFF  3D6,6C5
067AE:  MOVLW  03
067B0:  MOVLB  6
067B2:  MOVWF  xC7
067B4:  MOVLW  90
067B6:  MOVWF  xC6
067B8:  MOVLB  0
067BA:  CALL   1DA0
....................          } 
....................       } 
....................        
....................       if(InputEventDetected == true) 
067BE:  BTFSS  4D.4
067C0:  BRA    6A98
....................       {   
....................          if(AllowedFuntions.showInputstatus == true) 
067C2:  BTFSS  21.1
067C4:  BRA    681E
....................          { 
....................             cmdSize = sprintf(cdmMessage, "Input Value: %u",!InputStatus); 
067C6:  MOVLW  00
067C8:  BTFSS  4D.5
067CA:  MOVLW  01
067CC:  MOVLB  6
067CE:  MOVWF  xC5
067D0:  MOVLW  03
067D2:  MOVLB  3
067D4:  MOVWF  x86
067D6:  MOVLW  90
067D8:  MOVWF  x85
067DA:  MOVLW  B8
067DC:  MOVWF  FF6
067DE:  MOVLW  0F
067E0:  MOVWF  FF7
067E2:  MOVLW  0D
067E4:  MOVLB  6
067E6:  MOVWF  xCD
067E8:  MOVLB  0
067EA:  CALL   1CBA
067EE:  MOVFF  6C5,7D9
067F2:  MOVLW  1B
067F4:  MOVLB  7
067F6:  MOVWF  xDA
067F8:  MOVLB  0
067FA:  CALL   174A
067FE:  MOVLW  90
06800:  MOVLB  3
06802:  SUBWF  x85,W
06804:  MOVWF  xD6
....................             sendToPC(InputShowStatus,cmdSize,&cdmMessage); 
06806:  MOVLW  71
06808:  MOVLB  6
0680A:  MOVWF  xC5
0680C:  MOVFF  3D6,6C6
06810:  MOVLW  03
06812:  MOVWF  xC8
06814:  MOVLW  90
06816:  MOVWF  xC7
06818:  MOVLB  0
0681A:  CALL   17D0
....................          } 
....................           
....................          if(AllowedFuntions.SendInputstatus == true) 
0681E:  BTFSS  21.2
06820:  BRA    685A
....................          { 
....................             unsigned int16 idStatus = EntradaDigital.StatusDataID; 
....................             unsigned int32 dataStatus = make32(0,0,0,!InputStatus); 
06822:  MOVFF  38D,697
06826:  MOVFF  38C,696
0682A:  MOVLW  00
0682C:  BTFSS  4D.5
0682E:  MOVLW  01
06830:  MOVLB  6
06832:  CLRF   x9B
06834:  CLRF   x9A
06836:  CLRF   x99
06838:  MOVWF  x98
....................             SentThirdPartyDataStatusData(0,idStatus, dataStatus);  
0683A:  CLRF   xC5
0683C:  MOVFF  697,6C7
06840:  MOVFF  696,6C6
06844:  MOVFF  69B,6CB
06848:  MOVFF  69A,6CA
0684C:  MOVFF  699,6C9
06850:  MOVFF  698,6C8
06854:  MOVLB  0
06856:  CALL   1E20
....................          } 
....................           
....................          if(AllowedFuntions.saveEepromDueInput == true) 
0685A:  BTFSS  21.3
0685C:  BRA    6A92
....................          { 
....................             unsigned int1 status = !InputStatus; 
0685E:  MOVLB  6
06860:  BCF    x9C.0
06862:  BTFSS  4D.5
06864:  BSF    x9C.0
....................             if(status == EepromInputValueToSave) 
06866:  MOVF   x9C,W
06868:  XORWF  4D,W
0686A:  ANDLW  01
0686C:  BTFSS  FD8.2
0686E:  BRA    6A94
....................             { 
....................                Variables structNow; 
....................                structNow = UpDateVariables(); 
06870:  MOVLB  0
06872:  CALL   21EC
06876:  MOVFF  02,03
0687A:  MOVFF  01,FE1
0687E:  MOVFF  02,FE2
06882:  MOVLW  06
06884:  MOVWF  FEA
06886:  MOVLW  9D
06888:  MOVWF  FE9
0688A:  MOVLW  27
0688C:  MOVWF  01
0688E:  MOVFF  FE6,FEE
06892:  DECFSZ 01,F
06894:  BRA    688E
....................                if(CompareStructs(ValoresIniciales, structNow)) 
06896:  MOVFF  26,6C5
0689A:  MOVFF  27,6C6
0689E:  MOVFF  28,6C7
068A2:  MOVFF  29,6C8
068A6:  MOVFF  2A,6C9
068AA:  MOVFF  2B,6CA
068AE:  MOVFF  2C,6CB
068B2:  MOVFF  2D,6CC
068B6:  MOVFF  2E,6CD
068BA:  MOVFF  2F,6CE
068BE:  MOVFF  30,6CF
068C2:  MOVFF  31,6D0
068C6:  MOVFF  32,6D1
068CA:  MOVFF  33,6D2
068CE:  MOVFF  34,6D3
068D2:  MOVFF  35,6D4
068D6:  MOVFF  36,6D5
068DA:  MOVFF  37,6D6
068DE:  MOVFF  38,6D7
068E2:  MOVFF  39,6D8
068E6:  MOVFF  3A,6D9
068EA:  MOVFF  3B,6DA
068EE:  MOVFF  3C,6DB
068F2:  MOVFF  3D,6DC
068F6:  MOVFF  3E,6DD
068FA:  MOVFF  3F,6DE
068FE:  MOVFF  40,6DF
06902:  MOVFF  41,6E0
06906:  MOVFF  42,6E1
0690A:  MOVFF  43,6E2
0690E:  MOVFF  44,6E3
06912:  MOVFF  45,6E4
06916:  MOVFF  46,6E5
0691A:  MOVFF  47,6E6
0691E:  MOVFF  48,6E7
06922:  MOVFF  49,6E8
06926:  MOVFF  4A,6E9
0692A:  MOVFF  4B,6EA
0692E:  MOVFF  4C,6EB
06932:  MOVFF  69D,6EC
06936:  MOVFF  69E,6ED
0693A:  MOVFF  69F,6EE
0693E:  MOVFF  6A0,6EF
06942:  MOVFF  6A1,6F0
06946:  MOVFF  6A2,6F1
0694A:  MOVFF  6A3,6F2
0694E:  MOVFF  6A4,6F3
06952:  MOVFF  6A5,6F4
06956:  MOVFF  6A6,6F5
0695A:  MOVFF  6A7,6F6
0695E:  MOVFF  6A8,6F7
06962:  MOVFF  6A9,6F8
06966:  MOVFF  6AA,6F9
0696A:  MOVFF  6AB,6FA
0696E:  MOVFF  6AC,6FB
06972:  MOVFF  6AD,6FC
06976:  MOVFF  6AE,6FD
0697A:  MOVFF  6AF,6FE
0697E:  MOVFF  6B0,6FF
06982:  MOVFF  6B1,700
06986:  MOVFF  6B2,701
0698A:  MOVFF  6B3,702
0698E:  MOVFF  6B4,703
06992:  MOVFF  6B5,704
06996:  MOVFF  6B6,705
0699A:  MOVFF  6B7,706
0699E:  MOVFF  6B8,707
069A2:  MOVFF  6B9,708
069A6:  MOVFF  6BA,709
069AA:  MOVFF  6BB,70A
069AE:  MOVFF  6BC,70B
069B2:  MOVFF  6BD,70C
069B6:  MOVFF  6BE,70D
069BA:  MOVFF  6BF,70E
069BE:  MOVFF  6C0,70F
069C2:  MOVFF  6C1,710
069C6:  MOVFF  6C2,711
069CA:  MOVFF  6C3,712
069CE:  CALL   24F0
069D2:  MOVF   01,F
069D4:  BZ    6A92
....................                { 
....................                   EepromSave(structNow); 
069D6:  MOVFF  69D,6C5
069DA:  MOVFF  69E,6C6
069DE:  MOVFF  69F,6C7
069E2:  MOVFF  6A0,6C8
069E6:  MOVFF  6A1,6C9
069EA:  MOVFF  6A2,6CA
069EE:  MOVFF  6A3,6CB
069F2:  MOVFF  6A4,6CC
069F6:  MOVFF  6A5,6CD
069FA:  MOVFF  6A6,6CE
069FE:  MOVFF  6A7,6CF
06A02:  MOVFF  6A8,6D0
06A06:  MOVFF  6A9,6D1
06A0A:  MOVFF  6AA,6D2
06A0E:  MOVFF  6AB,6D3
06A12:  MOVFF  6AC,6D4
06A16:  MOVFF  6AD,6D5
06A1A:  MOVFF  6AE,6D6
06A1E:  MOVFF  6AF,6D7
06A22:  MOVFF  6B0,6D8
06A26:  MOVFF  6B1,6D9
06A2A:  MOVFF  6B2,6DA
06A2E:  MOVFF  6B3,6DB
06A32:  MOVFF  6B4,6DC
06A36:  MOVFF  6B5,6DD
06A3A:  MOVFF  6B6,6DE
06A3E:  MOVFF  6B7,6DF
06A42:  MOVFF  6B8,6E0
06A46:  MOVFF  6B9,6E1
06A4A:  MOVFF  6BA,6E2
06A4E:  MOVFF  6BB,6E3
06A52:  MOVFF  6BC,6E4
06A56:  MOVFF  6BD,6E5
06A5A:  MOVFF  6BE,6E6
06A5E:  MOVFF  6BF,6E7
06A62:  MOVFF  6C0,6E8
06A66:  MOVFF  6C1,6E9
06A6A:  MOVFF  6C2,6EA
06A6E:  MOVFF  6C3,6EB
06A72:  CALL   2552
....................                   unsigned int8 buf[1]; 
....................                   buf[0] = BloqueEeprom; 
06A76:  MOVFF  4E,6C4
....................                   SentFormatMIMEPacket(EepromAllSaved, 1, &buf[0]); 
06A7A:  MOVLW  95
06A7C:  MOVLB  6
06A7E:  MOVWF  xC5
06A80:  MOVLW  01
06A82:  MOVWF  xC6
06A84:  MOVLW  06
06A86:  MOVWF  xC8
06A88:  MOVLW  C4
06A8A:  MOVWF  xC7
06A8C:  MOVLB  0
06A8E:  CALL   1A92
06A92:  MOVLB  6
....................                } 
....................             } 
....................          } 
....................           
....................          InputEventDetected = false; 
06A94:  BCF    4D.4
06A96:  MOVLB  0
....................       } 
....................        
....................       restart_wdt(); 
06A98:  CLRWDT
06A9A:  GOTO   2730
....................    } 
.................... } 
....................  
06A9E:  SLEEP 
.................... Variables UpDateVariables() 
.................... { 
....................    Variables ValorActual; 
....................    ValorActual.MIMEackByGo            = GoIOXstatus.p_timeOutMime; 
*
021EC:  MOVFF  51,6CC
021F0:  MOVFF  50,6CB
....................    ValorActual.MIMEackByServer        = GoIOXstatus.p_timeOutACKFromServer; 
021F4:  MOVFF  81,6D0
021F8:  MOVFF  80,6CF
021FC:  MOVFF  7F,6CE
02200:  MOVFF  7E,6CD
....................    ValorActual.MIMEmax                = GoIOXstatus.maxMIMEs;   
02204:  MOVFF  55,6D2
02208:  MOVFF  54,6D1
....................    ValorActual.MIMEoutEnabled         = AllowedFuntions.MIMEout;    
0220C:  MOVLB  6
0220E:  BCF    xD3.0
02210:  BTFSC  20.3
02212:  BSF    xD3.0
....................    ValorActual.MIMEinEnabled          = AllowedFuntions.MIMEin;    
02214:  BCF    xD3.1
02216:  BTFSC  20.2
02218:  BSF    xD3.1
....................    ValorActual.MIMEWaitACKtoSend      = AllowedFuntions.blockMIMEByACK;    
0221A:  BCF    xD3.2
0221C:  BTFSC  21.0
0221E:  BSF    xD3.2
....................    ValorActual.MIMEautoResponseACK    = AllowedFuntions.MimeACKResponse;   
02220:  BCF    xD3.3
02222:  BTFSC  20.4
02224:  BSF    xD3.3
....................     
....................    ValorActual.CSackByGo              = GoIOXstatus.p_timeOutCustom; 
02226:  MOVFF  5D,6D5
0222A:  MOVFF  5C,6D4
....................    ValorActual.CSmax                  = GoIOXstatus.maxCustoms;  
0222E:  MOVFF  65,6D7
02232:  MOVFF  64,6D6
....................    ValorActual.CScustomEnabled        = AllowedFuntions.customData; 
02236:  BCF    xD3.4
02238:  BTFSC  20.0
0223A:  BSF    xD3.4
....................    ValorActual.CSstatusEnabled        = AllowedFuntions.StatusData; 
0223C:  BCF    xD3.5
0223E:  BTFSC  20.1
02240:  BSF    xD3.5
....................     
....................    ValorActual.HOStimeToResquest      = GoIOXstatus.p_TimetoRqstHOS; 
02242:  MOVFF  6F,6DB
02246:  MOVFF  6E,6DA
0224A:  MOVFF  6D,6D9
0224E:  MOVFF  6C,6D8
....................    ValorActual.HOSrqstEnabled         = AllowedFuntions.rqstGoInfo;    
02252:  BCF    xD3.7
02254:  BTFSC  20.5
02256:  BSF    xD3.7
....................    ValorActual.HOSautoShowEnabled     = AllowedFuntions.showGoInfo;   
02258:  BCF    xD3.6
0225A:  BTFSC  20.7
0225C:  BSF    xD3.6
....................       
....................    ValorActual.ACTmode                = Actuator.OutputMode; 
0225E:  MOVFF  2A6,6DC
....................    ValorActual.ACTstatus              = Actuator.OutputState; 
02262:  BCF    xE9.0
02264:  MOVLB  2
02266:  BTFSS  xA7.0
02268:  BRA    2270
0226A:  MOVLB  6
0226C:  BSF    xE9.0
0226E:  MOVLB  2
....................    ValorActual.ACTtoReset             = Actuator.TimeToReset; 
02270:  MOVFF  2A0,6E0
02274:  MOVFF  29F,6DF
02278:  MOVFF  29E,6DE
0227C:  MOVFF  29D,6DD
....................    ValorActual.ACTinReset             = Actuator.TimeInReset; 
02280:  MOVFF  29C,6E4
02284:  MOVFF  29B,6E3
02288:  MOVFF  29A,6E2
0228C:  MOVFF  299,6E1
....................    ValorActual.ACTtimeOutPIN          = Actuator.P_TimeOutPass; 
02290:  MOVFF  2AE,6E8
02294:  MOVFF  2AD,6E7
02298:  MOVFF  2AC,6E6
0229C:  MOVFF  2AB,6E5
....................    ValorActual.ACTenableClientRequest = AllowedFuntions.rqstActuator; 
022A0:  MOVLB  6
022A2:  BCF    xE9.1
022A4:  BTFSC  20.6
022A6:  BSF    xE9.1
....................     
....................    ValorActual.DBItimeToHeartBeat     = GoIOXstatus.p_TimetoHearBeat; 
022A8:  MOVFF  89,6ED
022AC:  MOVFF  88,6EC
022B0:  MOVFF  87,6EB
022B4:  MOVFF  86,6EA
....................    ValorActual.DBIheartBeatEnabled    = GoIOXstatus.HeartbeatEnable; 
022B8:  BCF    xE9.2
022BA:  MOVLB  0
022BC:  BTFSS  x8E.0
022BE:  BRA    22C6
022C0:  MOVLB  6
022C2:  BSF    xE9.2
022C4:  MOVLB  0
....................     
....................    ValorActual.InputEnableShow        = AllowedFuntions.showInputstatus; 
022C6:  MOVLB  6
022C8:  BCF    xE9.3
022CA:  BTFSC  21.1
022CC:  BSF    xE9.3
....................    ValorActual.InputEnablestatus      = AllowedFuntions.sendInputstatus; 
022CE:  BCF    xE9.4
022D0:  BTFSC  21.2
022D2:  BSF    xE9.4
....................    ValorActual.InputEnableSaveEeprom  = AllowedFuntions.saveEepromDueInput; 
022D4:  BCF    xE9.5
022D6:  BTFSC  21.3
022D8:  BSF    xE9.5
....................    ValorActual.InputTimeToSense       = EntradaDigital.TimeToSense; 
022DA:  MOVFF  389,6F1
022DE:  MOVFF  388,6F0
....................    ValorActual.InputStatusDataId      = EntradaDigital.StatusDataID; 
022E2:  MOVFF  38D,6EF
022E6:  MOVFF  38C,6EE
....................    ValorActual.InputValueToSave       = EepromInputValueToSave; 
022EA:  BCF    xE9.6
022EC:  BTFSC  4D.0
022EE:  BSF    xE9.6
....................    ValorActual.empty = 0; 
022F0:  BCF    xE9.7
....................     
....................    return ValorActual; 
022F2:  MOVLW  CB
022F4:  MOVWF  01
022F6:  MOVLW  06
022F8:  MOVWF  02
022FA:  MOVLB  0
022FC:  RETURN 0
.................... } 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: D515   VREGSLEEP INTRC_HP SOSC_DIG NOXINST ECH_IO PLLEN FCMEN IESO
   Word  2: 2D78   PUT NOBROWNOUT BORV18 ZPBORM WDT_NOSLEEP WDT2048
   Word  3: 0900   CANB MSSPMSK7
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
